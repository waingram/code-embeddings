class HundredDoors { public static void main ( String [ ] args ) { boolean [ ] doors = new boolean [ 101 ] ; for ( int i = 1 ; i < doors . length ; i ++ ) { for ( int j = i ; j < doors . length ; j += i ) { doors [ j ] = ! doors [ j ] ; } } for ( int i = 1 ; i < doors . length ; i ++ ) { if ( doors [ i ] ) { System . out . printf ( "Door %d is open.%n" , i ) ; } } } } 
class HundredDoors { public static void main ( String [ ] args ) { for ( int i = 1 ; i <= 10 ; i ++ ) System . out . printf ( "Door %d is open.%n" , i * i ) ; } } 
import java . util . stream . Collectors ; import java . util . stream . IntStream ; class HundredDoors { public static void main ( String args [ ] ) { String openDoors = IntStream . rangeClosed ( 1 , 100 ) . filter ( i -> Math . pow ( ( int ) Math . sqrt ( i ) , 2 ) == i ) . mapToObj ( Integer :: toString ) . collect ( Collectors . joining ( ", " ) ) ; System . out . printf ( "Open doors: %s%n" , openDoors ) ; } } 
import java . util . * ; public class Game24 { static Random r = new Random ( ) ; public static void main ( String [ ] args ) { int [ ] digits = randomDigits ( ) ; Scanner in = new Scanner ( System . in ) ; System . out . print ( "Make 24 using these digits: " ) ; System . out . println ( Arrays . toString ( digits ) ) ; System . out . print ( "> " ) ; Stack < Float > s = new Stack < > ( ) ; long total = 0 ; for ( char c : in . nextLine ( ) . toCharArray ( ) ) { if ( '0' <= c && c <= '9' ) { int d = c - '0' ; total += ( 1 << ( d * 5 ) ) ; s . push ( ( float ) d ) ; } else if ( "+/-*" . indexOf ( c ) != - 1 ) { s . push ( applyOperator ( s . pop ( ) , s . pop ( ) , c ) ) ; } } if ( tallyDigits ( digits ) != total ) System . out . print ( "Not the same digits. " ) ; else if ( Math . abs ( 24 - s . peek ( ) ) < 0.001F ) System . out . println ( "Correct!" ) ; else System . out . print ( "Not correct." ) ; } static float applyOperator ( float a , float b , char c ) { switch ( c ) { case '+' : return a + b ; case '-' : return b - a ; case '*' : return a * b ; case '/' : return b / a ; default : return Float . NaN ; } } static long tallyDigits ( int [ ] a ) { long total = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) total += ( 1 << ( a [ i ] * 5 ) ) ; return total ; } static int [ ] randomDigits ( ) { int [ ] result = new int [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) result [ i ] = r . nextInt ( 9 ) + 1 ; return result ; } } 
import java . util . * ; public class Sum2 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; System . out . println ( in . nextInt ( ) + in . nextInt ( ) ) ; } } 
import java . io . * ; import java . util . * ; public class SumDif { StreamTokenizer in ; PrintWriter out ; public static void main ( String [ ] args ) throws IOException { new SumDif ( ) . run ( ) ; } private int nextInt ( ) throws IOException { in . nextToken ( ) ; return ( int ) in . nval ; } public void run ( ) throws IOException { in = new StreamTokenizer ( new BufferedReader ( new InputStreamReader ( System . in ) ) ) ; out = new PrintWriter ( new OutputStreamWriter ( System . out ) ) ; solve ( ) ; out . flush ( ) ; } private void solve ( ) throws IOException { out . println ( nextInt ( ) + nextInt ( ) ) ; } } 
import java . io . * ; import java . nio . charset . Charset ; public class AplusB { public static void main ( String [ ] args ) throws IOException { StreamTokenizer in = new StreamTokenizer ( new InputStreamReader ( System . in , Charset . defaultCharset ( ) ) ) ; in . nextToken ( ) ; int a = ( int ) in . nval ; in . nextToken ( ) ; int b = ( int ) in . nval ; try ( Writer out = new OutputStreamWriter ( System . out , Charset . defaultCharset ( ) ) ) { out . write ( Integer . toString ( a + b ) ) ; } } } 
grammar aplusb ; options { language = Java ; } aplusb : ( WS * e1 = Num WS + e2 = Num NEWLINE { System . out . println ( $e1 . text + " + " + $e2 . text + " = " + ( Integer . parseInt ( $e1 . text ) + Integer . parseInt ( $e2 . text ) ) ) ; } ) + ; Num : '-' ? ( '0' . . '9' ) + ; WS : ( ' ' | '\t' ) ; NEWLINE : WS * '\r' ? '\n' ; 
import java . util . Arrays ; import java . util . Collections ; import java . util . List ; public class ABC { public static void main ( String [ ] args ) { List < String > blocks = Arrays . asList ( "BO" , "XK" , "DQ" , "CP" , "NA" , "GT" , "RE" , "TG" , "QD" , "FS" , "JW" , "HU" , "VI" , "AN" , "OB" , "ER" , "FS" , "LY" , "PC" , "ZM" ) ; for ( String word : Arrays . asList ( "" , "A" , "BARK" , "BOOK" , "TREAT" , "COMMON" , "SQUAD" , "CONFUSE" ) ) { System . out . printf ( "%s: %s%n" , word . isEmpty ( ) ? "\"\"" : word , canMakeWord ( word , blocks ) ) ; } } public static boolean canMakeWord ( String word , List < String > blocks ) { if ( word . isEmpty ( ) ) return true ; char c = word . charAt ( 0 ) ; for ( int i = 0 ; i < blocks . size ( ) ; i ++ ) { String b = blocks . get ( i ) ; if ( b . charAt ( 0 ) != c && b . charAt ( 1 ) != c ) continue ; Collections . swap ( blocks , 0 , i ) ; if ( canMakeWord ( word . substring ( 1 ) , blocks . subList ( 1 , blocks . size ( ) ) ) ) return true ; Collections . swap ( blocks , 0 , i ) ; } return false ; } } 
public class Accumulator { private double sum ; public Accumulator ( double sum0 ) { sum = sum0 ; } public double call ( double n ) { return sum += n ; } public static void main ( String [ ] args ) { Accumulator x = new Accumulator ( 1 ) ; x . call ( 5 ) ; System . out . println ( new Accumulator ( 3 ) ) ; System . out . println ( x . call ( 2.3 ) ) ; } } 
public class Accumulator { private double sum ; public Accumulator ( double sum0 ) { sum = sum0 ; } public double call ( double n ) { return sum += n ; } public static void main ( String [ ] args ) { Accumulator x = new Accumulator ( 1 ) ; x . call ( 5 ) ; System . out . println ( new Accumulator ( 3 ) ) ; System . out . println ( x . call ( 2.3 ) ) ; } } 
public class AccumulatorFactory { public interface Accumulator { double add ( double x ) ; } private static Accumulator accumulator ( final double initial ) { return new Accumulator ( ) { private double sum = initial ; @ Override public double add ( double x ) { return sum += x ; } } ; } public static void main ( String [ ] args ) { Accumulator x = accumulator ( 1.0 ) ; x . add ( 5.0 ) ; System . out . println ( accumulator ( 3.0 ) ) ; System . out . println ( x . add ( 2.3 ) ) ; } } 
import java . util . function . DoubleUnaryOperator ; public interface AccumulatorFactory { public static DoubleUnaryOperator accumulator ( double element ) { double [ ] sum = { element } ; return value -> sum [ 0 ] += value ; } public static void main ( String ... arguments ) { DoubleUnaryOperator x = accumulator ( 1.0 ) ; x . applyAsDouble ( 5.0 ) ; System . out . println ( accumulator ( 3.0 ) ) ; System . out . println ( x . applyAsDouble ( 2.3 ) ) ; } } 
public class Accumulator { private Long sumA ; private double sumB ; public Accumulator ( Number sum0 ) { if ( sum0 instanceof Double ) { sumB = sum0 . doubleValue ( ) ; } else { sumA = sum0 . longValue ( ) ; } } public Number call ( Number n ) { if ( sumA != null ) { if ( n instanceof Double ) { sumB = n . doubleValue ( ) + sumA ; sumA = null ; return sumB ; } return sumA += n . longValue ( ) ; } return sumB += n . doubleValue ( ) ; } public static void main ( String [ ] args ) { Accumulator x = new Accumulator ( 1 ) ; x . call ( 5 ) ; Accumulator y = new Accumulator ( 3 ) ; System . out . println ( y + " has value " + y . call ( 0 ) ) ; System . out . println ( x . call ( 2.3 ) ) ; } } 
import java . math . BigInteger ; public static BigInteger ack ( BigInteger m , BigInteger n ) { return m . equals ( BigInteger . ZERO ) ? n . add ( BigInteger . ONE ) : ack ( m . subtract ( BigInteger . ONE ) , n . equals ( BigInteger . ZERO ) ? BigInteger . ONE : ack ( m , n . subtract ( BigInteger . ONE ) ) ) ; } 
@ FunctionalInterface public interface FunctionalField < FIELD extends Enum < ? > > { public Object untypedField ( FIELD field ) ; @ SuppressWarnings ( "unchecked" ) public default < VALUE > VALUE field ( FIELD field ) { return ( VALUE ) untypedField ( field ) ; } } 
import java . util . function . BiFunction ; import java . util . function . Function ; import java . util . function . Predicate ; import java . util . function . UnaryOperator ; import java . util . stream . Stream ; public interface TailRecursive { public static < INPUT , INTERMEDIARY , OUTPUT > Function < INPUT , OUTPUT > new_ ( Function < INPUT , INTERMEDIARY > toIntermediary , UnaryOperator < INTERMEDIARY > unaryOperator , Predicate < INTERMEDIARY > predicate , Function < INTERMEDIARY , OUTPUT > toOutput ) { return input -> $ . new_ ( Stream . iterate ( toIntermediary . apply ( input ) , unaryOperator ) , predicate , toOutput ) ; } public static < INPUT1 , INPUT2 , INTERMEDIARY , OUTPUT > BiFunction < INPUT1 , INPUT2 , OUTPUT > new_ ( BiFunction < INPUT1 , INPUT2 , INTERMEDIARY > toIntermediary , UnaryOperator < INTERMEDIARY > unaryOperator , Predicate < INTERMEDIARY > predicate , Function < INTERMEDIARY , OUTPUT > toOutput ) { return ( input1 , input2 ) -> $ . new_ ( Stream . iterate ( toIntermediary . apply ( input1 , input2 ) , unaryOperator ) , predicate , toOutput ) ; } public enum $ { $$ ; private static < INTERMEDIARY , OUTPUT > OUTPUT new_ ( Stream < INTERMEDIARY > stream , Predicate < INTERMEDIARY > predicate , Function < INTERMEDIARY , OUTPUT > function ) { return stream . filter ( predicate ) . map ( function ) . findAny ( ) . orElseThrow ( RuntimeException :: new ) ; } } } 
import java . math . BigInteger ; import java . util . Stack ; import java . util . function . BinaryOperator ; import java . util . stream . Collectors ; import java . util . stream . Stream ; public interface Ackermann { public static Ackermann new_ ( BigInteger number1 , BigInteger number2 , Stack < BigInteger > stack , boolean flag ) { return $ . new_ ( number1 , number2 , stack , flag ) ; } public static void main ( String ... arguments ) { $ . main ( arguments ) ; } public BigInteger number1 ( ) ; public BigInteger number2 ( ) ; public Stack < BigInteger > stack ( ) ; public boolean flag ( ) ; public enum $ { $$ ; private static final BigInteger ZERO = BigInteger . ZERO ; private static final BigInteger ONE = BigInteger . ONE ; private static final BigInteger TWO = BigInteger . valueOf ( 2 ) ; private static final BigInteger THREE = BigInteger . valueOf ( 3 ) ; private static final BigInteger FOUR = BigInteger . valueOf ( 4 ) ; private static Ackermann new_ ( BigInteger number1 , BigInteger number2 , Stack < BigInteger > stack , boolean flag ) { return ( FunctionalAckermann ) field -> { switch ( field ) { case number1 : return number1 ; case number2 : return number2 ; case stack : return stack ; case flag : return flag ; default : throw new UnsupportedOperationException ( field instanceof Field ? "Field checker has not been updated properly." : "Field is not of the correct type." ) ; } } ; } private static final BinaryOperator < BigInteger > ACKERMANN = TailRecursive . new_ ( ( BigInteger number1 , BigInteger number2 ) -> new_ ( number1 , number2 , Stream . of ( number1 ) . collect ( Collectors . toCollection ( Stack :: new ) ) , false ) , ackermann -> { BigInteger number1 = ackermann . number1 ( ) ; BigInteger number2 = ackermann . number2 ( ) ; Stack < BigInteger > stack = ackermann . stack ( ) ; if ( ! stack . empty ( ) && ! ackermann . flag ( ) ) { number1 = stack . pop ( ) ; } switch ( number1 . intValue ( ) ) { case 0 : return new_ ( number1 , number2 . add ( ONE ) , stack , false ) ; case 1 : return new_ ( number1 , number2 . add ( TWO ) , stack , false ) ; case 2 : return new_ ( number1 , number2 . multiply ( TWO ) . add ( THREE ) , stack , false ) ; default : if ( ZERO . equals ( number2 ) ) { return new_ ( number1 . subtract ( ONE ) , ONE , stack , true ) ; } else { stack . push ( number1 . subtract ( ONE ) ) ; return new_ ( number1 , number2 . subtract ( ONE ) , stack , true ) ; } } } , ackermann -> ackermann . stack ( ) . empty ( ) , Ackermann :: number2 ) :: apply ; private static void main ( String ... arguments ) { System . out . println ( ACKERMANN . apply ( FOUR , TWO ) ) ; } private enum Field { number1 , number2 , stack , flag } @ FunctionalInterface private interface FunctionalAckermann extends FunctionalField < Field > , Ackermann { @ Override public default BigInteger number1 ( ) { return field ( Field . number1 ) ; } @ Override public default BigInteger number2 ( ) { return field ( Field . number2 ) ; } @ Override public default Stack < BigInteger > stack ( ) { return field ( Field . stack ) ; } @ Override public default boolean flag ( ) { return field ( Field . flag ) ; } } } } 
import java . io . File ; import java . io . IOException ; import java . nio . file . Files ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Comparator ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class DerangedAnagrams { public static void main ( String [ ] args ) throws IOException { List < String > words = Files . readAllLines ( new File ( "unixdict.txt" ) . toPath ( ) ) ; printLongestDerangedAnagram ( words ) ; } private static void printLongestDerangedAnagram ( List < String > words ) { words . sort ( Comparator . comparingInt ( String :: length ) . reversed ( ) . thenComparing ( String :: toString ) ) ; Map < String , ArrayList < String > > map = new HashMap < > ( ) ; for ( String word : words ) { char [ ] chars = word . toCharArray ( ) ; Arrays . sort ( chars ) ; String key = String . valueOf ( chars ) ; List < String > anagrams = map . computeIfAbsent ( key , k -> new ArrayList < > ( ) ) ; for ( String anagram : anagrams ) { if ( isDeranged ( word , anagram ) ) { System . out . printf ( "%s %s%n" , anagram , word ) ; return ; } } anagrams . add ( word ) ; } System . out . println ( "no result" ) ; } private static boolean isDeranged ( String word1 , String word2 ) { for ( int i = 0 ; i < word1 . length ( ) ; i ++ ) { if ( word1 . charAt ( i ) == word2 . charAt ( i ) ) { return false ; } } return true ; } } 
import java . net . * ; import java . io . * ; import java . util . * ; public class WordsOfEqChars { public static void main ( String [ ] args ) throws IOException { URL url = new URL ( "http://www.puzzlers.org/pub/wordlists/unixdict.txt" ) ; InputStreamReader isr = new InputStreamReader ( url . openStream ( ) ) ; BufferedReader reader = new BufferedReader ( isr ) ; Map < String , Collection < String > > anagrams = new HashMap < String , Collection < String > > ( ) ; String word ; int count = 0 ; while ( ( word = reader . readLine ( ) ) != null ) { char [ ] chars = word . toCharArray ( ) ; Arrays . sort ( chars ) ; String key = new String ( chars ) ; if ( ! anagrams . containsKey ( key ) ) anagrams . put ( key , new ArrayList < String > ( ) ) ; anagrams . get ( key ) . add ( word ) ; count = Math . max ( count , anagrams . get ( key ) . size ( ) ) ; } reader . close ( ) ; for ( Collection < String > ana : anagrams . values ( ) ) if ( ana . size ( ) >= count ) System . out . println ( ana ) ; } } 
import java . net . * ; import java . io . * ; import java . util . * ; import java . util . concurrent . * ; import java . util . function . * ; public interface Anagram { public static < AUTOCLOSEABLE extends AutoCloseable , OUTPUT > Supplier < OUTPUT > tryWithResources ( Callable < AUTOCLOSEABLE > callable , Function < AUTOCLOSEABLE , Supplier < OUTPUT > > function , Supplier < OUTPUT > defaultSupplier ) { return ( ) -> { try ( AUTOCLOSEABLE autoCloseable = callable . call ( ) ) { return function . apply ( autoCloseable ) . get ( ) ; } catch ( Throwable throwable ) { return defaultSupplier . get ( ) ; } } ; } public static < INPUT , OUTPUT > Function < INPUT , OUTPUT > function ( Supplier < OUTPUT > supplier ) { return i -> supplier . get ( ) ; } public static void main ( String ... args ) { Map < String , Collection < String > > anagrams = new ConcurrentSkipListMap < > ( ) ; int count = tryWithResources ( ( ) -> new BufferedReader ( new InputStreamReader ( new URL ( "http://www.puzzlers.org/pub/wordlists/unixdict.txt" ) . openStream ( ) ) ) , reader -> ( ) -> reader . lines ( ) . parallel ( ) . mapToInt ( word -> { char [ ] chars = word . toCharArray ( ) ; Arrays . parallelSort ( chars ) ; String key = Arrays . toString ( chars ) ; Collection < String > collection = anagrams . computeIfAbsent ( key , function ( ArrayList :: new ) ) ; collection . add ( word ) ; return collection . size ( ) ; } ) . max ( ) . orElse ( 0 ) , ( ) -> 0 ) . get ( ) ; anagrams . values ( ) . stream ( ) . filter ( ana -> ana . size ( ) >= count ) . forEach ( System . out :: println ) ; } } 
public static long fib ( int n ) { if ( n < 0 ) throw new IllegalArgumentException ( "n can not be a negative number" ) ; return new Object ( ) { private long fibInner ( int n ) { return ( n < 2 ) ? n : ( fibInner ( n - 1 ) + fibInner ( n - 2 ) ) ; } } . fibInner ( n ) ; } 
import java . util . function . Function ; @ FunctionalInterface interface SelfApplicable < OUTPUT > { OUTPUT apply ( SelfApplicable < OUTPUT > input ) ; } class Utils { public static < INPUT , OUTPUT > SelfApplicable < Function < Function < Function < INPUT , OUTPUT > , Function < INPUT , OUTPUT > > , Function < INPUT , OUTPUT > > > y ( ) { return y -> f -> x -> f . apply ( y . apply ( y ) . apply ( f ) ) . apply ( x ) ; } public static < INPUT , OUTPUT > Function < Function < Function < INPUT , OUTPUT > , Function < INPUT , OUTPUT > > , Function < INPUT , OUTPUT > > fix ( ) { return Utils . < INPUT , OUTPUT > y ( ) . apply ( Utils . < INPUT , OUTPUT > y ( ) ) ; } public static long fib ( int m ) { if ( m < 0 ) throw new IllegalArgumentException ( "n can not be a negative number" ) ; return Utils . < Integer , Long > fix ( ) . apply ( f -> n -> ( n < 2 ) ? n : ( f . apply ( n - 1 ) + f . apply ( n - 2 ) ) ) . apply ( m ) ; } } 
public class ArrayCallback7 { interface IntConsumer { void run ( int x ) ; } interface IntToInt { int run ( int x ) ; } static void forEach ( int [ ] arr , IntConsumer consumer ) { for ( int i : arr ) { consumer . run ( i ) ; } } static void update ( int [ ] arr , IntToInt mapper ) { for ( int i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = mapper . run ( arr [ i ] ) ; } } public static void main ( String [ ] args ) { int [ ] numbers = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; forEach ( numbers , new IntConsumer ( ) { public void run ( int x ) { System . out . println ( x ) ; } } ) ; update ( numbers , new IntToInt ( ) { @ Override public int run ( int x ) { return x * x ; } } ) ; forEach ( numbers , new IntConsumer ( ) { public void run ( int x ) { System . out . println ( x ) ; } } ) ; } } 
import java . util . Arrays ; public class ArrayCallback { public static void main ( String [ ] args ) { int [ ] myIntArray = { 1 , 2 , 3 , 4 , 5 } ; int sum = Arrays . stream ( myIntArray ) . map ( x -> { int cube = x * x * x ; System . out . println ( cube ) ; return cube ; } ) . reduce ( 0 , ( left , right ) -> left + right ) ; System . out . println ( "sum: " + sum ) ; } } 
import java . util . Scanner ; public class IntegerArithmetic { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int sum = a + b ; System . out . println ( "a + b = " + sum ) ; System . out . println ( "a - b = " + ( a - b ) ) ; System . out . println ( "a * b = " + ( a * b ) ) ; System . out . println ( "quotient of a / b = " + ( a / b ) ) ; System . out . println ( "remainder of a / b = " + ( a % b ) ) ; } } 
public class ArithmeticGeometricMean { public static double agm ( double a , double g ) { double a1 = a ; double g1 = g ; while ( Math . abs ( a1 - g1 ) >= 1.0e-14 ) { double arith = ( a1 + g1 ) / 2.0 ; double geom = Math . sqrt ( a1 * g1 ) ; a1 = arith ; g1 = geom ; } return a1 ; } public static void main ( String [ ] args ) { System . out . println ( agm ( 1.0 , 1.0 / Math . sqrt ( 2.0 ) ) ) ; } } 
public static Object [ ] concat ( Object [ ] arr1 , Object [ ] arr2 ) { Object [ ] res = new Object [ arr1 . length + arr2 . length ] ; System . arraycopy ( arr1 , 0 , res , 0 , arr1 . length ) ; System . arraycopy ( arr2 , 0 , res , arr1 . length , arr2 . length ) ; return res ; } 
int [ ] array = new int [ 10 ] ; array [ 0 ] = 42 ; System . out . println ( array [ 3 ] ) ; 
List < Integer > list = new ArrayList < Integer > ( ) ; list . add ( 5 ) ; list . add ( 1 , 6 ) ; System . out . println ( list . get ( 0 ) ) ; 
Map < String , Integer > map = new HashMap < String , Integer > ( ) ; map . put ( "foo" , 5 ) ; map . put ( "bar" , 10 ) ; map . put ( "baz" , 15 ) ; map . put ( "foo" , 6 ) ; 
public static Map < String , Integer > map = new HashMap < String , Integer > ( ) { { put ( "foo" , 5 ) ; put ( "bar" , 10 ) ; put ( "baz" , 15 ) ; put ( "foo" , 6 ) ; } } ; 
map . get ( "foo" ) ; map . get ( "invalid" ) ; 
for ( String key : map . keySet ( ) ) System . out . println ( key ) ; 
for ( int value : map . values ( ) ) System . out . println ( value ) ; 
for ( Map . Entry < String , Integer > entry : map . entrySet ( ) ) System . out . println ( entry . getKey ( ) + " => " + entry . getValue ( ) ) ; 
Map < String , Integer > map = new HashMap < String , Integer > ( ) ; map . put ( "hello" , 1 ) ; map . put ( "world" , 2 ) ; map . put ( "!" , 3 ) ; for ( Map . Entry < String , Integer > e : map . entrySet ( ) ) { String key = e . getKey ( ) ; Integer value = e . getValue ( ) ; System . out . println ( "key = " + key + ", value = " + value ) ; } for ( String key : map . keySet ( ) ) { System . out . println ( "key = " + key ) ; } for ( Integer value : map . values ( ) ) { System . out . println ( "value = " + value ) ; } 
Map < String , Integer > map = new HashMap < > ( ) ; map . put ( "hello" , 1 ) ; map . put ( "world" , 2 ) ; map . put ( "!" , 3 ) ; map . forEach ( ( k , v ) -> { System . out . printf ( "key = %s, value = %s%n" , k , v ) ; } ) ; map . keySet ( ) . forEach ( k -> System . out . printf ( "key = %s%n" , k ) ) ; map . values ( ) . forEach ( v -> System . out . printf ( "value = %s%n" , v ) ) ; 
public static double avg ( double ... arr ) { double sum = 0.0 ; for ( double x : arr ) { sum += x ; } return sum / arr . length ; } 
public static double median ( List < Double > list ) { Collections . sort ( list ) ; return ( list . get ( list . size ( ) / 2 ) + list . get ( ( list . size ( ) - 1 ) / 2 ) ) / 2 ; } 
public static double median2 ( List < Double > list ) { PriorityQueue < Double > pq = new PriorityQueue < Double > ( list ) ; int n = list . size ( ) ; for ( int i = 0 ; i < ( n - 1 ) / 2 ; i ++ ) pq . poll ( ) ; if ( n % 2 != 0 ) return pq . poll ( ) ; else return ( pq . poll ( ) + pq . poll ( ) ) / 2.0 ; } 
import java . util . * ; public class Mode { public static < T > List < T > mode ( List < ? extends T > coll ) { Map < T , Integer > seen = new HashMap < T , Integer > ( ) ; int max = 0 ; List < T > maxElems = new ArrayList < T > ( ) ; for ( T value : coll ) { if ( seen . containsKey ( value ) ) seen . put ( value , seen . get ( value ) + 1 ) ; else seen . put ( value , 1 ) ; if ( seen . get ( value ) > max ) { max = seen . get ( value ) ; maxElems . clear ( ) ; maxElems . add ( value ) ; } else if ( seen . get ( value ) == max ) { maxElems . add ( value ) ; } } return maxElems ; } public static void main ( String [ ] args ) { System . out . println ( mode ( Arrays . asList ( 1 , 3 , 6 , 6 , 6 , 6 , 7 , 7 , 12 , 12 , 17 ) ) ) ; System . out . println ( mode ( Arrays . asList ( 1 , 1 , 2 , 4 , 4 ) ) ) ; } } 
import java . util . Arrays ; import java . util . List ; public class PythagoreanMeans { public static double arithmeticMean ( List < Double > numbers ) { if ( numbers . isEmpty ( ) ) return Double . NaN ; double mean = 0.0 ; for ( Double number : numbers ) { mean += number ; } return mean / numbers . size ( ) ; } public static double geometricMean ( List < Double > numbers ) { if ( numbers . isEmpty ( ) ) return Double . NaN ; double mean = 1.0 ; for ( Double number : numbers ) { mean *= number ; } return Math . pow ( mean , 1.0 / numbers . size ( ) ) ; } public static double harmonicMean ( List < Double > numbers ) { if ( numbers . isEmpty ( ) || numbers . contains ( 0.0 ) ) return Double . NaN ; double mean = 0.0 ; for ( Double number : numbers ) { mean += ( 1.0 / number ) ; } return numbers . size ( ) / mean ; } public static void main ( String [ ] args ) { Double [ ] array = { 1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 , 10.0 } ; List < Double > list = Arrays . asList ( array ) ; double arithmetic = arithmeticMean ( list ) ; double geometric = geometricMean ( list ) ; double harmonic = harmonicMean ( list ) ; System . out . format ( "A = %f  G = %f  H = %f%n" , arithmetic , geometric , harmonic ) ; System . out . format ( "A >= G is %b, G >= H is %b%n" , ( arithmetic >= geometric ) , ( geometric >= harmonic ) ) ; } } 
public static double arithmAverage ( double array [ ] ) { if ( array == null || array . length == 0 ) { return 0.0 ; } else { return DoubleStream . of ( array ) . average ( ) . getAsDouble ( ) ; } } public static double geomAverage ( double array [ ] ) { if ( array == null || array . length == 0 ) { return 0.0 ; } else { double aver = DoubleStream . of ( array ) . reduce ( 1 , ( x , y ) -> x * y ) ; return Math . pow ( aver , 1.0 / array . length ) ; } } public static double harmAverage ( double array [ ] ) { if ( array == null || array . length == 0 ) { return 0.0 ; } else { double aver = DoubleStream . of ( array ) . filter ( n -> n > 0.0 ) . map ( n -> 1.0 / n ) . reduce ( 0 , ( x , y ) -> x + y ) ; return array . length / aver ; } } 
public class RootMeanSquare { public static double rootMeanSquare ( double ... nums ) { double sum = 0.0 ; for ( double num : nums ) sum += num * num ; return Math . sqrt ( sum / nums . length ) ; } public static void main ( String [ ] args ) { double [ ] nums = { 1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 , 10.0 } ; System . out . println ( "The RMS of the numbers from 1 to 10 is " + rootMeanSquare ( nums ) ) ; } } 
public class BalancedBrackets { public static boolean hasBalancedBrackets ( String str ) { int brackets = 0 ; for ( char ch : str . toCharArray ( ) ) { if ( ch == '[' ) { brackets ++ ; } else if ( ch == ']' ) { brackets -- ; } else { return false ; } if ( brackets < 0 ) { return false ; } } return brackets == 0 ; } public static String generateBalancedBrackets ( int n ) { assert n % 2 == 0 ; char [ ] ans = new char [ n ] ; int openBracketsLeft = n / 2 ; int unclosed = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( Math . random ( ) >= 0.5 && openBracketsLeft > 0 || unclosed == 0 ) { ans [ i ] = '[' ; openBracketsLeft -- ; unclosed ++ ; } else { ans [ i ] = ']' ; unclosed -- ; } } return String . valueOf ( ans ) ; } public static void main ( String [ ] args ) { for ( int i = 0 ; i <= 16 ; i += 2 ) { String brackets = generateBalancedBrackets ( i ) ; System . out . println ( brackets + ": " + hasBalancedBrackets ( brackets ) ) ; } String [ ] tests = { "" , "[]" , "][" , "[][]" , "][][" , "[[][]]" , "[]][[]" } ; for ( String test : tests ) { System . out . println ( test + ": " + hasBalancedBrackets ( test ) ) ; } } } 
public class Main { public static void main ( String [ ] args ) { System . out . println ( Integer . toBinaryString ( 5 ) ) ; System . out . println ( Integer . toBinaryString ( 50 ) ) ; System . out . println ( Integer . toBinaryString ( 9000 ) ) ; } } 
public class BinarySearchIterative { public static int binarySearch ( int [ ] nums , int check ) { int hi = nums . length - 1 ; int lo = 0 ; while ( hi >= lo ) { int guess = lo + ( ( hi - lo ) / 2 ) ; if ( nums [ guess ] > check ) { hi = guess - 1 ; } else if ( nums [ guess ] < check ) { lo = guess + 1 ; } else { return guess ; } } return - 1 ; } public static void main ( String [ ] args ) { int [ ] haystack = { 1 , 5 , 6 , 7 , 8 , 11 } ; int needle = 5 ; int index = binarySearch ( haystack , needle ) ; if ( index == - 1 ) { System . out . println ( needle + " is not in the array" ) ; } else { System . out . println ( needle + " is at index " + index ) ; } } } 
public class BinarySearchRecursive { public static int binarySearch ( int [ ] haystack , int needle , int lo , int hi ) { if ( hi < lo ) { return - 1 ; } int guess = ( hi + lo ) / 2 ; if ( haystack [ guess ] > needle ) { return binarySearch ( haystack , needle , lo , guess - 1 ) ; } else if ( haystack [ guess ] < needle ) { return binarySearch ( haystack , needle , guess + 1 , hi ) ; } return guess ; } public static void main ( String [ ] args ) { int [ ] haystack = { 1 , 5 , 6 , 7 , 8 , 11 } ; int needle = 5 ; int index = binarySearch ( haystack , needle , 0 , haystack . length ) ; if ( index == - 1 ) { System . out . println ( needle + " is not in the array" ) ; } else { System . out . println ( needle + " is at index " + index ) ; } } } 
import java . util . Arrays ; int index = Arrays . binarySearch ( array , thing ) ; int index = Arrays . binarySearch ( array , startIndex , endIndex , thing ) ; int index = Arrays . binarySearch ( array , thing , comparator ) ; int index = Arrays . binarySearch ( array , startIndex , endIndex , thing , comparator ) ; 
import java . util . Collections ; int index = Collections . binarySearch ( list , thing ) ; int index = Collections . binarySearch ( list , thing , comparator ) ; 
public static void bitwise ( int a , int b ) { System . out . println ( "a AND b: " + ( a & b ) ) ; System . out . println ( "a OR b: " + ( a | b ) ) ; System . out . println ( "a XOR b: " + ( a ^ b ) ) ; System . out . println ( "NOT a: " + ~ a ) ; System . out . println ( "a << b: " + ( a << b ) ) ; System . out . println ( "a >> b: " + ( a > > b ) ) ; System . out . println ( "a >>> b: " + ( a > > > b ) ) ; System . out . println ( "a rol b: " + Integer . rotateLeft ( a , b ) ) ; System . out . println ( "a ror b: " + Integer . rotateRight ( a , b ) ) ; } 
a <<= 3 ; a = a << 3 ; a *= 8 ; a = a * 8 ; 
import java . util . InputMismatchException ; import java . util . Random ; import java . util . Scanner ; public class BullsAndCows { public static void main ( String [ ] args ) { Random gen = new Random ( ) ; int target = 0 ; while ( hasDupes ( target = ( gen . nextInt ( 9000 ) + 1000 ) ) ) ; String targetStr = target + "" ; boolean guessed = false ; Scanner input = new Scanner ( System . in ) ; int guesses = 0 ; do { int bulls = 0 ; int cows = 0 ; System . out . print ( "Guess a 4-digit number with no duplicate digits: " ) ; int guess ; try { guess = input . nextInt ( ) ; if ( hasDupes ( guess ) || guess < 1000 ) continue ; } catch ( InputMismatchException e ) { continue ; } guesses ++ ; String guessStr = guess + "" ; for ( int i = 0 ; i < 4 ; i ++ ) { if ( guessStr . charAt ( i ) == targetStr . charAt ( i ) ) { bulls ++ ; } else if ( targetStr . contains ( guessStr . charAt ( i ) + "" ) ) { cows ++ ; } } if ( bulls == 4 ) { guessed = true ; } else { System . out . println ( cows + " Cows and " + bulls + " Bulls." ) ; } } while ( ! guessed ) ; System . out . println ( "You won after " + guesses + " guesses!" ) ; } public static boolean hasDupes ( int num ) { boolean [ ] digs = new boolean [ 10 ] ; while ( num > 0 ) { if ( digs [ num % 10 ] ) return true ; digs [ num % 10 ] = true ; num /= 10 ; } return false ; } } 
import java . io . * ; import java . awt . Point ; import java . util . HashMap ; import java . util . Scanner ; public class CSV { private HashMap < Point , String > _map = new HashMap < Point , String > ( ) ; private int _cols ; private int _rows ; public void open ( File file ) throws FileNotFoundException , IOException { open ( file , ',' ) ; } public void open ( File file , char delimiter ) throws FileNotFoundException , IOException { Scanner scanner = new Scanner ( file ) ; scanner . useDelimiter ( Character . toString ( delimiter ) ) ; clear ( ) ; while ( scanner . hasNextLine ( ) ) { String [ ] values = scanner . nextLine ( ) . split ( Character . toString ( delimiter ) ) ; int col = 0 ; for ( String value : values ) { _map . put ( new Point ( col , _rows ) , value ) ; _cols = Math . max ( _cols , ++ col ) ; } _rows ++ ; } scanner . close ( ) ; } public void save ( File file ) throws IOException { save ( file , ',' ) ; } public void save ( File file , char delimiter ) throws IOException { FileWriter fw = new FileWriter ( file ) ; BufferedWriter bw = new BufferedWriter ( fw ) ; for ( int row = 0 ; row < _rows ; row ++ ) { for ( int col = 0 ; col < _cols ; col ++ ) { Point key = new Point ( col , row ) ; if ( _map . containsKey ( key ) ) { bw . write ( _map . get ( key ) ) ; } if ( ( col + 1 ) < _cols ) { bw . write ( delimiter ) ; } } bw . newLine ( ) ; } bw . flush ( ) ; bw . close ( ) ; } public String get ( int col , int row ) { String val = "" ; Point key = new Point ( col , row ) ; if ( _map . containsKey ( key ) ) { val = _map . get ( key ) ; } return val ; } public void put ( int col , int row , String value ) { _map . put ( new Point ( col , row ) , value ) ; _cols = Math . max ( _cols , col + 1 ) ; _rows = Math . max ( _rows , row + 1 ) ; } public void clear ( ) { _map . clear ( ) ; _cols = 0 ; _rows = 0 ; } public int rows ( ) { return _rows ; } public int cols ( ) { return _cols ; } public static void main ( String [ ] args ) { try { CSV csv = new CSV ( ) ; csv . open ( new File ( "test_in.csv" ) ) ; csv . put ( 0 , 0 , "Column0" ) ; csv . put ( 1 , 1 , "100" ) ; csv . put ( 2 , 2 , "200" ) ; csv . put ( 3 , 3 , "300" ) ; csv . put ( 4 , 4 , "400" ) ; csv . save ( new File ( "test_out.csv" ) ) ; } catch ( Exception e ) { } } } 
import java . io . * ; import java . util . * ; import org . apache . commons . csv . * ; public class RCsv { private static final String NL = System . getProperty ( "line.separator" ) ; private static final String FILENAME_IR = "data/csvtest_in.csv" ; private static final String FILENAME_OR = "data/csvtest_sum.csv" ; private static final String COL_NAME_SUM = "SUM, \"integers\"" ; public static void main ( String [ ] args ) { Reader iCvs = null ; Writer oCvs = null ; System . out . println ( textFileContentsToString ( FILENAME_IR ) ) ; try { iCvs = new BufferedReader ( new FileReader ( FILENAME_IR ) ) ; oCvs = new BufferedWriter ( new FileWriter ( FILENAME_OR ) ) ; processCsv ( iCvs , oCvs ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } finally { try { if ( iCvs != null ) { iCvs . close ( ) ; } if ( oCvs != null ) { oCvs . close ( ) ; } } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } System . out . println ( textFileContentsToString ( FILENAME_OR ) ) ; return ; } public static void processCsv ( Reader iCvs , Writer oCvs ) throws IOException { CSVPrinter printer = null ; try { printer = new CSVPrinter ( oCvs , CSVFormat . DEFAULT . withRecordSeparator ( NL ) ) ; List < String > oCvsHeaders ; List < String > oCvsRecord ; CSVParser records = CSVFormat . DEFAULT . withHeader ( ) . parse ( iCvs ) ; Map < String , Integer > irHeader = records . getHeaderMap ( ) ; oCvsHeaders = new ArrayList < String > ( Arrays . asList ( ( irHeader . keySet ( ) ) . toArray ( new String [ 0 ] ) ) ) ; oCvsHeaders . add ( COL_NAME_SUM ) ; printer . printRecord ( oCvsHeaders ) ; for ( CSVRecord record : records ) { oCvsRecord = record2list ( record , oCvsHeaders ) ; printer . printRecord ( oCvsRecord ) ; } } finally { if ( printer != null ) { printer . close ( ) ; } } return ; } private static List < String > record2list ( CSVRecord record , List < String > oCvsHeaders ) { List < String > cvsRecord ; Map < String , String > rMap = record . toMap ( ) ; long recNo = record . getRecordNumber ( ) ; rMap = alterRecord ( rMap , recNo ) ; int sum = 0 ; sum = summation ( rMap ) ; rMap . put ( COL_NAME_SUM , String . valueOf ( sum ) ) ; cvsRecord = new ArrayList < String > ( ) ; for ( String key : oCvsHeaders ) { cvsRecord . add ( rMap . get ( key ) ) ; } return cvsRecord ; } private static Map < String , String > alterRecord ( Map < String , String > rMap , long recNo ) { int rv ; Random rg = new Random ( recNo ) ; rv = rg . nextInt ( 50 ) ; String [ ] ks = rMap . keySet ( ) . toArray ( new String [ 0 ] ) ; int ix = rg . nextInt ( ks . length ) ; long yv = 0 ; String ky = ks [ ix ] ; String xv = rMap . get ( ky ) ; if ( xv != null && xv . length ( ) > 0 ) { yv = Long . valueOf ( xv ) + rv ; rMap . put ( ks [ ix ] , String . valueOf ( yv ) ) ; } return rMap ; } private static int summation ( Map < String , String > rMap ) { int sum = 0 ; for ( String col : rMap . keySet ( ) ) { String nv = rMap . get ( col ) ; sum += nv != null && nv . length ( ) > 0 ? Integer . valueOf ( nv ) : 0 ; } return sum ; } private static String textFileContentsToString ( String filename ) { StringBuilder lineOut = new StringBuilder ( ) ; Scanner fs = null ; try { fs = new Scanner ( new File ( filename ) ) ; lineOut . append ( filename ) ; lineOut . append ( NL ) ; while ( fs . hasNextLine ( ) ) { String line = fs . nextLine ( ) ; lineOut . append ( line ) ; lineOut . append ( NL ) ; } } catch ( FileNotFoundException ex ) { ex . printStackTrace ( ) ; } finally { if ( fs != null ) { fs . close ( ) ; } } return lineOut . toString ( ) ; } } 
public static void main ( String [ ] args ) throws IOException { CsvParserSettings settings = new CsvParserSettings ( ) ; settings . getFormat ( ) . setLineSeparator ( "\n" ) ; BeanListProcessor < Employee > rowProcessor = new BeanListProcessor < Employee > ( Employee . class ) ; settings . setRowProcessor ( rowProcessor ) ; CsvParser parser = new CsvParser ( settings ) ; parser . parse ( new FileReader ( "/examples/employees.csv" ) ) ; List < Employee > resolvedBeans = rowProcessor . getBeans ( ) ; CsvWriterSettings writerSettings = new CsvWriterSettings ( ) ; writerSettings . setRowWriterProcessor ( new BeanWriterProcessor < Employee > ( Employee . class ) ) ; CsvWriter writer = new CsvWriter ( new FileWriter ( "/examples/processed_employees.csv" ) , writerSettings ) ; writer . processRecords ( resolvedBeans ) ; writer . writeRows ( new ArrayList < List < Object > > ( ) ) ; } 
import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . io . PrintStream ; class Csv2Html { public static String escapeChars ( String lineIn ) { StringBuilder sb = new StringBuilder ( ) ; int lineLength = lineIn . length ( ) ; for ( int i = 0 ; i < lineLength ; i ++ ) { char c = lineIn . charAt ( i ) ; switch ( c ) { case '"' : sb . append ( "&quot;" ) ; break ; case '&' : sb . append ( "&amp;" ) ; break ; case '\'' : sb . append ( "&apos;" ) ; break ; case '<' : sb . append ( "&lt;" ) ; break ; case '>' : sb . append ( "&gt;" ) ; break ; default : sb . append ( c ) ; } } return sb . toString ( ) ; } public static void tableHeader ( PrintStream ps , String [ ] columns ) { ps . print ( "<tr>" ) ; for ( int i = 0 ; i < columns . length ; i ++ ) { ps . print ( "<th>" ) ; ps . print ( columns [ i ] ) ; ps . print ( "</th>" ) ; } ps . println ( "</tr>" ) ; } public static void tableRow ( PrintStream ps , String [ ] columns ) { ps . print ( "<tr>" ) ; for ( int i = 0 ; i < columns . length ; i ++ ) { ps . print ( "<td>" ) ; ps . print ( columns [ i ] ) ; ps . print ( "</td>" ) ; } ps . println ( "</tr>" ) ; } public static void main ( String [ ] args ) throws Exception { boolean withTableHeader = ( args . length != 0 ) ; InputStreamReader isr = new InputStreamReader ( System . in ) ; BufferedReader br = new BufferedReader ( isr ) ; PrintStream stdout = System . out ; stdout . println ( "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">" ) ; stdout . println ( "<html xmlns=\"http://www.w3.org/1999/xhtml\">" ) ; stdout . println ( "<head><meta http-equiv=\"Content-type\" content=\"text/html;charset=UTF-8\"/>" ) ; stdout . println ( "<title>Csv2Html</title>" ) ; stdout . println ( "<style type=\"text/css\">" ) ; stdout . println ( "body{background-color:#FFF;color:#000;font-family:OpenSans,sans-serif;font-size:10px;}" ) ; stdout . println ( "table{border:0.2em solid #2F6FAB;border-collapse:collapse;}" ) ; stdout . println ( "th{border:0.15em solid #2F6FAB;padding:0.5em;background-color:#E9E9E9;}" ) ; stdout . println ( "td{border:0.1em solid #2F6FAB;padding:0.5em;background-color:#F9F9F9;}</style>" ) ; stdout . println ( "</head><body><h1>Csv2Html</h1>" ) ; stdout . println ( "<table>" ) ; String stdinLine ; boolean firstLine = true ; while ( ( stdinLine = br . readLine ( ) ) != null ) { String [ ] columns = escapeChars ( stdinLine ) . split ( "," ) ; if ( withTableHeader == true && firstLine == true ) { tableHeader ( stdout , columns ) ; firstLine = false ; } else { tableRow ( stdout , columns ) ; } } stdout . println ( "</table></body></html>" ) ; } } 


public class Cipher { public static void main ( String [ ] args ) { String str = "The quick brown fox Jumped over the lazy Dog" ; System . out . println ( Cipher . encode ( str , 12 ) ) ; System . out . println ( Cipher . decode ( Cipher . encode ( str , 12 ) , 12 ) ) ; } public static String decode ( String enc , int offset ) { return encode ( enc , 26 - offset ) ; } public static String encode ( String enc , int offset ) { offset = offset % 26 + 26 ; StringBuilder encoded = new StringBuilder ( ) ; for ( char i : enc . toCharArray ( ) ) { if ( Character . isLetter ( i ) ) { if ( Character . isUpperCase ( i ) ) { encoded . append ( ( char ) ( 'A' + ( i - 'A' + offset ) % 26 ) ) ; } else { encoded . append ( ( char ) ( 'a' + ( i - 'a' + offset ) % 26 ) ) ; } } else { encoded . append ( i ) ; } } return encoded . toString ( ) ; } } 
ClassWithStaticMethod . staticMethodName ( argument1 , argument2 ) ; 
ClassWithMethod varName = new ClassWithMethod ( ) ; varName . methodName ( argument1 , argument2 ) ; new ClassWithMethod ( ) . methodName ( argument1 , argument2 ) ; 
import java . util . HashMap ; import java . util . Map ; public class Catalan { private static final Map < Long , Double > facts = new HashMap < Long , Double > ( ) ; private static final Map < Long , Double > catsI = new HashMap < Long , Double > ( ) ; private static final Map < Long , Double > catsR1 = new HashMap < Long , Double > ( ) ; private static final Map < Long , Double > catsR2 = new HashMap < Long , Double > ( ) ; static { facts . put ( 0L , 1D ) ; facts . put ( 1L , 1D ) ; facts . put ( 2L , 2D ) ; catsI . put ( 0L , 1D ) ; catsR1 . put ( 0L , 1D ) ; catsR2 . put ( 0L , 1D ) ; } private static double fact ( long n ) { if ( facts . containsKey ( n ) ) { return facts . get ( n ) ; } double fact = 1 ; for ( long i = 2 ; i <= n ; i ++ ) { fact *= i ; } facts . put ( n , fact ) ; return fact ; } private static double catI ( long n ) { if ( ! catsI . containsKey ( n ) ) { catsI . put ( n , fact ( 2 * n ) / ( fact ( n + 1 ) * fact ( n ) ) ) ; } return catsI . get ( n ) ; } private static double catR1 ( long n ) { if ( catsR1 . containsKey ( n ) ) { return catsR1 . get ( n ) ; } double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += catR1 ( i ) * catR1 ( n - 1 - i ) ; } catsR1 . put ( n , sum ) ; return sum ; } private static double catR2 ( long n ) { if ( ! catsR2 . containsKey ( n ) ) { catsR2 . put ( n , ( ( 2.0 * ( 2 * ( n - 1 ) + 1 ) ) / ( n + 1 ) ) * catR2 ( n - 1 ) ) ; } return catsR2 . get ( n ) ; } public static void main ( String [ ] args ) { for ( int i = 0 ; i <= 15 ; i ++ ) { System . out . println ( catI ( i ) ) ; System . out . println ( catR1 ( i ) ) ; System . out . println ( catR2 ( i ) ) ; } } } 
public class Foo { public static void main ( String [ ] args ) { System . out . println ( ( int ) 'a' ) ; System . out . println ( ( char ) 97 ) ; } } 
public class Bar { public static void main ( String [ ] args ) { System . out . println ( ( int ) ) ; System . out . println ( ( char ) 960 ) ; } } 
import java . io . File ; public class FileExistsTest { public static boolean isFileExists ( String filename ) { boolean exists = new File ( filename ) . exists ( ) ; return exists ; } public static void test ( String type , String filename ) { System . out . println ( "The following " + type + " called " + filename + ( isFileExists ( filename ) ? " exists." : " not exists." ) ) ; } public static void main ( String args [ ] ) { test ( "file" , "input.txt" ) ; test ( "file" , File . separator + "input.txt" ) ; test ( "directory" , "docs" ) ; test ( "directory" , File . separator + "docs" + File . separator ) ; } } 
import java . nio . file . FileSystem ; import java . nio . file . FileSystems ; import java . nio . file . Files ; public class FileExistsTest { private static FileSystem defaultFS = FileSystems . getDefault ( ) ; public static boolean isFileExists ( String filename ) { return Files . exists ( defaultFS . getPath ( filename ) ) ; } public static void test ( String type , String filename ) { System . out . println ( "The following " + type + " called " + filename + ( isFileExists ( filename ) ? " exists." : " not exists." ) ) ; } public static void main ( String args [ ] ) { test ( "file" , "input.txt" ) ; test ( "file" , defaultFS . getSeparator ( ) + "input.txt" ) ; test ( "directory" , "docs" ) ; test ( "directory" , defaultFS . getSeparator ( ) + "docs" + defaultFS . getSeparator ( ) ) ; } } 
import java . nio . file . Files ; public class FileExistsTest { public static void main ( String args [ ] ) { System . out . printf ( "input.txt - %s" , new File ( "input.txt" ) . exists ( ) ) ; } 
public class MyClass { private int variable ; public MyClass ( ) { } public void someMethod ( ) { this . variable = 1 ; } } 
new MyClass ( ) ; 
import java . util . function . Supplier ; import java . util . ArrayList ; public class ValueCapture { public static void main ( String [ ] args ) { ArrayList < Supplier < Integer > > funcs = new ArrayList < > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { int j = i ; funcs . add ( ( ) -> j * j ) ; } Supplier < Integer > foo = funcs . get ( 3 ) ; System . out . println ( foo . get ( ) ) ; } } 
import java . util . List ; import java . util . function . IntSupplier ; import java . util . stream . IntStream ; import static java . util . stream . Collectors . toList ; public interface ValueCapture { public static void main ( String ... arguments ) { List < IntSupplier > closures = IntStream . rangeClosed ( 0 , 10 ) . < IntSupplier > mapToObj ( i -> ( ) -> i * i ) . collect ( toList ( ) ) ; IntSupplier closure = closures . get ( 3 ) ; System . out . println ( closure . getAsInt ( ) ) ; } } 
List arrayList = new ArrayList ( ) ; arrayList . add ( new Integer ( 0 ) ) ; arrayList . add ( 0 ) ; List < Integer > myarrlist = new ArrayList < Integer > ( ) ; int sum ; for ( int i = 0 ; i < 10 ; i ++ ) { myarrlist . add ( i ) ; } 
for ( i = 0 ; i < myarrlist . size ( ) ; i ++ ) { sum += myarrlist . get ( i ) ; } 
for ( int i : myarrlist ) { sum += i ; } 
myarrlist . remove ( myarrlist . size ( ) - 1 ) myarrlist . clear ( ) ; 
import scala . Tuple2 ; import scala . collection . concurrent . TrieMap ; import scala . collection . immutable . HashSet ; import scala . collection . mutable . ArrayBuffer ; public class Collections { public static void main ( String [ ] args ) { ArrayBuffer < Integer > myarrlist = new ArrayBuffer < Integer > ( ) ; ArrayBuffer < Integer > myarrlist2 = new ArrayBuffer < Integer > ( 20 ) ; myarrlist . $plus$eq ( new Integer ( 42 ) ) ; myarrlist . $plus$eq ( 13 ) ; myarrlist . $plus$eq ( - 1 ) ; myarrlist2 = ( ArrayBuffer < Integer > ) myarrlist2 . $minus ( - 1 ) ; for ( int i = 0 ; i < 10 ; i ++ ) myarrlist2 . $plus$eq ( i ) ; int sum = 0 ; for ( int i = 0 ; i < myarrlist2 . size ( ) ; i ++ ) { sum += myarrlist2 . apply ( i ) ; } System . out . println ( "List is: " + myarrlist2 + " with head: " + myarrlist2 . head ( ) + " sum is: " + sum ) ; System . out . println ( "Third element is: " + myarrlist2 . apply$mcII$sp ( 2 ) ) ; Tuple2 < String , String > tuple = new Tuple2 < String , String > ( "US" , "Washington" ) ; System . out . println ( "Tuple2 is : " + tuple ) ; ArrayBuffer < Tuple2 < String , String > > capList = new ArrayBuffer < Tuple2 < String , String > > ( ) ; capList . $plus$eq ( new Tuple2 < String , String > ( "US" , "Washington" ) ) ; capList . $plus$eq ( new Tuple2 < String , String > ( "France" , "Paris" ) ) ; System . out . println ( capList ) ; TrieMap < String , String > trieMap = new TrieMap < String , String > ( ) ; trieMap . put ( "US" , "Washington" ) ; trieMap . put ( "France" , "Paris" ) ; HashSet < Character > set = new HashSet < Character > ( ) ; ArrayBuffer < Tuple2 < String , String > > capBuffer = new ArrayBuffer < Tuple2 < String , String > > ( ) ; trieMap . put ( "US" , "Washington" ) ; System . out . println ( trieMap ) ; } } 
import com . objectwave . utility . * ; public class MultiCombinationsTester { public MultiCombinationsTester ( ) throws CombinatoricException { Object [ ] objects = { "iced" , "jam" , "plain" } ; MultiCombinations mc = new MultiCombinations ( objects , 2 ) ; while ( mc . hasMoreElements ( ) ) { for ( int i = 0 ; i < mc . nextElement ( ) . length ; i ++ ) { System . out . print ( mc . nextElement ( ) [ i ] . toString ( ) + " " ) ; } System . out . println ( ) ; } System . out . println ( "----------" ) ; System . out . println ( "The ways to choose 3 items from 10 with replacement = " + MultiCombinations . c ( 10 , 3 ) ) ; } public static void main ( String [ ] args ) throws CombinatoricException { new MultiCombinationsTester ( ) ; } } 
import com . objectwave . utility . * ; import java . util . * ; public class MultiCombinations { private HashSet < String > set = new HashSet < String > ( ) ; private Combinations comb = null ; private Object [ ] nextElem = null ; public MultiCombinations ( Object [ ] objects , int k ) throws CombinatoricException { k = Math . max ( 0 , k ) ; Object [ ] myObjects = new Object [ objects . length * k ] ; for ( int i = 0 ; i < objects . length ; i ++ ) { for ( int j = 0 ; j < k ; j ++ ) { myObjects [ i * k + j ] = objects [ i ] ; } } comb = new Combinations ( myObjects , k ) ; } boolean hasMoreElements ( ) { boolean ret = false ; nextElem = null ; int oldCount = set . size ( ) ; while ( comb . hasMoreElements ( ) ) { Object [ ] elem = ( Object [ ] ) comb . nextElement ( ) ; String str = "" ; for ( int i = 0 ; i < elem . length ; i ++ ) { str += ( "%" + elem [ i ] . toString ( ) + "~" ) ; } set . add ( str ) ; if ( set . size ( ) > oldCount ) { nextElem = elem ; ret = true ; break ; } } return ret ; } Object [ ] nextElement ( ) { return nextElem ; } static java . math . BigInteger c ( int n , int k ) throws CombinatoricException { return Combinatoric . c ( n + k - 1 , k ) ; } } 
import java . util . Collections ; import java . util . LinkedList ; public class Comb { public static void main ( String [ ] args ) { System . out . println ( comb ( 3 , 5 ) ) ; } public static String bitprint ( int u ) { String s = "" ; for ( int n = 0 ; u > 0 ; ++ n , u >>= 1 ) if ( ( u & 1 ) > 0 ) s += n + " " ; return s ; } public static int bitcount ( int u ) { int n ; for ( n = 0 ; u > 0 ; ++ n , u &= ( u - 1 ) ) ; return n ; } public static LinkedList < String > comb ( int c , int n ) { LinkedList < String > s = new LinkedList < String > ( ) ; for ( int u = 0 ; u < 1 << n ; u ++ ) if ( bitcount ( u ) == c ) s . push ( bitprint ( u ) ) ; Collections . sort ( s ) ; return s ; } } 
public class Quibbler { public static String quibble ( String [ ] words ) { String qText = "{" ; for ( int wIndex = 0 ; wIndex < words . length ; wIndex ++ ) { qText += words [ wIndex ] + ( wIndex == words . length - 1 ? "" : wIndex == words . length - 2 ? " and " : ", " ; } qText += "}" ; return qText ; } public static void main ( String [ ] args ) { System . out . println ( quibble ( new String [ ] { } ) ) ; System . out . println ( quibble ( new String [ ] { "ABC" } ) ) ; System . out . println ( quibble ( new String [ ] { "ABC" , "DEF" } ) ) ; System . out . println ( quibble ( new String [ ] { "ABC" , "DEF" , "G" } ) ) ; System . out . println ( quibble ( new String [ ] { "ABC" , "DEF" , "G" , "H" } ) ) ; } } 
public class Arguments { public static void main ( String [ ] args ) { System . out . println ( "There are " + args . length + " arguments given." ) ; for ( int i = 0 ; i < args . length ; i ++ ) System . out . println ( "The argument #" + ( i + 1 ) + " is " + args [ i ] + " and is at index " + i ) ; } } 





public class JustComments { public static void main ( String [ ] args ) { System . out . println ( "Hello" + " World!" ) ; } } 
public class Point { public int x , y ; public Point ( ) { this ( 0 ) ; } public Point ( int x0 ) { this ( x0 , 0 ) ; } public Point ( int x0 , int y0 ) { x = x0 ; y = y0 ; } public static void main ( String args [ ] ) { Point point = new Point ( 1 , 2 ) ; System . out . println ( "x = " + point . x ) ; System . out . println ( "y = " + point . y ) ; } } 
String src = "Hello" ; String newAlias = src ; String strCopy = new String ( src ) ; 
StringBuffer srcCopy = new StringBuffer ( "Hello" ) ; 
public class Count { public static void main ( String [ ] args ) { for ( int i = 0 ; i >= 0 ; i ++ ) { System . out . println ( Integer . toOctalString ( i ) ) ; } } } 
public class CountSubstring { public static int countSubstring ( String subStr , String str ) { return ( str . length ( ) - str . replace ( subStr , "" ) . length ( ) ) / subStr . length ( ) ; } public static void main ( String [ ] args ) { System . out . println ( countSubstring ( "th" , "the three truths" ) ) ; System . out . println ( countSubstring ( "abab" , "ababababab" ) ) ; System . out . println ( countSubstring ( "a*b" , "abaabba*bbaba*bbab" ) ) ; } } 
import java . util . regex . Pattern ; public class CountSubstring { public static int countSubstring ( String subStr , String str ) { return str . split ( Pattern . quote ( subStr ) , - 1 ) . length - 1 ; } public static void main ( String [ ] args ) { System . out . println ( countSubstring ( "th" , "the three truths" ) ) ; System . out . println ( countSubstring ( "abab" , "ababababab" ) ) ; System . out . println ( countSubstring ( "a*b" , "abaabba*bbaba*bbab" ) ) ; } } 
public class CountSubstring { public static int countSubstring ( String subStr , String str ) { int count = 0 ; for ( int loc = str . indexOf ( subStr ) ; loc != - 1 ; loc = str . indexOf ( subStr , loc + subStr . length ( ) ) ) count ++ ; return count ; } public static void main ( String [ ] args ) { System . out . println ( countSubstring ( "th" , "the three truths" ) ) ; System . out . println ( countSubstring ( "abab" , "ababababab" ) ) ; System . out . println ( countSubstring ( "a*b" , "abaabba*bbaba*bbab" ) ) ; } } 
public class HTML { public static String array2HTML ( Object [ ] [ ] array ) { StringBuilder html = new StringBuilder ( "<table>" ) ; for ( Object elem : array [ 0 ] ) { html . append ( "<th>" + elem . toString ( ) + "</th>" ) ; } for ( int i = 1 ; i < array . length ; i ++ ) { Object [ ] row = array [ i ] ; html . append ( "<tr>" ) ; for ( Object elem : row ) { html . append ( "<td>" + elem . toString ( ) + "</td>" ) ; } html . append ( "</tr>" ) ; } html . append ( "</table>" ) ; return html . toString ( ) ; } public static void main ( String [ ] args ) { Object [ ] [ ] ints = { { "" , "X" , "Y" , "Z" } , { 1 , 1 , 2 , 3 } , { 2 , 4 , 5 , 6 } , { 3 , 7 , 8 , 9 } , { 4 , 10 , 11 , 12 } } ; System . out . println ( array2HTML ( ints ) ) ; } } 
< table > < th > < / th > < th > X < / th > < th > Y < / th > < th > Z < / th > < tr > < td > 1 < / td > < td > 1 < / td > < td > 2 < / td > < td > 3 < / td > < / tr > < tr > < td > 2 < / td > < td > 4 < / td > < td > 5 < / td > < td > 6 < / td > < / tr > < tr > < td > 3 < / td > < td > 7 < / td > < td > 8 < / td > < td > 9 < / td > < / tr > < tr > < td > 4 < / td > < td > 10 < / td > < td > 11 < / td > < td > 12 < / td > < / tr > < / table > 
import java . util . Calendar ; import java . util . GregorianCalendar ; import java . text . DateFormatSymbols ; import java . util . Date ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; public class Dates { public static void main ( final String [ ] args ) { Calendar now = new GregorianCalendar ( ) ; DateFormatSymbols symbols = new DateFormatSymbols ( ) ; System . out . println ( now . get ( Calendar . YEAR ) + "-" + ( now . get ( Calendar . MONTH ) + 1 ) + "-" + now . get ( Calendar . DATE ) ) ; System . out . print ( symbols . getWeekdays ( ) [ now . get ( Calendar . DAY_OF_WEEK ) ] + ", " ) ; System . out . print ( symbols . getMonths ( ) [ now . get ( Calendar . MONTH ) ] + " " ) ; System . out . println ( now . get ( Calendar . DATE ) + ", " + now . get ( Calendar . YEAR ) ) ; Date date = new Date ( ) ; DateFormat format1 = new SimpleDateFormat ( "yyyy-MM-dd" ) ; System . out . println ( format1 . format ( date ) ) ; DateFormat format2 = new SimpleDateFormat ( "EEEE, MMMM dd, yyyy" ) ; System . out . println ( format2 . format ( date ) ) ; } } 
import java . time . LocalDate ; import java . time . format . DateTimeFormatter ; public class Dates { public static void main ( final String [ ] args ) { LocalDate date = LocalDate . now ( ) ; DateTimeFormatter dtFormatter = DateTimeFormatter . ofPattern ( "yyyy MM dd" ) ; System . out . println ( dtFormatter . format ( date ) ) ; } } 
import java . util . Date ; import java . text . SimpleDateFormat ; public class DateManip { public static void main ( String [ ] args ) throws Exception { String dateStr = "March 7 2009 7:30pm EST" ; SimpleDateFormat sdf = new SimpleDateFormat ( "MMMM d yyyy h:mma zzz" ) ; Date date = sdf . parse ( dateStr ) ; date . setTime ( date . getTime ( ) + 43200000l ) ; System . out . println ( sdf . format ( date ) ) ; } } 
import java . util . Calendar ; import java . util . Date ; import java . util . GregorianCalendar ; public class Yuletide { public static void main ( String [ ] args ) { for ( int i = 2008 ; i <= 2121 ; i ++ ) { Calendar cal = new GregorianCalendar ( i , Calendar . DECEMBER , 25 ) ; if ( cal . get ( Calendar . DAY_OF_WEEK ) == Calendar . SUNDAY ) { System . out . println ( cal . getTime ( ) ) ; } } } } 
interface Thingable { String thing ( ) ; } class Delegator { public Thingable delegate ; public String operation ( ) { if ( delegate == null ) return "default implementation" ; else return delegate . thing ( ) ; } } class Delegate implements Thingable { public String thing ( ) { return "delegate implementation" ; } } public class DelegateExample { public static void main ( String [ ] args ) { Delegator a = new Delegator ( ) ; assert a . operation ( ) . equals ( "default implementation" ) ; Delegate d = new Delegate ( ) ; a . delegate = d ; assert a . operation ( ) . equals ( "delegate implementation" ) ; a . delegate = new Thingable ( ) { public String thing ( ) { return "anonymous delegate implementation" ; } } ; assert a . operation ( ) . equals ( "anonymous delegate implementation" ) ; } } 
package delegate ; @ FunctionalInterface public interface Thingable { public String thing ( ) ; } 
package delegate ; import java . util . Optional ; public interface Delegator { public Thingable delegate ( ) ; public Delegator delegate ( Thingable thingable ) ; public static Delegator new_ ( ) { return $Delegator . new_ ( ) ; } public default String operation ( ) { return Optional . ofNullable ( delegate ( ) ) . map ( Thingable :: thing ) . orElse ( "default implementation" ) ; } } 
package delegate ; @ FunctionalInterface interface $Delegator extends Delegator { @ Override public default Delegator delegate ( Thingable thingable ) { return new_ ( thingable ) ; } public static $Delegator new_ ( ) { return new_ ( ( ) -> null ) ; } public static $Delegator new_ ( Thingable thingable ) { return ( ) -> thingable ; } } 
package delegate ; public final class Delegate implements Thingable { @ Override public String thing ( ) { return "delegate implementation" ; } } 
package delegate ; public interface DelegateTest { public static String thingable ( ) { return "method reference implementation" ; } public static void main ( String ... arguments ) { Delegator d1 = Delegator . new_ ( ) ; assert d1 . operation ( ) . equals ( "default implementation" ) ; Delegator d2 = d1 . delegate ( new Delegate ( ) ) ; assert d2 . operation ( ) . equals ( "delegate implementation" ) ; Delegator d3 = d2 . delegate ( new Thingable ( ) { @ Override public String thing ( ) { return "anonymous delegate implementation" ; } } ) ; assert d3 . operation ( ) . equals ( "anonymous delegate implementation" ) ; Delegator d4 = d3 . delegate ( DelegateTest :: thingable ) ; assert d4 . operation ( ) . equals ( "method reference implementation" ) ; Delegator d5 = d4 . delegate ( ( ) -> "lambda expression implementation" ) ; assert d5 . operation ( ) . equals ( "lambda expression implementation" ) ; } } 
import java . io . File ; public class FileDeleteTest { public static boolean deleteFile ( String filename ) { boolean exists = new File ( filename ) . delete ( ) ; return exists ; } public static void test ( String type , String filename ) { System . out . println ( "The following " + type + " called " + filename + ( deleteFile ( filename ) ? " was deleted." : " could not be deleted." ) ) ; } public static void main ( String args [ ] ) { test ( "file" , "input.txt" ) ; test ( "file" , File . seperator + "input.txt" ) ; test ( "directory" , "docs" ) ; test ( "directory" , File . seperator + "docs" + File . seperator ) ; } } 
public static boolean infinity ( double numer , double denom ) { return Double . isInfinite ( numer / denom ) ; } 
public static boolean except ( double numer , double denom ) { try { int dummy = ( int ) numer / ( int ) denom ; return false ; } catch ( ArithmeticException e ) { return true ; } } 
public boolean isNumeric ( String input ) { try { Integer . parseInt ( input ) ; return true ; } catch ( NumberFormatException e ) { return false ; } } 
private static final boolean isNumeric ( final String s ) { if ( s == null || s . isEmpty ( ) ) return false ; for ( int x = 0 ; x < s . length ( ) ; x ++ ) { final char c = s . charAt ( x ) ; if ( x == 0 && ( c == '-' ) ) continue ; if ( ( c >= '0' ) && ( c <= '9' ) ) continue ; return false ; } return true ; } 
public static boolean isNumeric ( String inputData ) { return inputData . matches ( "[-+]?\\d+(\\.\\d+)?" ) ; } 
public static boolean isNumeric ( String inputData ) { NumberFormat formatter = NumberFormat . getInstance ( ) ; ParsePosition pos = new ParsePosition ( 0 ) ; formatter . parse ( inputData , pos ) ; return inputData . length ( ) == pos . getIndex ( ) ; } 
public static boolean isNumeric ( String inputData ) { Scanner sc = new Scanner ( inputData ) ; return sc . hasNextInt ( ) ; } 
import java . util . Calendar ; import java . util . GregorianCalendar ; public class DiscordianDate { final static String [ ] seasons = { "Chaos" , "Discord" , "Confusion" , "Bureaucracy" , "The Aftermath" } ; final static String [ ] weekday = { "Sweetmorn" , "Boomtime" , "Pungenday" , "Prickle-Prickle" , "Setting Orange" } ; final static String [ ] apostle = { "Mungday" , "Mojoday" , "Syaday" , "Zaraday" , "Maladay" } ; final static String [ ] holiday = { "Chaoflux" , "Discoflux" , "Confuflux" , "Bureflux" , "Afflux" } ; public static String discordianDate ( final GregorianCalendar date ) { int y = date . get ( Calendar . YEAR ) ; int yold = y + 1166 ; int dayOfYear = date . get ( Calendar . DAY_OF_YEAR ) ; if ( date . isLeapYear ( y ) ) { if ( dayOfYear == 60 ) return "St. Tib's Day, in the YOLD " + yold ; else if ( dayOfYear > 60 ) dayOfYear -- ; } dayOfYear -- ; int seasonDay = dayOfYear % 73 + 1 ; if ( seasonDay == 5 ) return apostle [ dayOfYear / 73 ] + ", in the YOLD " + yold ; if ( seasonDay == 50 ) return holiday [ dayOfYear / 73 ] + ", in the YOLD " + yold ; String season = seasons [ dayOfYear / 73 ] ; String dayOfWeek = weekday [ dayOfYear % 5 ] ; return String . format ( "%s, day %s of %s in the YOLD %s" , dayOfWeek , seasonDay , season , yold ) ; } public static void main ( String [ ] args ) { System . out . println ( discordianDate ( new GregorianCalendar ( ) ) ) ; test ( 2010 , 6 , 22 , "Pungenday, day 57 of Confusion in the YOLD 3176" ) ; test ( 2012 , 1 , 28 , "Prickle-Prickle, day 59 of Chaos in the YOLD 3178" ) ; test ( 2012 , 1 , 29 , "St. Tib's Day, in the YOLD 3178" ) ; test ( 2012 , 2 , 1 , "Setting Orange, day 60 of Chaos in the YOLD 3178" ) ; test ( 2010 , 0 , 5 , "Mungday, in the YOLD 3176" ) ; test ( 2011 , 4 , 3 , "Discoflux, in the YOLD 3177" ) ; test ( 2015 , 9 , 19 , "Boomtime, day 73 of Bureaucracy in the YOLD 3181" ) ; } private static void test ( int y , int m , int d , final String result ) { assert ( discordianDate ( new GregorianCalendar ( y , m , d ) ) . equals ( result ) ) ; } } 
public class DotProduct { public static void main ( String [ ] args ) { double [ ] a = { 1 , 3 , - 5 } ; double [ ] b = { 4 , - 2 , - 1 } ; System . out . println ( dotProd ( a , b ) ) ; } public static double dotProd ( double [ ] a , double [ ] b ) { if ( a . length != b . length ) { throw new IllegalArgumentException ( "The dimensions have to be equal!" ) ; } double sum = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { sum += a [ i ] * b [ i ] ; } return sum ; } } 
String s = "" ; if ( s != null && s . isEmpty ( ) ) { System . out . println ( "s is empty" ) ; } else { System . out . println ( "s is not empty" ) ; } 
final int immutableInt = 4 ; int mutableInt = 4 ; mutableInt = 6 ; immutableInt = 6 ; 
final String immutableString = "test" ; immutableString = new String ( "anotherTest" ) ; final StringBuffer immutableBuffer = new StringBuffer ( ) ; immutableBuffer . append ( "a" ) ; immutableBuffer = new StringBuffer ( "a" ) ; 
public class Immute { private final int num ; private final String word ; private final StringBuffer buff ; public Immute ( int num ) { this . num = num ; word = num + "" ; buff = new StringBuffer ( "test" + word ) ; } public int getNum ( ) { return num ; } public String getWord ( ) { return word ; } public StringBuffer getBuff ( ) { return new StringBuffer ( buff ) ; } } 
enum Fruits { APPLE , BANANA , CHERRY } 
enum Fruits { APPLE ( 0 ) , BANANA ( 1 ) , CHERRY ( 2 ) private final int value ; fruits ( int value ) { this . value = value ; } public int value ( ) { return value ; } } 
System . getenv ( "HOME" ) System . getenv ( ) 
public class Equlibrium { public static void main ( String [ ] args ) { int [ ] sequence = { - 7 , 1 , 5 , 2 , - 4 , 3 , 0 } ; equlibrium_indices ( sequence ) ; } public static void equlibrium_indices ( int [ ] sequence ) { int totalSum = 0 ; for ( int n : sequence ) { totalSum += n ; } int runningSum = 0 ; for ( int i = 0 ; i < sequence . length ; i ++ ) { int n = sequence [ i ] ; if ( totalSum - runningSum - n == runningSum ) { System . out . println ( i ) ; } runningSum += n ; } } } 
public class Binomial { private static long binomial ( int n , int k ) { if ( k > n - k ) k = n - k ; long b = 1 ; for ( int i = 1 , m = n ; i <= k ; i ++ , m -- ) b = b * m / i ; return b ; } public static void main ( String [ ] args ) { System . out . println ( binomial ( 5 , 3 ) ) ; } } 
public class Binom { public static double binomCoeff ( double n , double k ) { double result = 1 ; for ( int i = 1 ; i < k + 1 ; i ++ ) { result *= ( n - i + 1 ) / i ; } return result ; } public static void main ( String [ ] args ) { System . out . println ( binomCoeff ( 5 , 3 ) ) ; } } 
public class Binomial { private static long binom ( int n , int k ) { if ( k == 0 ) return 1 ; else if ( k > n - k ) return binom ( n , n - k ) ; else return binom ( n - 1 , k - 1 ) * n / k ; } public static void main ( String [ ] args ) { System . out . println ( binom ( 5 , 3 ) ) ; } } 
public static boolean isEven ( int i ) { return ( i & 1 ) == 0 ; } 
public static boolean isEven ( int i ) { return ( i % 2 ) == 0 ; } 
public static boolean isEven ( BigInteger i ) { return i . and ( BigInteger . ONE ) . equals ( BigInteger . ZERO ) ; } 
public static boolean isEven ( BigInteger i ) { return ! i . testBit ( 0 ) ; } 
public static boolean isEven ( BigInteger i ) { return i . mod ( BigInteger . valueOf ( 2 ) ) . equals ( BigInteger . ZERO ) ; } 
import java . util . Random ; public class EvoAlgo { static final String target = "METHINKS IT IS LIKE A WEASEL" ; static final char [ ] possibilities = "ABCDEFGHIJKLMNOPQRSTUVWXYZ " . toCharArray ( ) ; static int C = 100 ; static double minMutateRate = 0.09 ; static int perfectFitness = target . length ( ) ; private static String parent ; static Random rand = new Random ( ) ; private static int fitness ( String trial ) { int retVal = 0 ; for ( int i = 0 ; i < trial . length ( ) ; i ++ ) { if ( trial . charAt ( i ) == target . charAt ( i ) ) retVal ++ ; } return retVal ; } private static double newMutateRate ( ) { return ( ( ( double ) perfectFitness - fitness ( parent ) ) / perfectFitness * ( 1 - minMutateRate ) ) ; } private static String mutate ( String parent , double rate ) { String retVal = "" ; for ( int i = 0 ; i < parent . length ( ) ; i ++ ) { retVal += ( rand . nextDouble ( ) <= rate ) ? possibilities [ rand . nextInt ( possibilities . length ) ] : parent . charAt ( i ) ; } return retVal ; } public static void main ( String [ ] args ) { parent = mutate ( target , 1 ) ; int iter = 0 ; while ( ! target . equals ( parent ) ) { double rate = newMutateRate ( ) ; iter ++ ; if ( iter % 100 == 0 ) { System . out . println ( iter + ": " + parent + ", fitness: " + fitness ( parent ) + ", rate: " + rate ) ; } String bestSpawn = null ; int bestFit = 0 ; for ( int i = 0 ; i < C ; i ++ ) { String spawn = mutate ( parent , rate ) ; int fitness = fitness ( spawn ) ; if ( fitness > bestFit ) { bestSpawn = spawn ; bestFit = fitness ; } } parent = bestFit > fitness ( parent ) ? bestSpawn : parent ; } System . out . println ( parent + ", " + iter ) ; } } 
public class MyException extends Exception { } public class MyRuntimeException extends RuntimeException { } 
public void fooChecked ( ) throws MyException { throw new MyException ( ) ; } public void fooUnchecked ( ) { throw new MyRuntimeException ( ) ; } 
try { fooChecked ( ) ; } catch ( MyException exc ) { } catch ( Exception exc ) { } catch ( Throwable exc ) { } finally { } 
public void foo ( ) throws UnsupportedDataTypeException { try { throwsNumberFormatException ( ) ; throwsUnsupportedDataTypeException ( ) ; throwsFileNotFoundException ( ) ; } catch ( FileNotFoundException | NumberFormatException ex ) { } catch ( IOException e ) { throw e ; } } 
import java . util . Scanner ; import java . io . * ; public class Program { public static void main ( String [ ] args ) { try { Process p = Runtime . getRuntime ( ) . exec ( "cmd /C dir" ) ; Scanner sc = new Scanner ( p . getInputStream ( ) ) ; while ( sc . hasNext ( ) ) System . out . println ( sc . nextLine ( ) ) ; } catch ( IOException e ) { System . out . println ( e . getMessage ( ) ) ; } } } 
import java . io . IOException ; import java . io . InputStream ; public class MainEntry { public static void main ( String [ ] args ) { executeCmd ( "ls -oa" ) ; } private static void executeCmd ( String string ) { InputStream pipedOut = null ; try { Process aProcess = Runtime . getRuntime ( ) . exec ( string ) ; aProcess . waitFor ( ) ; pipedOut = aProcess . getInputStream ( ) ; byte buffer [ ] = new byte [ 2048 ] ; int read = pipedOut . read ( buffer ) ; while ( read >= 0 ) { System . out . write ( buffer , 0 , read ) ; read = pipedOut . read ( buffer ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( InterruptedException ie ) { ie . printStackTrace ( ) ; } finally { if ( pipedOut != null ) { try { pipedOut . close ( ) ; } catch ( IOException e ) { } } } } } 
import java . io . IOException ; import java . io . InputStream ; public class MainEntry { public static void main ( String [ ] args ) { executeCmd ( "ls -oa" ) ; } private static void executeCmd ( String string ) { InputStream pipedOut = null ; try { Process aProcess = Runtime . getRuntime ( ) . exec ( string ) ; Thread pipeThread = new Thread ( new StreamGobber ( aProcess . getInputStream ( ) ) ) ; Thread errorThread = new Thread ( new StreamGobber ( aProcess . getErrorStream ( ) ) ) ; pipeThread . start ( ) ; errorThread . start ( ) ; aProcess . waitFor ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( InterruptedException ie ) { ie . printStackTrace ( ) ; } } } class StreamGobber implements Runnable { private InputStream Pipe ; public StreamGobber ( InputStream pipe ) { if ( pipe == null ) { throw new NullPointerException ( "bad pipe" ) ; } Pipe = pipe ; } public void run ( ) { try { byte buffer [ ] = new byte [ 2048 ] ; int read = Pipe . read ( buffer ) ; while ( read >= 0 ) { System . out . write ( buffer , 0 , read ) ; read = Pipe . read ( buffer ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { if ( Pipe != null ) { try { Pipe . close ( ) ; } catch ( IOException e ) { } } } } } 
public static long fact ( final int n ) { if ( n < 0 ) { System . err . println ( "No negative numbers" ) ; return 0 ; } long ans = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { ans *= i ; } return ans ; } 
public static long fact ( final int n ) { if ( n < 0 ) { System . err . println ( "No negative numbers" ) ; return 0 ; } return ( n < 2 ) ? 1 : n * fact ( n - 1 ) ; } 
public static TreeSet < Long > factors ( long n ) { TreeSet < Long > factors = new TreeSet < Long > ( ) ; factors . add ( n ) ; factors . add ( 1L ) ; for ( long test = n - 1 ; test >= Math . sqrt ( n ) ; test -- ) if ( n % test == 0 ) { factors . add ( test ) ; factors . add ( n / test ) ; } return factors ; } 
class Fibonacci { public static int [ ] lucas ( int n , int numRequested ) { if ( n < 2 ) throw new IllegalArgumentException ( "Fibonacci value must be at least 2" ) ; return fibonacci ( ( n == 2 ) ? new int [ ] { 2 , 1 } : lucas ( n - 1 , n ) , numRequested ) ; } public static int [ ] fibonacci ( int n , int numRequested ) { if ( n < 2 ) throw new IllegalArgumentException ( "Fibonacci value must be at least 2" ) ; return fibonacci ( ( n == 2 ) ? new int [ ] { 1 , 1 } : fibonacci ( n - 1 , n ) , numRequested ) ; } public static int [ ] fibonacci ( int [ ] startingValues , int numRequested ) { int [ ] output = new int [ numRequested ] ; int n = startingValues . length ; System . arraycopy ( startingValues , 0 , output , 0 , n ) ; for ( int i = n ; i < numRequested ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) output [ i ] += output [ i - j ] ; return output ; } public static void main ( String [ ] args ) { for ( int n = 2 ; n <= 10 ; n ++ ) { System . out . print ( "nacci(" + n + "):" ) ; for ( int value : fibonacci ( n , 15 ) ) System . out . print ( " " + value ) ; System . out . println ( ) ; } for ( int n = 2 ; n <= 10 ; n ++ ) { System . out . print ( "lucas(" + n + "):" ) ; for ( int value : lucas ( n , 15 ) ) System . out . print ( " " + value ) ; System . out . println ( ) ; } } } 
public static long itFibN ( int n ) { if ( n < 2 ) return n ; long ans = 0 ; long n1 = 0 ; long n2 = 1 ; for ( n -- ; n > 0 ; n -- ) { ans = n1 + n2 ; n1 = n2 ; n2 = ans ; } return ans ; } 
public static long fib ( long n ) { if ( n <= 0 ) return 0 ; long i = ( int ) ( n - 1 ) ; long a = 1 , b = 0 , c = 0 , d = 1 , tmp1 , tmp2 ; while ( i > 0 ) { if ( i % 2 != 0 ) { tmp1 = d * b + c * a ; tmp2 = d * ( b + a ) + c * b ; a = tmp1 ; b = tmp2 ; } tmp1 = ( long ) ( Math . pow ( c , 2 ) + Math . pow ( d , 2 ) ) ; tmp2 = d * ( 2 * c + d ) ; c = tmp1 ; d = tmp2 ; i = i / 2 ; } return a + b ; } 
public static long recFibN ( final int n ) { return ( n < 2 ) ? n : recFibN ( n - 1 ) + recFibN ( n - 2 ) ; } 
public static long anFibN ( final long n ) { double p = ( 1 + Math . sqrt ( 5 ) ) / 2 ; double q = 1 / p ; return ( long ) ( ( Math . pow ( p , n ) + Math . pow ( q , n ) ) / Math . sqrt ( 5 ) ) ; } 
public static long fibTailRec ( final int n ) { return fibInner ( 0 , 1 , n ) ; } private static long fibInner ( final long a , final long b , final int n ) { return n < 1 ? a : n == 1 ? b : fibInner ( b , a + b , n - 1 ) ; } 
import java . util . function . LongUnaryOperator ; import java . util . stream . LongStream ; public class FibUtil { public static LongStream fibStream ( ) { return LongStream . iterate ( 1l , new LongUnaryOperator ( ) { private long lastFib = 0 ; @ Override public long applyAsLong ( long operand ) { long ret = operand + lastFib ; lastFib = operand ; return ret ; } } ) ; } public static long fib ( long n ) { return fibStream ( ) . limit ( n ) . reduce ( ( prev , last ) -> last ) . getAsLong ( ) ; } } 
import java . io . * ; public class FileIODemo { public static void main ( String [ ] args ) { try { FileInputStream in = new FileInputStream ( "input.txt" ) ; FileOutputStream out = new FileOutputStream ( "ouput.txt" ) ; int c ; while ( ( c = in . read ( ) ) != - 1 ) { out . write ( c ) ; } } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } 
import java . io . * ; public class FileIODemo2 { public static void main ( String args [ ] ) { try { final InputStream in = new FileInputStream ( "input.txt" ) ; try { final OutputStream out = new FileOutputStream ( "output.txt" ) ; try { int c ; while ( ( c = in . read ( ) ) != - 1 ) { out . write ( c ) ; } } finally { out . close ( ) ; } } finally { in . close ( ) ; } } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } 
import java . io . * ; import java . nio . channels . * ; public class FileIODemo3 { public static void main ( String args [ ] ) { try { final FileChannel in = new FileInputStream ( "input.txt" ) . getChannel ( ) ; try { final FileChannel out = new FileOutputStream ( "output.txt" ) . getChannel ( ) ; try { out . transferFrom ( in , 0 , in . size ( ) ) ; } finally { out . close ( ) ; } } finally { in . close ( ) ; } } catch ( Exception e ) { System . err . println ( "Exception while trying to copy: " + e ) ; e . printStackTrace ( ) ; } } } 
import java . io . * ; public class Test { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new FileReader ( "input.txt" ) ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( "output.txt" ) ) ; String line ; while ( ( line = br . readLine ( ) ) != null ) { bw . write ( line ) ; bw . newLine ( ) ; } br . close ( ) ; bw . close ( ) ; } } 
import java . nio . file . * ; public class Copy { public static void main ( String [ ] args ) throws Exception { FileSystem fs = FileSystems . getDefault ( ) ; Path in = fs . getPath ( "input.txt" ) ; Path out = fs . getPath ( "output.txt" ) ; Files . copy ( in , out , StandardCopyOption . REPLACE_EXISTING ) ; } } 
import java . io . File ; import java . util . Date ; public class FileModificationTimeTest { public static void test ( String type , File file ) { long t = file . lastModified ( ) ; System . out . println ( "The following " + type + " called " + file . getPath ( ) + ( t == 0 ? " does not exist." : " was modified at " + new Date ( t ) . toString ( ) ) ) ; System . out . println ( "The following " + type + " called " + file . getPath ( ) + ( ! file . setLastModified ( System . currentTimeMillis ( ) ) ? " does not exist." : " was modified to current time." ) ) ; System . out . println ( "The following " + type + " called " + file . getPath ( ) + ( ! file . setLastModified ( t ) ? " does not exist." : " was modified to previous time." ) ) ; } public static void main ( String args [ ] ) { test ( "file" , new File ( "output.txt" ) ) ; test ( "directory" , new File ( "docs" ) ) ; } } 
import java . io . File ; public class FileSize { public static void main ( String [ ] args ) { System . out . println ( "input.txt  : " + new File ( "input.txt" ) . length ( ) + " bytes" ) ; System . out . println ( "/input.txt : " + new File ( "/input.txt" ) . length ( ) + " bytes" ) ; } } 
int [ ] array = { 1 , 2 , 3 , 4 , 5 } ; List < Integer > evensList = new ArrayList < Integer > ( ) ; for ( int i : array ) { if ( i % 2 == 0 ) evensList . add ( i ) ; } int [ ] evens = evensList . toArray ( new int [ 0 ] ) ; 
public class RecursionTest { private static void recurse ( int i ) { try { recurse ( i + 1 ) ; } catch ( StackOverflowError e ) { System . out . print ( "Recursion depth on this system is " + i + "." ) ; } } public static void main ( String [ ] args ) { recurse ( 0 ) ; } } 
import java . util . Scanner ; public class LastSunday { static final String [ ] months = { "January" , "February" , "March" , "April" , "May" , "June" , "July" , "August" , "September" , "October" , "November" , "December" } ; public static int [ ] findLastSunday ( int year ) { boolean isLeap = isLeapYear ( year ) ; int [ ] days = { 31 , isLeap ? 29 : 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; int [ ] lastDay = new int [ 12 ] ; for ( int m = 0 ; i < 12 ; i ++ ) { int d ; for ( d = days [ m ] ; getWeekDay ( year , m , d ) != 0 ; d -- ) ; lastDay [ m ] = d ; } return lastDay ; } private static boolean isLeapYear ( int year ) { if ( year % 4 == 0 ) { if ( year % 100 != 0 ) return true ; else if ( year % 400 == 0 ) return true ; } return false ; } private static int getWeekDay ( int y , int m , int d ) { int f = y + d + 3 * m - 1 ; m ++ ; if ( m < 3 ) y -- ; else f -= ( int ) ( 0.4 * m + 2.3 ) ; f += ( int ) ( y / 4 ) - ( int ) ( ( y / 100 + 1 ) * 0.75 ) ; f %= 7 ; return f ; } private static void display ( int year , int [ ] lastDay ) { System . out . println ( "\nYEAR: " + year ) ; for ( int m = 0 ; i < 12 ; i ++ ) System . out . println ( months [ m ] + ": " + lastDay [ m ] ) ; } public static void main ( String [ ] args ) throws Exception { System . out . print ( "Enter year: " ) ; Scanner s = new Scanner ( System . in ) ; int y = Integer . parseInt ( s . next ( ) ) ; int [ ] lastDay = findLastSunday ( y ) ; display ( y , lastDay ) ; s . close ( ) ; } } 
import java . time . * ; import java . util . stream . * ; import static java . time . temporal . TemporalAdjusters . * ; public class FindTheLastSundayOfEachMonth { public static Stream < LocalDate > lastSundaysOf ( int year ) { return IntStream . rangeClosed ( 1 , 12 ) . mapToObj ( month -> LocalDate . of ( year , month , 1 ) . with ( lastDayOfMonth ( ) ) . with ( previousOrSame ( DayOfWeek . SUNDAY ) ) ) ; } public static java . util . List < LocalDate > listLastSundaysOf ( int year ) { return lastSundaysOf ( year ) . collect ( Collectors . toList ( ) ) ; } public static void main ( String [ ] args ) throws Exception { int year = args . length > 0 ? Integer . parseInt ( args [ 0 ] ) : LocalDate . now ( ) . getYear ( ) ; for ( LocalDate d : listLastSundaysOf ( year ) ) { System . out . println ( d ) ; } ; String result = lastSundaysOf ( 2013 ) . map ( LocalDate :: toString ) . collect ( Collectors . joining ( "\n" ) ) ; String test = "2013-01-27\n2013-02-24\n2013-03-31\n2013-04-28\n2013-05-26\n2013-06-30\n2013-07-28\n2013-08-25\n2013-09-29\n2013-10-27\n2013-11-24\n2013-12-29" ; if ( ! test . equals ( result ) ) throw new AssertionError ( "test failure" ) ; } } 
import java . util . ArrayList ; import com . google . common . base . Joiner ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Lists ; public class FindMissingPermutation { public static void main ( String [ ] args ) { Joiner joiner = Joiner . on ( "" ) . skipNulls ( ) ; ImmutableSet < String > s = ImmutableSet . of ( "ABCD" , "CABD" , "ACDB" , "DACB" , "BCDA" , "ACBD" , "ADCB" , "CDAB" , "DABC" , "BCAD" , "CADB" , "CDBA" , "CBAD" , "ABDC" , "ADBC" , "BDCA" , "DCBA" , "BACD" , "BADC" , "BDAC" , "CBDA" , "DBCA" , "DCAB" ) ; for ( ArrayList < Character > cs : Utils . Permutations ( Lists . newArrayList ( 'A' , 'B' , 'C' , 'D' ) ) ) if ( ! s . contains ( joiner . join ( cs ) ) ) System . out . println ( joiner . join ( cs ) ) ; } } 
public class FindMissingPermutation { public static void main ( String [ ] args ) { String [ ] givenPermutations = { "ABCD" , "CABD" , "ACDB" , "DACB" , "BCDA" , "ACBD" , "ADCB" , "CDAB" , "DABC" , "BCAD" , "CADB" , "CDBA" , "CBAD" , "ABDC" , "ADBC" , "BDCA" , "DCBA" , "BACD" , "BADC" , "BDAC" , "CBDA" , "DBCA" , "DCAB" } ; String characterSet = givenPermutations [ 0 ] ; int maxCode = characterSet . length ( ) - 1 ; for ( int i = characterSet . length ( ) ; i >= 3 ; i -- ) maxCode *= i ; StringBuilder missingPermutation = new StringBuilder ( ) ; for ( int i = 0 ; i < characterSet . length ( ) ; i ++ ) { int code = 0 ; for ( String permutation : givenPermutations ) code += characterSet . indexOf ( permutation . charAt ( i ) ) ; missingPermutation . append ( characterSet . charAt ( maxCode - code ) ) ; } System . out . println ( "Missing permutation: " + missingPermutation . toString ( ) ) ; } } 
import java . util . ArrayList ; public class FirstClass { public interface Function < A , B > { B apply ( A x ) ; } public static < A , B , C > Function < A , C > compose ( final Function < B , C > f , final Function < A , B > g ) { return new Function < A , C > ( ) { @ Override public C apply ( A x ) { return f . apply ( g . apply ( x ) ) ; } } ; } public static void main ( String [ ] args ) { ArrayList < Function < Double , Double > > functions = new ArrayList < Function < Double , Double > > ( ) ; functions . add ( new Function < Double , Double > ( ) { @ Override public Double apply ( Double x ) { return Math . cos ( x ) ; } } ) ; functions . add ( new Function < Double , Double > ( ) { @ Override public Double apply ( Double x ) { return Math . tan ( x ) ; } } ) ; functions . add ( new Function < Double , Double > ( ) { @ Override public Double apply ( Double x ) { return x * x ; } } ) ; ArrayList < Function < Double , Double > > inverse = new ArrayList < Function < Double , Double > > ( ) ; inverse . add ( new Function < Double , Double > ( ) { @ Override public Double apply ( Double x ) { return Math . acos ( x ) ; } } ) ; inverse . add ( new Function < Double , Double > ( ) { @ Override public Double apply ( Double x ) { return Math . atan ( x ) ; } } ) ; inverse . add ( new Function < Double , Double > ( ) { @ Override public Double apply ( Double x ) { return Math . sqrt ( x ) ; } } ) ; System . out . println ( "Compositions:" ) ; for ( int i = 0 ; i < functions . size ( ) ; i ++ ) { System . out . println ( compose ( functions . get ( i ) , inverse . get ( i ) ) . apply ( 0.5 ) ) ; } System . out . println ( "Hard-coded compositions:" ) ; System . out . println ( Math . cos ( Math . acos ( 0.5 ) ) ) ; System . out . println ( Math . tan ( Math . atan ( 0.5 ) ) ) ; System . out . println ( Math . pow ( Math . sqrt ( 0.5 ) , 2 ) ) ; } } 
import java . util . ArrayList ; import java . util . function . Function ; public class FirstClass { public static void main ( String ... arguments ) { ArrayList < Function < Double , Double > > functions = new ArrayList < > ( ) ; functions . add ( Math :: cos ) ; functions . add ( Math :: tan ) ; functions . add ( x -> x * x ) ; ArrayList < Function < Double , Double > > inverse = new ArrayList < > ( ) ; inverse . add ( Math :: acos ) ; inverse . add ( Math :: atan ) ; inverse . add ( Math :: sqrt ) ; System . out . println ( "Compositions:" ) ; for ( int i = 0 ; i < functions . size ( ) ; i ++ ) { System . out . println ( functions . get ( i ) . compose ( inverse . get ( i ) ) . apply ( 0.5 ) ) ; } System . out . println ( "Hard-coded compositions:" ) ; System . out . println ( Math . cos ( Math . acos ( 0.5 ) ) ) ; System . out . println ( Math . tan ( Math . atan ( 0.5 ) ) ) ; System . out . println ( Math . pow ( Math . sqrt ( 0.5 ) , 2 ) ) ; } } 
import java . util . LinkedList ; import java . util . List ; public final class FlattenUtil { public static List < Object > flatten ( List < ? > list ) { List < Object > retVal = new LinkedList < Object > ( ) ; flatten ( list , retVal ) ; return retVal ; } public static void flatten ( List < ? > fromTreeList , List < Object > toFlatList ) { for ( Object item : fromTreeList ) { if ( item instanceof List < ? > ) { flatten ( ( List < ? > ) item , toFlatList ) ; } else { toFlatList . add ( item ) ; } } } } 
import static java . util . Arrays . asList ; import java . util . List ; public final class FlattenTestMain { public static void main ( String [ ] args ) { List < Object > treeList = a ( a ( 1 ) , 2 , a ( a ( 3 , 4 ) , 5 ) , a ( a ( a ( ) ) ) , a ( a ( a ( 6 ) ) ) , 7 , 8 , a ( ) ) ; List < Object > flatList = FlattenUtil . flatten ( treeList ) ; System . out . println ( treeList ) ; System . out . println ( "flatten: " + flatList ) ; } private static List < Object > a ( Object ... a ) { return asList ( a ) ; } } 
import java . util . List ; import java . util . stream . Stream ; import java . util . stream . Collectors ; public final class FlattenUtil { public static Stream < Object > flattenToStream ( List < ? > list ) { return list . stream ( ) . flatMap ( item -> item instanceof List < ? > ? flattenToStream ( ( List < ? > ) item ) : Stream . of ( item ) ) ; } public static List < Object > flatten ( List < ? > list ) { return flattenToStream ( list ) . collect ( Collectors . toList ( ) ) ; } } 
public class Floyd { public static void main ( String [ ] args ) { printTriangle ( 5 ) ; printTriangle ( 14 ) ; } private static void printTriangle ( int n ) { System . out . println ( n + " rows:" ) ; for ( int rowNum = 1 , printMe = 1 , numsPrinted = 0 ; rowNum <= n ; printMe ++ ) { int cols = ( int ) Math . ceil ( Math . log10 ( n * ( n - 1 ) / 2 + numsPrinted + 2 ) ) ; System . out . printf ( "%" + cols + "d " , printMe ) ; if ( ++ numsPrinted == rowNum ) { System . out . println ( ) ; rowNum ++ ; numsPrinted = 0 ; } } } } 
import java . util . Arrays ; import java . util . LinkedList ; import java . util . List ; public class Fire { private static final char BURNING = 'w' ; private static final char TREE = 'T' ; private static final char EMPTY = '.' ; private static final double F = 0.2 ; private static final double P = 0.4 ; private static final double TREE_PROB = 0.5 ; private static List < String > process ( List < String > land ) { List < String > newLand = new LinkedList < String > ( ) ; for ( int i = 0 ; i < land . size ( ) ; i ++ ) { String rowAbove , thisRow = land . get ( i ) , rowBelow ; if ( i == 0 ) { rowAbove = null ; rowBelow = land . get ( i + 1 ) ; } else if ( i == land . size ( ) - 1 ) { rowBelow = null ; rowAbove = land . get ( i - 1 ) ; } else { rowBelow = land . get ( i + 1 ) ; rowAbove = land . get ( i - 1 ) ; } newLand . add ( processRows ( rowAbove , thisRow , rowBelow ) ) ; } return newLand ; } private static String processRows ( String rowAbove , String thisRow , String rowBelow ) { String newRow = "" ; for ( int i = 0 ; i < thisRow . length ( ) ; i ++ ) { switch ( thisRow . charAt ( i ) ) { case BURNING : newRow += EMPTY ; break ; case EMPTY : newRow += Math . random ( ) < P ? TREE : EMPTY ; break ; case TREE : String neighbors = "" ; if ( i == 0 ) { neighbors += rowAbove == null ? "" : rowAbove . substring ( i , i + 2 ) ; neighbors += thisRow . charAt ( i + 1 ) ; neighbors += rowBelow == null ? "" : rowBelow . substring ( i , i + 2 ) ; if ( neighbors . contains ( Character . toString ( BURNING ) ) ) { newRow += BURNING ; break ; } } else if ( i == thisRow . length ( ) - 1 ) { neighbors += rowAbove == null ? "" : rowAbove . substring ( i - 1 , i + 1 ) ; neighbors += thisRow . charAt ( i - 1 ) ; neighbors += rowBelow == null ? "" : rowBelow . substring ( i - 1 , i + 1 ) ; if ( neighbors . contains ( Character . toString ( BURNING ) ) ) { newRow += BURNING ; break ; } } else { neighbors += rowAbove == null ? "" : rowAbove . substring ( i - 1 , i + 2 ) ; neighbors += thisRow . charAt ( i + 1 ) ; neighbors += thisRow . charAt ( i - 1 ) ; neighbors += rowBelow == null ? "" : rowBelow . substring ( i - 1 , i + 2 ) ; if ( neighbors . contains ( Character . toString ( BURNING ) ) ) { newRow += BURNING ; break ; } } newRow += Math . random ( ) < F ? BURNING : TREE ; } } return newRow ; } public static List < String > populate ( int width , int height ) { List < String > land = new LinkedList < String > ( ) ; for ( ; height > 0 ; height -- ) { StringBuilder line = new StringBuilder ( width ) ; for ( int i = width ; i > 0 ; i -- ) { line . append ( ( Math . random ( ) < TREE_PROB ) ? TREE : EMPTY ) ; } land . add ( line . toString ( ) ) ; } return land ; } public static void processN ( List < String > land , int n ) { for ( int i = 0 ; i < n ; i ++ ) { land = process ( land ) ; } } public static void processNPrint ( List < String > land , int n ) { for ( int i = 0 ; i < n ; i ++ ) { land = process ( land ) ; print ( land ) ; } } public static void print ( List < String > land ) { for ( String row : land ) { System . out . println ( row ) ; } System . out . println ( ) ; } public static void main ( String [ ] args ) { List < String > land = Arrays . asList ( ".TTT.T.T.TTTT.T" , "T.T.T.TT..T.T.." , "TT.TTTT...T.TT." , "TTT..TTTTT.T..T" , ".T.TTT....TT.TT" , "...T..TTT.TT.T." , ".TT.TT...TT..TT" , ".TT.T.T..T.T.T." , "..TTT.TT.T..T.." , ".T....T.....TTT" , "T..TTT..T..T..." , "TTT....TTTTTT.T" , "......TwTTT...T" , "..T....TTTTTTTT" , ".T.T.T....TT..." ) ; print ( land ) ; processNPrint ( land , 10 ) ; System . out . println ( "Random land test:" ) ; land = populate ( 10 , 10 ) ; print ( land ) ; processNPrint ( land , 10 ) ; } } 
public class Printing { public static void main ( String [ ] args ) { double printer = 7.125 ; System . out . printf ( "%09.3f" , printer ) ; } } 
import java . text . DecimalFormat ; import java . text . NumberFormat ; public class Format { public static void main ( String [ ] args ) { NumberFormat numForm = new DecimalFormat ( ) ; numForm . setMinimumIntegerDigits ( 9 ) ; numForm . setGroupingUsed ( false ) ; System . out . println ( numForm . format ( 7.125 ) ) ; numForm . setMinimumIntegerDigits ( 5 ) ; numForm . setMinimumFractionDigits ( 5 ) ; System . out . println ( numForm . format ( 7.125 ) ) ; numForm . setMinimumFractionDigits ( 0 ) ; numForm . setMaximumFractionDigits ( 2 ) ; System . out . println ( numForm . format ( 7.125 ) ) ; System . out . println ( numForm . format ( 7.135 ) ) ; } } 
import java . util . Arrays ; public class FD { public static void main ( String args [ ] ) { double [ ] a = { 90 , 47 , 58 , 29 , 22 , 32 , 55 , 5 , 55 , 73 } ; System . out . println ( Arrays . toString ( dif ( a , 1 ) ) ) ; System . out . println ( Arrays . toString ( dif ( a , 2 ) ) ) ; System . out . println ( Arrays . toString ( dif ( a , 9 ) ) ) ; System . out . println ( Arrays . toString ( dif ( a , 10 ) ) ) ; System . out . println ( Arrays . toString ( dif ( a , 11 ) ) ) ; System . out . println ( Arrays . toString ( dif ( a , - 1 ) ) ) ; System . out . println ( Arrays . toString ( dif ( a , 0 ) ) ) ; } public static double [ ] dif ( double [ ] a , int n ) { if ( n < 0 ) return null ; for ( int i = 0 ; i < n && a . length > 0 ; i ++ ) { double [ ] b = new double [ a . length - 1 ] ; for ( int j = 0 ; j < b . length ; j ++ ) { b [ j ] = a [ j + 1 ] - a [ j ] ; } a = b ; } return a ; } } 
import java . awt . Color ; import java . awt . Graphics ; import javax . swing . JFrame ; public class FractalTree extends JFrame { public FractalTree ( ) { super ( "Fractal Tree" ) ; setBounds ( 100 , 100 , 800 , 600 ) ; setResizable ( false ) ; setDefaultCloseOperation ( EXIT_ON_CLOSE ) ; } private void drawTree ( Graphics g , int x1 , int y1 , double angle , int depth ) { if ( depth == 0 ) return ; int x2 = x1 + ( int ) ( Math . cos ( Math . toRadians ( angle ) ) * depth * 10.0 ) ; int y2 = y1 + ( int ) ( Math . sin ( Math . toRadians ( angle ) ) * depth * 10.0 ) ; g . drawLine ( x1 , y1 , x2 , y2 ) ; drawTree ( g , x2 , y2 , angle - 20 , depth - 1 ) ; drawTree ( g , x2 , y2 , angle + 20 , depth - 1 ) ; } @ Override public void paint ( Graphics g ) { g . setColor ( Color . BLACK ) ; drawTree ( g , 400 , 500 , - 90 , 9 ) ; } public static void main ( String [ ] args ) { new FractalTree ( ) . setVisible ( true ) ; } } 
public class Compose { public interface Fun < A , B > { B call ( A x ) ; } public static < A , B , C > Fun < A , C > compose ( final Fun < B , C > f , final Fun < A , B > g ) { return new Fun < A , C > ( ) { public C call ( A x ) { return f . call ( g . call ( x ) ) ; } } ; } public static void main ( String [ ] args ) { Fun < Double , Double > sin = new Fun < Double , Double > ( ) { public Double call ( Double x ) { return Math . sin ( x ) ; } } ; Fun < Double , Double > asin = new Fun < Double , Double > ( ) { public Double call ( Double x ) { return Math . asin ( x ) ; } } ; Fun < Double , Double > sin_asin = compose ( sin , asin ) ; System . out . println ( sin_asin . call ( 0.5 ) ) ; } } 
import java . util . function . Function ; public class Compose { public static void main ( String [ ] args ) { Function < Double , Double > sin_asin = ( ( Function < Double , Double > ) Math :: sin ) . compose ( Math :: asin ) ; System . out . println ( sin_asin . apply ( 0.5 ) ) ; } } 
import java . util . function . Function ; public class Compose { public static < A , B , C > Function < A , C > compose ( Function < B , C > f , Function < A , B > g ) { return x -> f . apply ( g . apply ( x ) ) ; } public static void main ( String [ ] args ) { Function < Double , Double > sin_asin = compose ( Math :: sin , Math :: asin ) ; System . out . println ( sin_asin . apply ( 0.5 ) ) ; } } 
public class Math { public static int multiply ( int a , int b ) { return a * b ; } public static double multiply ( double a , double b ) { return a * b ; } } 
public class LowerAscii { public static void main ( String [ ] args ) { StringBuilder sb = new StringBuilder ( 26 ) ; for ( char ch = 'a' ; ch <= 'z' ; ch ++ ) sb . append ( ch ) ; System . out . printf ( "lower ascii: %s, length: %s" , sb , sb . length ( ) ) ; } } 
import java . util . function . LongSupplier ; import static java . util . stream . LongStream . generate ; public class GeneratorExponential implements LongSupplier { private LongSupplier source , filter ; private long s , f ; public GeneratorExponential ( LongSupplier source , LongSupplier filter ) { this . source = source ; this . filter = filter ; f = filter . getAsLong ( ) ; } @ Override public long getAsLong ( ) { s = source . getAsLong ( ) ; while ( s == f ) { s = source . getAsLong ( ) ; f = filter . getAsLong ( ) ; } while ( s > f ) { f = filter . getAsLong ( ) ; } return s ; } public static void main ( String [ ] args ) { generate ( new GeneratorExponential ( new SquaresGen ( ) , new CubesGen ( ) ) ) . skip ( 20 ) . limit ( 10 ) . forEach ( n -> System . out . printf ( "%d " , n ) ) ; } } class SquaresGen implements LongSupplier { private long n ; @ Override public long getAsLong ( ) { return n * n ++ ; } } class CubesGen implements LongSupplier { private long n ; @ Override public long getAsLong ( ) { return n * n * n ++ ; } } 
class Pair < T > { T first ; T second ; } public static < T > void swap ( Pair < T > p ) { T temp = p . first ; p . first = p . second ; p . second = temp ; } 
public static long gcd ( long a , long b ) { long factor = Math . min ( a , b ) ; for ( long loop = factor ; loop > 1 ; loop -- ) { if ( a % loop == 0 && b % loop == 0 ) { return loop ; } } return 1 ; } 
public static int gcd ( int a , int b ) { while ( b > 0 ) { int c = a % b ; a = b ; b = c ; } return a ; } 
static int gcd ( int a , int b ) { int min = a > b ? b : a , max = a + b - min , div = min ; for ( int i = 1 ; i < min ; div = min / ++ i ) if ( min % div == 0 && max % div == 0 ) return div ; return 1 ; } 
public static long gcd ( long u , long v ) { long t , k ; if ( v == 0 ) return u ; u = Math . abs ( u ) ; v = Math . abs ( v ) ; if ( u < v ) { t = u ; u = v ; v = t ; } for ( k = 1 ; ( u & 1 ) == 0 && ( v & 1 ) == 0 ; k <<= 1 ) { u >>= 1 ; v >>= 1 ; } t = ( u & 1 ) != 0 ? - v : u ; while ( t != 0 ) { while ( ( t & 1 ) == 0 ) t >>= 1 ; if ( t > 0 ) u = t ; else v = - t ; t = u - v ; } return u * k ; } 
public static long gcd ( long a , long b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a > b ) return gcd ( b , a % b ) ; return gcd ( a , b % a ) ; } 
import java . math . BigInteger ; public static long gcd ( long a , long b ) { return BigInteger . valueOf ( a ) . gcd ( BigInteger . valueOf ( b ) ) . longValue ( ) ; } 
public static float max ( float [ ] values ) throws NoSuchElementException { if ( values . length == 0 ) throw new NoSuchElementException ( ) ; float themax = values [ 0 ] ; for ( int idx = 1 ; idx < values . length ; ++ idx ) { if ( values [ idx ] > themax ) themax = values [ idx ] ; } return themax ; } 
public static float max ( float [ ] values ) throws NoSuchElementException { if ( values . length == 0 ) throw new NoSuchElementException ( ) ; Arrays . sort ( values ) ; return values [ values . length - 1 ] ; } 
import java . util . List ; import java . util . Collections ; import java . util . Arrays ; public static < T extends Comparable < ? super T > > T max ( List < T > values ) { return Collections . max ( values ) ; } public static < T extends Comparable < ? super T > > T max ( T [ ] values ) { return Collections . max ( Arrays . asList ( values ) ) ; } 
import java . util . Scanner ; import java . util . ArrayList ; public class Sub { private static int [ ] indices ; public static void main ( String [ ] args ) { ArrayList < Long > array = new ArrayList < Long > ( ) ; Scanner in = new Scanner ( System . in ) ; while ( in . hasNextLong ( ) ) array . add ( in . nextLong ( ) ) ; long highSum = Long . MIN_VALUE ; ArrayList < Long > highSet = new ArrayList < Long > ( ) ; for ( int subSize = 0 ; subSize <= array . size ( ) ; subSize ++ ) { indices = new int [ subSize ] ; for ( int i = 0 ; i < subSize ; i ++ ) indices [ i ] = i ; do { long sum = 0 ; ArrayList < Long > temp = new ArrayList < Long > ( ) ; for ( long index : indices ) { sum += array . get ( index ) ; temp . add ( array . get ( index ) ) ; } if ( sum > highSum ) { highSet = temp ; highSum = sum ; } } while ( nextIndices ( array ) ) ; } System . out . println ( "Sum: " + highSum + "\nSet: " + highSet ) ; } private static boolean nextIndices ( ArrayList < Long > a ) { for ( int i = indices . length - 1 ; i >= 0 ; -- i ) { indices [ i ] ++ ; for ( int j = i + 1 ; j < indices . length ; ++ j ) { indices [ j ] = indices [ j - 1 ] + 1 ; } if ( indices [ indices . length - 1 ] < a . size ( ) ) { return true ; } } return false ; } } 
private static int BiggestSubsum ( int [ ] t ) { int sum = 0 ; int maxsum = 0 ; for ( int i : t ) { sum += i ; if ( sum < 0 ) sum = 0 ; maxsum = sum > maxsum ? sum : maxsum ; } return maxsum ; } 
import java . util . Random ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; Random random = new Random ( ) ; long from = 1 ; long to = 100 ; int randomNumber = random . nextInt ( to - from + 1 ) + from ; int guessedNumber = 0 ; System . out . printf ( "The number is between %d and %d.\n" , from , to ) ; do { System . out . print ( "Guess what the number is: " ) ; guessedNumber = scan . nextInt ( ) ; if ( guessedNumber > randomNumber ) System . out . println ( "Your guess is too high!" ) ; else if ( guessedNumber < randomNumber ) System . out . println ( "Your guess is too low!" ) ; else System . out . println ( "You got it!" ) ; } while ( guessedNumber != randomNumber ) ; } } 
public class Guessing { public static void main ( String [ ] args ) throws NumberFormatException { int n = ( int ) ( Math . random ( ) * 10 + 1 ) ; System . out . print ( "Guess the number between 1 and 10: " ) ; while ( Integer . parseInt ( System . console ( ) . readLine ( ) ) != n ) { System . out . print ( "Wrong! Guess again: " ) ; } System . out . println ( "Well guessed!" ) ; } } 
import java . util . Scanner ; import java . net . URL ; public class Main { public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( new URL ( "http://www.rosettacode.org" ) . openStream ( ) ) ; while ( sc . hasNext ( ) ) System . out . println ( sc . nextLine ( ) ) ; } } 
import org . apache . commons . io . IOUtils ; import java . net . URL ; public class Main { public static void main ( String [ ] args ) throws Exception { IOUtils . copy ( new URL ( "http://rosettacode.org" ) . openStream ( ) , System . out ) ; } } 
import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; class Hailstone { public static List < Long > getHailstoneSequence ( long n ) { if ( n <= 0 ) throw new IllegalArgumentException ( "Invalid starting sequence number" ) ; List < Long > list = new ArrayList < Long > ( ) ; list . add ( Long . valueOf ( n ) ) ; while ( n != 1 ) { if ( ( n & 1 ) == 0 ) n = n / 2 ; else n = 3 * n + 1 ; list . add ( Long . valueOf ( n ) ) ; } return list ; } public static void main ( String [ ] args ) { List < Long > sequence27 = getHailstoneSequence ( 27 ) ; System . out . println ( "Sequence for 27 has " + sequence27 . size ( ) + " elements: " + sequence27 ) ; long MAX = 100000 ; { long highestNumber = 1 ; int highestCount = 1 ; for ( long i = 2 ; i < MAX ; i ++ ) { int count = getHailstoneSequence ( i ) . size ( ) ; if ( count > highestCount ) { highestCount = count ; highestNumber = i ; } } System . out . println ( "Method 1, number " + highestNumber + " has the longest sequence, with a length of " + highestCount ) ; } { long highestNumber = 1 ; int highestCount = 1 ; for ( long i = 2 ; i < MAX ; i ++ ) { int count = 1 ; long n = i ; while ( n != 1 ) { if ( ( n & 1 ) == 0 ) n = n / 2 ; else n = 3 * n + 1 ; count ++ ; } if ( count > highestCount ) { highestCount = count ; highestNumber = i ; } } System . out . println ( "Method 2, number " + highestNumber + " has the longest sequence, with a length of " + highestCount ) ; } { long highestNumber = 1 ; long highestCount = 1 ; Map < Long , Integer > sequenceMap = new HashMap < Long , Integer > ( ) ; sequenceMap . put ( Long . valueOf ( 1 ) , Integer . valueOf ( 1 ) ) ; List < Long > currentList = new ArrayList < Long > ( ) ; for ( long i = 2 ; i < MAX ; i ++ ) { currentList . clear ( ) ; Long n = Long . valueOf ( i ) ; Integer count = null ; while ( ( count = sequenceMap . get ( n ) ) == null ) { currentList . add ( n ) ; long nValue = n . longValue ( ) ; if ( ( nValue & 1 ) == 0 ) n = Long . valueOf ( nValue / 2 ) ; else n = Long . valueOf ( 3 * nValue + 1 ) ; } int curCount = count . intValue ( ) ; for ( int j = currentList . size ( ) - 1 ; j >= 0 ; j -- ) sequenceMap . put ( currentList . get ( j ) , Integer . valueOf ( ++ curCount ) ) ; if ( curCount > highestCount ) { highestCount = curCount ; highestNumber = i ; } } System . out . println ( "Method 3, number " + highestNumber + " has the longest sequence, with a length of " + highestCount ) ; } return ; } } 
import java . util . HashSet ; public class Happy { public static boolean happy ( long number ) { long m = 0 ; int digit = 0 ; HashSet < Long > cycle = new HashSet < Long > ( ) ; while ( number != 1 && cycle . add ( number ) ) { m = 0 ; while ( number > 0 ) { digit = ( int ) ( number % 10 ) ; m += digit * digit ; number /= 10 ; } number = m ; } return number == 1 ; } public static void main ( String [ ] args ) { for ( long num = 1 , count = 0 ; count < 8 ; num ++ ) { if ( happy ( num ) ) { System . out . println ( num ) ; count ++ ; } } } } 
import java . util . HashMap ; public static void main ( String [ ] args ) { String [ ] keys = { "a" , "b" , "c" } ; int [ ] vals = { 1 , 2 , 3 } ; HashMap < String , Integer > hash = new HashMap < String , Integer > ( ) ; for ( int i = 0 ; i < keys . length ; i ++ ) { hash . put ( keys [ i ] , vals [ i ] ) ; } } 
import javax . swing . * ; import java . awt . * ; public class OutputSwing { public static void main ( String [ ] args ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { JOptionPane . showMessageDialog ( null , "Goodbye, World!" ) ; JFrame frame = new JFrame ( "Goodbye, World!" ) ; JTextArea text = new JTextArea ( "Goodbye, World!" ) ; JButton button = new JButton ( "Goodbye, World!" ) ; frame . setLayout ( new FlowLayout ( ) ) ; frame . add ( button ) ; frame . add ( text ) ; frame . pack ( ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . setVisible ( true ) ; } } ) ; } } 
import javax . swing . * ; import java . awt . * ; public class HelloWorld { public static void main ( String [ ] args ) { SwingUtilities . invokeLater ( ( ) -> { JOptionPane . showMessageDialog ( null , "Goodbye, world!" ) ; JFrame frame = new JFrame ( "Goodbye, world!" ) ; JTextArea text = new JTextArea ( "Goodbye, world!" ) ; JButton button = new JButton ( "Goodbye, world!" ) ; frame . setLayout ( new FlowLayout ( ) ) ; frame . add ( button ) ; frame . add ( text ) ; frame . pack ( ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . setVisible ( true ) ; } ) ; } } 
import java . io . FileWriter ; import java . io . IOException ; public class LinePrinter { public static void main ( String [ ] args ) { try { FileWriter lp0 = new FileWriter ( "/dev/lp0" ) ; lp0 . write ( "Hello World!" ) ; lp0 . close ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } } } 
public class Err { public static void main ( String [ ] args ) { System . err . println ( "Goodbye, World!" ) ; } } 
public class HelloWorld { public static void main ( String [ ] args ) { System . out . println ( "Hello world!" ) ; } } 
public class NewClass { public NewClass ( ) { first ( new AnEventOrCallback ( ) { public void call ( ) { second ( ) ; } } ) ; } public void first ( AnEventOrCallback obj ) { obj . call ( ) ; } public void second ( ) { System . out . println ( "Second" ) ; } public static void main ( String [ ] args ) { new NewClass ( ) ; } } interface AnEventOrCallback { public void call ( ) ; } 
public class ListenerTest { public static void main ( String [ ] args ) { JButton testButton = new JButton ( "Test Button" ) ; testButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent ae ) { System . out . println ( "Click Detected by Anon Class" ) ; } } ) ; testButton . addActionListener ( e -> System . out . println ( "Click Detected by Lambda Listner" ) ) ; JFrame frame = new JFrame ( "Listener Test" ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . add ( testButton , BorderLayout . CENTER ) ; frame . pack ( ) ; frame . setVisible ( true ) ; } } 
import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; public class Horner { public static void main ( String [ ] args ) { List < Double > coeffs = new ArrayList < Double > ( ) ; coeffs . add ( - 19.0 ) ; coeffs . add ( 7.0 ) ; coeffs . add ( - 4.0 ) ; coeffs . add ( 6.0 ) ; System . out . println ( polyEval ( coeffs , 3 ) ) ; } public static double polyEval ( List < Double > coefficients , double x ) { Collections . reverse ( coefficients ) ; Double accumulator = coefficients . get ( 0 ) ; for ( int i = 1 ; i < coefficients . size ( ) ; i ++ ) { accumulator = ( accumulator * x ) + ( Double ) coefficients . get ( i ) ; } return accumulator ; } } 
import java . util . * ; abstract class HuffmanTree implements Comparable < HuffmanTree > { public final int frequency ; public HuffmanTree ( int freq ) { frequency = freq ; } public int compareTo ( HuffmanTree tree ) { return frequency - tree . frequency ; } } class HuffmanLeaf extends HuffmanTree { public final char value ; public HuffmanLeaf ( int freq , char val ) { super ( freq ) ; value = val ; } } class HuffmanNode extends HuffmanTree { public final HuffmanTree left , right ; public HuffmanNode ( HuffmanTree l , HuffmanTree r ) { super ( l . frequency + r . frequency ) ; left = l ; right = r ; } } public class HuffmanCode { public static HuffmanTree buildTree ( int [ ] charFreqs ) { PriorityQueue < HuffmanTree > trees = new PriorityQueue < HuffmanTree > ( ) ; for ( int i = 0 ; i < charFreqs . length ; i ++ ) if ( charFreqs [ i ] > 0 ) trees . offer ( new HuffmanLeaf ( charFreqs [ i ] , ( char ) i ) ) ; assert trees . size ( ) > 0 ; while ( trees . size ( ) > 1 ) { HuffmanTree a = trees . poll ( ) ; HuffmanTree b = trees . poll ( ) ; trees . offer ( new HuffmanNode ( a , b ) ) ; } return trees . poll ( ) ; } public static void printCodes ( HuffmanTree tree , StringBuffer prefix ) { assert tree != null ; if ( tree instanceof HuffmanLeaf ) { HuffmanLeaf leaf = ( HuffmanLeaf ) tree ; System . out . println ( leaf . value + "\t" + leaf . frequency + "\t" + prefix ) ; } else if ( tree instanceof HuffmanNode ) { HuffmanNode node = ( HuffmanNode ) tree ; prefix . append ( '0' ) ; printCodes ( node . left , prefix ) ; prefix . deleteCharAt ( prefix . length ( ) - 1 ) ; prefix . append ( '1' ) ; printCodes ( node . right , prefix ) ; prefix . deleteCharAt ( prefix . length ( ) - 1 ) ; } } public static void main ( String [ ] args ) { String test = "this is an example for huffman encoding" ; int [ ] charFreqs = new int [ 256 ] ; for ( char c : test . toCharArray ( ) ) charFreqs [ c ] ++ ; HuffmanTree tree = buildTree ( charFreqs ) ; System . out . println ( "SYMBOL\tWEIGHT\tHUFFMAN CODE" ) ; printCodes ( tree , new StringBuffer ( ) ) ; } } 
import java . math . BigInteger ; import java . util . * ; public class IBAN { private static final String DEFSTRS = "" + "AL28 AD24 AT20 AZ28 BE16 BH22 BA20 BR29 BG22 " + "HR21 CY28 CZ24 DK18 DO28 EE20 FO18 FI18 FR27 GE22 DE22 GI23 " + "GL18 GT28 HU28 IS26 IE22 IL23 IT27 KZ20 KW30 LV21 LB28 LI21 " + "LT20 LU20 MK19 MT31 MR27 MU30 MC27 MD24 ME22 NL18 NO15 PK24 " + "PS29 PL28 PT25 RO24 SM27 SA24 RS22 SK24 SI19 ES24 SE24 CH21 " + "TN24 TR26 AE23 GB22 VG24 GR27 CR21" ; private static final Map < String , Integer > DEFINITIONS = new HashMap < > ( ) ; static { for ( String definition : DEFSTRS . split ( " " ) ) DEFINITIONS . put ( definition . substring ( 0 , 2 ) , Integer . parseInt ( definition . substring ( 2 ) ) ) ; } public static void main ( String [ ] args ) { String [ ] ibans = { "GB82 WEST 1234 5698 7654 32" , "GB82 TEST 1234 5698 7654 32" , "GB81 WEST 1234 5698 7654 32" , "SA03 8000 0000 6080 1016 7519" , "CH93 0076 2011 6238 5295 7" , "XX00 0000" , "" , "DE" , "DE13 _ 1234 1234 1234 12" } ; for ( String iban : ibans ) System . out . printf ( "%s is %s.%n" , iban , validateIBAN ( iban ) ? "valid" : "not valid" ) ; } static boolean validateIBAN ( String iban ) { iban = iban . replaceAll ( "\\s" , "" ) . toUpperCase ( Locale . ROOT ) ; int len = iban . length ( ) ; if ( len < 4 || ! iban . matches ( "[0-9A-Z]+" ) || DEFINITIONS . getOrDefault ( iban . substring ( 0 , 2 ) , 0 ) != len ) return false ; iban = iban . substring ( 4 ) + iban . substring ( 0 , 4 ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < len ; i ++ ) sb . append ( Character . digit ( iban . charAt ( i ) , 36 ) ) ; BigInteger bigInt = new BigInteger ( sb . toString ( ) ) ; return bigInt . mod ( BigInteger . valueOf ( 97 ) ) . intValue ( ) == 1 ; } } 
public class PrintIdentityMatrix { public static void main ( String [ ] args ) { int n = 5 ; int [ ] [ ] array = new int [ n ] [ n ] ; IntStream . range ( 0 , n ) . forEach ( i -> array [ i ] [ i ] = 1 ) ; Arrays . stream ( array ) . map ( ( int [ ] a ) -> Arrays . toString ( a ) ) . forEach ( System . out :: println ) ; } } 
String s = "12345" ; s = String . valueOf ( Integer . parseInt ( s ) + 1 ) ; 
String s = "123456789012345678901234567890.12345" ; s = new BigDecimal ( s ) . add ( BigDecimal . ONE ) . toString ( ) ; 
double infinity = Double . POSITIVE_INFINITY ; Double . isInfinite ( infinity ) ; 
public static double getInf ( ) { return Double . POSITIVE_INFINITY ; } 
double biggestNumber = Double . MAX_VALUE ; 
public class Animal { } 
public class Dog extends Animal { } 
public class Cat extends Animal { } 
public class Lab extends Dog { } 
public class Collie extends Dog { } 
import java . util . Scanner ; ... Scanner in = new Scanner ( System . in ) ; while ( in . hasNext ( ) ) { String input = in . next ( ) ; } 
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; ... try { BufferedReader inp = new BufferedReader ( new InputStreamReader ( System . in ) ) ; while ( inp . ready ( ) ) { String input = inp . readLine ( ) ; } } catch ( IOException e ) { } 
import java . io . * ; public class compInt { public static void main ( String [ ] args ) { try { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int nbr1 = Integer . parseInt ( in . readLine ( ) ) ; int nbr2 = Integer . parseInt ( in . readLine ( ) ) ; if ( nbr1 < nbr2 ) System . out . println ( nbr1 + " is less than " + nbr2 ) ; if ( nbr1 > nbr2 ) System . out . println ( nbr1 + " is greater than " + nbr2 ) ; if ( nbr1 == nbr2 ) System . out . println ( nbr1 + " is equal to " + nbr2 ) ; } catch ( IOException e ) { } } } 
import com . google . gson . Gson ; public class JsonExample { public static void main ( String [ ] args ) { Gson gson = new Gson ( ) ; String json = "{ \"foo\": 1, \"bar\": [ \"10\", \"apples\"] }" ; MyJsonObject obj = gson . fromJson ( json , MyJsonObject . class ) ; System . out . println ( obj . getFoo ( ) ) ; for ( String bar : obj . getBar ( ) ) { System . out . println ( bar ) ; } obj = new MyJsonObject ( 2 , new String [ ] { "20" , "oranges" } ) ; json = gson . toJson ( obj ) ; System . out . println ( json ) ; } } class MyJsonObject { private int foo ; private String [ ] bar ; public MyJsonObject ( int foo , String [ ] bar ) { this . foo = foo ; this . bar = bar ; } public int getFoo ( ) { return foo ; } public String [ ] getBar ( ) { return bar ; } } 
import java . util . function . * ; import java . util . stream . * ; public class Jensen { static double sum ( int lo , int hi , IntToDoubleFunction f ) { return IntStream . rangeClosed ( lo , hi ) . mapToDouble ( f ) . sum ( ) ; } public static void main ( String args [ ] ) { System . out . println ( sum ( 1 , 100 , ( i -> 1.0 / i ) ) ) ; } } 
public class Jensen2 { interface IntToDoubleFunction { double apply ( int n ) ; } static double sum ( int lo , int hi , IntToDoubleFunction f ) { double res = 0 ; for ( int i = lo ; i <= hi ; i ++ ) res += f . apply ( i ) ; return res ; } public static void main ( String args [ ] ) { System . out . println ( sum ( 1 , 100 , new IntToDoubleFunction ( ) { public double apply ( int i ) { return 1.0 / i ; } } ) ) ; } } 
import java . util . ArrayList ; public class Josephus { public static int execute ( int n , int k ) { int killIdx = 0 ; ArrayList < Integer > prisoners = new ArrayList < Integer > ( n ) ; for ( int i = 0 ; i < n ; i ++ ) { prisoners . add ( i ) ; } System . out . println ( "Prisoners executed in order:" ) ; while ( prisoners . size ( ) > 1 ) { killIdx = ( killIdx + k - 1 ) % prisoners . size ( ) ; System . out . print ( prisoners . get ( killIdx ) + " " ) ; prisoners . remove ( killIdx ) ; } System . out . println ( ) ; return prisoners . get ( 0 ) ; } public static ArrayList < Integer > executeAllButM ( int n , int k , int m ) { int killIdx = 0 ; ArrayList < Integer > prisoners = new ArrayList < Integer > ( n ) ; for ( int i = 0 ; i < n ; i ++ ) { prisoners . add ( i ) ; } System . out . println ( "Prisoners executed in order:" ) ; while ( prisoners . size ( ) > m ) { killIdx = ( killIdx + k - 1 ) % prisoners . size ( ) ; System . out . print ( prisoners . get ( killIdx ) + " " ) ; prisoners . remove ( killIdx ) ; } System . out . println ( ) ; return prisoners ; } public static void main ( String [ ] args ) { System . out . println ( "Survivor: " + execute ( 41 , 3 ) ) ; System . out . println ( "Survivors: " + executeAllButM ( 41 , 3 , 3 ) ) ; } } 
import java . util . ArrayList ; import java . util . List ; public class Josephus { public static void main ( String [ ] args ) { execute ( 5 , 1 ) ; execute ( 41 , 2 ) ; execute ( 23482 , 3342 , 3 ) ; } public static int [ ] [ ] execute ( int n , int k ) { return execute ( n , k , 1 ) ; } public static int [ ] [ ] execute ( int n , int k , int s ) { List < Integer > ps = new ArrayList < Integer > ( n ) ; for ( int i = 0 ; i < n ; i += 1 ) ps . add ( i ) ; List < Integer > ks = new ArrayList < Integer > ( n - s ) ; for ( int i = k ; ps . size ( ) > s ; i = ( i + k ) % ps . size ( ) ) ks . add ( ps . remove ( i ) ) ; System . out . printf ( "Josephus(%d,%d,%d) -> %s / %s\n" , n , k , s , toString ( ps ) , toString ( ks ) ) ; return new int [ ] [ ] { ps . stream ( ) . mapToInt ( Integer :: intValue ) . toArray ( ) , ks . stream ( ) . mapToInt ( Integer :: intValue ) . toArray ( ) } ; } private static String toString ( List < Integer > ls ) { String dot = "" ; if ( ls . size ( ) >= 45 ) { dot = ", ..." ; ls = ls . subList ( 0 , 45 ) ; } String s = ls . toString ( ) ; return s . substring ( 1 , s . length ( ) - 1 ) + dot ; } } 
public class Kaprekar { private static String [ ] splitAt ( String str , int idx ) { String [ ] ans = new String [ 2 ] ; ans [ 0 ] = str . substring ( 0 , idx ) ; if ( ans [ 0 ] . equals ( "" ) ) ans [ 0 ] = "0" ; ans [ 1 ] = str . substring ( idx ) ; return ans ; } public static void main ( String [ ] args ) { int count = 0 ; int base = ( args . length > 0 ) ? Integer . parseInt ( args [ 0 ] ) : 10 ; for ( long i = 1 ; i <= 1000000 ; i ++ ) { String sqrStr = Long . toString ( i * i , base ) ; for ( int j = 0 ; j < sqrStr . length ( ) / 2 + 1 ; j ++ ) { String [ ] parts = splitAt ( sqrStr , j ) ; long firstNum = Long . parseLong ( parts [ 0 ] , base ) ; long secNum = Long . parseLong ( parts [ 1 ] , base ) ; if ( secNum == 0 ) break ; if ( firstNum + secNum == i ) { System . out . println ( i + "\t" + Long . toString ( i , base ) + "\t" + sqrStr + "\t" + parts [ 0 ] + " + " + parts [ 1 ] ) ; count ++ ; break ; } } } System . out . println ( count + " Kaprekar numbers < 1000000 (base 10) in base " + base ) ; } } 
package hu . pj . alg . test ; import hu . pj . alg . ZeroOneKnapsack ; import hu . pj . obj . Item ; import java . util . * ; import java . text . * ; public class ZeroOneKnapsackForTourists { public ZeroOneKnapsackForTourists ( ) { ZeroOneKnapsack zok = new ZeroOneKnapsack ( 400 ) ; zok . add ( "map" , 9 , 150 ) ; zok . add ( "compass" , 13 , 35 ) ; zok . add ( "water" , 153 , 200 ) ; zok . add ( "sandwich" , 50 , 160 ) ; zok . add ( "glucose" , 15 , 60 ) ; zok . add ( "tin" , 68 , 45 ) ; zok . add ( "banana" , 27 , 60 ) ; zok . add ( "apple" , 39 , 40 ) ; zok . add ( "cheese" , 23 , 30 ) ; zok . add ( "beer" , 52 , 10 ) ; zok . add ( "suntan cream" , 11 , 70 ) ; zok . add ( "camera" , 32 , 30 ) ; zok . add ( "t-shirt" , 24 , 15 ) ; zok . add ( "trousers" , 48 , 10 ) ; zok . add ( "umbrella" , 73 , 40 ) ; zok . add ( "waterproof trousers" , 42 , 70 ) ; zok . add ( "waterproof overclothes" , 43 , 75 ) ; zok . add ( "note-case" , 22 , 80 ) ; zok . add ( "sunglasses" , 7 , 20 ) ; zok . add ( "towel" , 18 , 12 ) ; zok . add ( "socks" , 4 , 50 ) ; zok . add ( "book" , 30 , 10 ) ; List < Item > itemList = zok . calcSolution ( ) ; if ( zok . isCalculated ( ) ) { NumberFormat nf = NumberFormat . getInstance ( ) ; System . out . println ( "Maximal weight           = " + nf . format ( zok . getMaxWeight ( ) / 100.0 ) + " kg" ) ; System . out . println ( "Total weight of solution = " + nf . format ( zok . getSolutionWeight ( ) / 100.0 ) + " kg" ) ; System . out . println ( "Total value              = " + zok . getProfit ( ) ) ; System . out . println ( ) ; System . out . println ( "You can carry the following materials " + "in the knapsack:" ) ; for ( Item item : itemList ) { if ( item . getInKnapsack ( ) == 1 ) { System . out . format ( "%1$-23s %2$-3s %3$-5s %4$-15s \n" , item . getName ( ) , item . getWeight ( ) , "dag  " , "(value = " + item . getValue ( ) + ")" ) ; } } } else { System . out . println ( "The problem is not solved. " + "Maybe you gave wrong data." ) ; } } public static void main ( String [ ] args ) { new ZeroOneKnapsackForTourists ( ) ; } } 
package hu . pj . alg ; import hu . pj . obj . Item ; import java . util . * ; public class ZeroOneKnapsack { protected List < Item > itemList = new ArrayList < Item > ( ) ; protected int maxWeight = 0 ; protected int solutionWeight = 0 ; protected int profit = 0 ; protected boolean calculated = false ; public ZeroOneKnapsack ( ) { } public ZeroOneKnapsack ( int _maxWeight ) { setMaxWeight ( _maxWeight ) ; } public ZeroOneKnapsack ( List < Item > _itemList ) { setItemList ( _itemList ) ; } public ZeroOneKnapsack ( List < Item > _itemList , int _maxWeight ) { setItemList ( _itemList ) ; setMaxWeight ( _maxWeight ) ; } public List < Item > calcSolution ( ) { int n = itemList . size ( ) ; setInitialStateForCalculation ( ) ; if ( n > 0 && maxWeight > 0 ) { List < List < Integer > > c = new ArrayList < List < Integer > > ( ) ; List < Integer > curr = new ArrayList < Integer > ( ) ; c . add ( curr ) ; for ( int j = 0 ; j <= maxWeight ; j ++ ) curr . add ( 0 ) ; for ( int i = 1 ; i <= n ; i ++ ) { List < Integer > prev = curr ; c . add ( curr = new ArrayList < Integer > ( ) ) ; for ( int j = 0 ; j <= maxWeight ; j ++ ) { if ( j > 0 ) { int wH = itemList . get ( i - 1 ) . getWeight ( ) ; curr . add ( ( wH > j ) ? prev . get ( j ) : Math . max ( prev . get ( j ) , itemList . get ( i - 1 ) . getValue ( ) + prev . get ( j - wH ) ) ) ; } else { curr . add ( 0 ) ; } } } profit = curr . get ( maxWeight ) ; for ( int i = n , j = maxWeight ; i > 0 && j >= 0 ; i -- ) { int tempI = c . get ( i ) . get ( j ) ; int tempI_1 = c . get ( i - 1 ) . get ( j ) ; if ( ( i == 0 && tempI > 0 ) || ( i > 0 && tempI != tempI_1 ) ) { Item iH = itemList . get ( i - 1 ) ; int wH = iH . getWeight ( ) ; iH . setInKnapsack ( 1 ) ; j -= wH ; solutionWeight += wH ; } } calculated = true ; } return itemList ; } public void add ( String name , int weight , int value ) { if ( name . equals ( "" ) ) name = "" + ( itemList . size ( ) + 1 ) ; itemList . add ( new Item ( name , weight , value ) ) ; setInitialStateForCalculation ( ) ; } public void add ( int weight , int value ) { add ( "" , weight , value ) ; } public void remove ( String name ) { for ( Iterator < Item > it = itemList . iterator ( ) ; it . hasNext ( ) ; ) { if ( name . equals ( it . next ( ) . getName ( ) ) ) { it . remove ( ) ; } } setInitialStateForCalculation ( ) ; } public void removeAllItems ( ) { itemList . clear ( ) ; setInitialStateForCalculation ( ) ; } public int getProfit ( ) { if ( ! calculated ) calcSolution ( ) ; return profit ; } public int getSolutionWeight ( ) { return solutionWeight ; } public boolean isCalculated ( ) { return calculated ; } public int getMaxWeight ( ) { return maxWeight ; } public void setMaxWeight ( int _maxWeight ) { maxWeight = Math . max ( _maxWeight , 0 ) ; } public void setItemList ( List < Item > _itemList ) { if ( _itemList != null ) { itemList = _itemList ; for ( Item item : _itemList ) { item . checkMembers ( ) ; } } } private void setInKnapsackByAll ( int inKnapsack ) { for ( Item item : itemList ) if ( inKnapsack > 0 ) item . setInKnapsack ( 1 ) ; else item . setInKnapsack ( 0 ) ; } protected void setInitialStateForCalculation ( ) { setInKnapsackByAll ( 0 ) ; calculated = false ; profit = 0 ; solutionWeight = 0 ; } } 
package hu . pj . obj ; public class Item { protected String name = "" ; protected int weight = 0 ; protected int value = 0 ; protected int bounding = 1 ; protected int inKnapsack = 0 ; public Item ( ) { } public Item ( Item item ) { setName ( item . name ) ; setWeight ( item . weight ) ; setValue ( item . value ) ; setBounding ( item . bounding ) ; } public Item ( int _weight , int _value ) { setWeight ( _weight ) ; setValue ( _value ) ; } public Item ( int _weight , int _value , int _bounding ) { setWeight ( _weight ) ; setValue ( _value ) ; setBounding ( _bounding ) ; } public Item ( String _name , int _weight , int _value ) { setName ( _name ) ; setWeight ( _weight ) ; setValue ( _value ) ; } public Item ( String _name , int _weight , int _value , int _bounding ) { setName ( _name ) ; setWeight ( _weight ) ; setValue ( _value ) ; setBounding ( _bounding ) ; } public void setName ( String _name ) { name = _name ; } public void setWeight ( int _weight ) { weight = Math . max ( _weight , 0 ) ; } public void setValue ( int _value ) { value = Math . max ( _value , 0 ) ; } public void setInKnapsack ( int _inKnapsack ) { inKnapsack = Math . min ( getBounding ( ) , Math . max ( _inKnapsack , 0 ) ) ; } public void setBounding ( int _bounding ) { bounding = Math . max ( _bounding , 0 ) ; if ( bounding == 0 ) inKnapsack = 0 ; } public void checkMembers ( ) { setWeight ( weight ) ; setValue ( value ) ; setBounding ( bounding ) ; setInKnapsack ( inKnapsack ) ; } public String getName ( ) { return name ; } public int getWeight ( ) { return weight ; } public int getValue ( ) { return value ; } public int getInKnapsack ( ) { return inKnapsack ; } public int getBounding ( ) { return bounding ; } } 
import java . util . Random ; public static final Random gen = new Random ( ) ; public static void shuffle ( int [ ] array ) { int n = array . length ; while ( n > 1 ) { int k = gen . nextInt ( n -- ) ; int temp = array [ n ] ; array [ n ] = array [ k ] ; array [ k ] = temp ; } } public static void shuffle ( Object [ ] array ) { int n = array . length ; while ( n > 1 ) { int k = gen . nextInt ( n -- ) ; Object temp = array [ n ] ; array [ n ] = array [ k ] ; array [ k ] = temp ; } } 
import java . util . * ; public class LZW { public static List < Integer > compress ( String uncompressed ) { int dictSize = 256 ; Map < String , Integer > dictionary = new HashMap < String , Integer > ( ) ; for ( int i = 0 ; i < 256 ; i ++ ) dictionary . put ( "" + ( char ) i , i ) ; String w = "" ; List < Integer > result = new ArrayList < Integer > ( ) ; for ( char c : uncompressed . toCharArray ( ) ) { String wc = w + c ; if ( dictionary . containsKey ( wc ) ) w = wc ; else { result . add ( dictionary . get ( w ) ) ; dictionary . put ( wc , dictSize ++ ) ; w = "" + c ; } } if ( ! w . equals ( "" ) ) result . add ( dictionary . get ( w ) ) ; return result ; } public static String decompress ( List < Integer > compressed ) { int dictSize = 256 ; Map < Integer , String > dictionary = new HashMap < Integer , String > ( ) ; for ( int i = 0 ; i < 256 ; i ++ ) dictionary . put ( i , "" + ( char ) i ) ; String w = "" + ( char ) ( int ) compressed . remove ( 0 ) ; StringBuffer result = new StringBuffer ( w ) ; for ( int k : compressed ) { String entry ; if ( dictionary . containsKey ( k ) ) entry = dictionary . get ( k ) ; else if ( k == dictSize ) entry = w + w . charAt ( 0 ) ; else throw new IllegalArgumentException ( "Bad compressed k: " + k ) ; result . append ( entry ) ; dictionary . put ( dictSize ++ , w + entry . charAt ( 0 ) ) ; w = entry ; } return result . toString ( ) ; } public static void main ( String [ ] args ) { List < Integer > compressed = compress ( "TOBEORNOTTOBEORTOBEORNOT" ) ; System . out . println ( compressed ) ; String decompressed = decompress ( compressed ) ; System . out . println ( decompressed ) ; } } 
[ 84 , 79 , 66 , 69 , 79 , 82 , 78 , 79 , 84 , 256 , 258 , 260 , 265 , 259 , 261 , 263 ] TOBEORNOTTOBEORTOBEORNOT 
import java . awt . Color ; import java . awt . Graphics ; import javax . swing . JFrame ; import javax . swing . JPanel ; public class Langton extends JFrame { private JPanel planePanel ; private static final int ZOOM = 4 ; public Langton ( final boolean [ ] [ ] plane ) { planePanel = new JPanel ( ) { @ Override public void paint ( Graphics g ) { for ( int y = 0 ; y < plane . length ; y ++ ) { for ( int x = 0 ; x < plane [ 0 ] . length ; x ++ ) { g . setColor ( plane [ y ] [ x ] ? Color . BLACK : Color . WHITE ) ; g . fillRect ( x * ZOOM , y * ZOOM , ZOOM , ZOOM ) ; } } g . setColor ( Color . GREEN ) ; g . fillRect ( plane [ 0 ] . length / 2 * ZOOM , plane . length / 2 * ZOOM , ZOOM / 2 , ZOOM / 2 ) ; } } ; planePanel . setSize ( plane [ 0 ] . length - 1 , plane . length - 1 ) ; add ( planePanel ) ; setSize ( ZOOM * plane [ 0 ] . length , ZOOM * plane . length + 30 ) ; setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; setVisible ( true ) ; } public static void main ( String [ ] args ) { new Langton ( runAnt ( 100 , 100 ) ) ; } private static boolean [ ] [ ] runAnt ( int height , int width ) { boolean [ ] [ ] plane = new boolean [ height ] [ width ] ; int antX = width / 2 , antY = height / 2 ; int xChange = 0 , yChange = - 1 ; while ( antX < width && antY < height && antX >= 0 && antY >= 0 ) { if ( plane [ antY ] [ antX ] ) { if ( xChange == 0 ) { xChange = yChange ; yChange = 0 ; } else { yChange = - xChange ; xChange = 0 ; } } else { if ( xChange == 0 ) { xChange = - yChange ; yChange = 0 ; } else { yChange = xChange ; xChange = 0 ; } } plane [ antY ] [ antX ] = ! plane [ antY ] [ antX ] ; antX += xChange ; antY += yChange ; } return plane ; } } 
import java . util . * ; public class IntConcat { private static Comparator < Integer > sorter = new Comparator < Integer > ( ) { @ Override public int compare ( Integer o1 , Integer o2 ) { String o1s = o1 . toString ( ) ; String o2s = o2 . toString ( ) ; if ( o1s . length ( ) == o2s . length ( ) ) { return o2s . compareTo ( o1s ) ; } int mlen = Math . max ( o1s . length ( ) , o2s . length ( ) ) ; while ( o1s . length ( ) < mlen * 2 ) o1s += o1s ; while ( o2s . length ( ) < mlen * 2 ) o2s += o2s ; return o2s . compareTo ( o1s ) ; } } ; public static String join ( List < ? > things ) { String output = "" ; for ( Object obj : things ) { output += obj ; } return output ; } public static void main ( String [ ] args ) { List < Integer > ints1 = new ArrayList < Integer > ( Arrays . asList ( 1 , 34 , 3 , 98 , 9 , 76 , 45 , 4 ) ) ; Collections . sort ( ints1 , sorter ) ; System . out . println ( join ( ints1 ) ) ; List < Integer > ints2 = new ArrayList < Integer > ( Arrays . asList ( 54 , 546 , 548 , 60 ) ) ; Collections . sort ( ints2 , sorter ) ; System . out . println ( join ( ints2 ) ) ; } } 
import java . util . Comparator ; import java . util . stream . Collectors ; import java . util . stream . Stream ; public interface IntConcat { public static Comparator < Integer > SORTER = ( o1 , o2 ) -> { String o1s = o1 . toString ( ) ; String o2s = o2 . toString ( ) ; if ( o1s . length ( ) == o2s . length ( ) ) { return o2s . compareTo ( o1s ) ; } int mlen = Math . max ( o1s . length ( ) , o2s . length ( ) ) ; while ( o1s . length ( ) < mlen * 2 ) { o1s += o1s ; } while ( o2s . length ( ) < mlen * 2 ) { o2s += o2s ; } return o2s . compareTo ( o1s ) ; } ; public static void main ( String [ ] args ) { Stream < Integer > ints1 = Stream . of ( 1 , 34 , 3 , 98 , 9 , 76 , 45 , 4 ) ; System . out . println ( ints1 . parallel ( ) . sorted ( SORTER ) . map ( String :: valueOf ) . collect ( Collectors . joining ( ) ) ) ; Stream < Integer > ints2 = Stream . of ( 54 , 546 , 548 , 60 ) ; System . out . println ( ints2 . parallel ( ) . sorted ( SORTER ) . map ( String :: valueOf ) . collect ( Collectors . joining ( ) ) ) ; } } 
import java . util . GregorianCalendar ; import java . text . MessageFormat ; public class Leapyear { public static void main ( String [ ] argv ) { int [ ] yrs = { 1800 , 1900 , 1994 , 1998 , 1999 , 2000 , 2001 , 2004 , 2100 } ; GregorianCalendar cal = new GregorianCalendar ( ) ; for ( int year : yrs ) { System . err . println ( MessageFormat . format ( "The year {0,number,#} is leaper: {1} / {2}." , year , cal . isLeapYear ( year ) , isLeapYear ( year ) ) ) ; } } public static boolean isLeapYear ( int year ) { return ( year % 100 == 0 ) ? ( year % 400 == 0 ) : ( year % 4 == 0 ) ; } } 
import java . util . Scanner ; public class LCM { public static void main ( String [ ] args ) { Scanner aScanner = new Scanner ( System . in ) ; System . out . print ( "Enter the value of m:" ) ; int m = aScanner . nextInt ( ) ; System . out . print ( "Enter the value of n:" ) ; int n = aScanner . nextInt ( ) ; int lcm = ( n == m || n == 1 ) ? m : ( m == 1 ? n : 0 ) ; if ( lcm == 0 ) { int mm = m , nn = n ; while ( mm != nn ) { while ( mm < nn ) { mm += m ; } while ( nn < mm ) { nn += n ; } } lcm = mm ; } System . out . println ( "lcm(" + m + ", " + n + ") = " + lcm ) ; } } 
import java . io . BufferedReader ; import java . io . FileReader ; import java . io . IOException ; import java . util . Arrays ; public class LetterFreq { public static int [ ] countLetters ( String filename ) throws IOException { int [ ] freqs = new int [ 26 ] ; BufferedReader in = new BufferedReader ( new FileReader ( filename ) ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) { line = line . toUpperCase ( ) ; for ( char ch : line . toCharArray ( ) ) { if ( Character . isLetter ( ch ) ) { freqs [ ch - 'A' ] ++ ; } } } in . close ( ) ; return freqs ; } public static void main ( String [ ] args ) throws IOException { System . out . println ( Arrays . toString ( countLetters ( "filename.txt" ) ) ) ; } } 
public static int [ ] countLetters ( String filename ) throws IOException { int [ ] freqs = new int [ 26 ] ; try ( BufferedReader in = new BufferedReader ( new FileReader ( filename ) ) ) { String line ; while ( ( line = in . readLine ( ) ) != null ) { line = line . toUpperCase ( ) ; for ( char ch : line . toCharArray ( ) ) { if ( Character . isLetter ( ch ) ) { freqs [ ch - 'A' ] ++ ; } } } } return freqs ; } 
public static Map < Integer , Long > countLetters ( String filename ) throws IOException { return Files . lines ( Paths . get ( filename ) ) . flatMapToInt ( String :: chars ) . filter ( Character :: isLetter ) . boxed ( ) . collect ( Collectors . groupingBy ( Function . identity ( ) , Collectors . counting ( ) ) ) ; } 
public class Levenshtein { public static int distance ( String a , String b ) { a = a . toLowerCase ( ) ; b = b . toLowerCase ( ) ; int [ ] costs = new int [ b . length ( ) + 1 ] ; for ( int j = 0 ; j < costs . length ; j ++ ) costs [ j ] = j ; for ( int i = 1 ; i <= a . length ( ) ; i ++ ) { costs [ 0 ] = i ; int nw = i - 1 ; for ( int j = 1 ; j <= b . length ( ) ; j ++ ) { int cj = Math . min ( 1 + Math . min ( costs [ j ] , costs [ j - 1 ] ) , a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ? nw : nw + 1 ) ; nw = costs [ j ] ; costs [ j ] = cj ; } } return costs [ b . length ( ) ] ; } public static void main ( String [ ] args ) { String [ ] data = { "kitten" , "sitting" , "saturday" , "sunday" , "rosettacode" , "raisethysword" } ; for ( int i = 0 ; i < data . length ; i += 2 ) System . out . println ( "distance(" + data [ i ] + ", " + data [ i + 1 ] + ") = " + distance ( data [ i ] , data [ i + 1 ] ) ) ; } } 
public class Levenshtein { public static int levenshtein ( String s , String t ) { if ( s . length ( ) == 0 ) return t . length ( ) ; if ( t . length ( ) == 0 ) return s . length ( ) ; if ( s . charAt ( 0 ) == t . charAt ( 0 ) ) return levenshtein ( s . substring ( 1 ) , t . substring ( 1 ) ) ; int a = levenshtein ( s . substring ( 1 ) , t . substring ( 1 ) ) ; int b = levenshtein ( s , t . substring ( 1 ) ) ; int c = levenshtein ( s . substring ( 1 ) , t ) ; if ( a > b ) a = b ; if ( a > c ) a = c ; return a + 1 ; } public static void main ( String [ ] args ) { String s1 = "kitten" ; String s2 = "sitting" ; System . out . println ( "distance between '" + s1 + "' and '" + s2 + "': " + levenshtein ( s1 , s2 ) ) ; s1 = "rosettacode" ; s2 = "raisethysword" ; System . out . println ( "distance between '" + s1 + "' and '" + s2 + "': " + levenshtein ( s1 , s2 ) ) ; StringBuilder sb1 = new StringBuilder ( s1 ) ; StringBuilder sb2 = new StringBuilder ( s2 ) ; System . out . println ( "distance between '" + sb1 . reverse ( ) + "' and '" + sb2 . reverse ( ) + "': " + levenshtein ( sb1 . reverse ( ) . toString ( ) , sb2 . reverse ( ) . toString ( ) ) ) ; } } 
public class IntegerLiterals { public static void main ( String [ ] args ) { System . out . println ( 727 == 0x2d7 && 727 == 01327 ) ; } } 
public class BinaryLiteral { public static void main ( String [ ] args ) { System . out . println ( 727 == 0b10_1101_0111 ) ; } } 
char a = 'a' ; String b = "abc" ; char doubleQuote = '"' ; char singleQuote = '\'' ; String singleQuotes = "''" ; String doubleQuotes = "\"\"" ; 
public static void logic ( boolean a , boolean b ) { System . out . println ( "a AND b: " + ( a && b ) ) ; System . out . println ( "a OR b: " + ( a || b ) ) ; System . out . println ( "NOT a: " + ( ! a ) ) ; } 
public class LongMult { private static byte [ ] stringToDigits ( String num ) { byte [ ] result = new byte [ num . length ( ) ] ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) { char c = num . charAt ( i ) ; if ( c < '0' || c > '9' ) { throw new IllegalArgumentException ( "Invalid digit " + c + " found at position " + i ) ; } result [ num . length ( ) - 1 - i ] = ( byte ) ( c - '0' ) ; } return result ; } public static String longMult ( String num1 , String num2 ) { byte [ ] left = stringToDigits ( num1 ) ; byte [ ] right = stringToDigits ( num2 ) ; byte [ ] result = new byte [ left . length + right . length ] ; for ( int rightPos = 0 ; rightPos < right . length ; rightPos ++ ) { byte rightDigit = right [ rightPos ] ; byte temp = 0 ; for ( int leftPos = 0 ; leftPos < left . length ; leftPos ++ ) { temp += result [ leftPos + rightPos ] ; temp += rightDigit * left [ leftPos ] ; result [ leftPos + rightPos ] = ( byte ) ( temp % 10 ) ; temp /= 10 ; } int destPos = rightPos + left . length ; while ( temp != 0 ) { temp += result [ destPos ] & 0xFFFFFFFFL ; result [ destPos ] = ( byte ) ( temp % 10 ) ; temp /= 10 ; destPos ++ ; } } StringBuilder stringResultBuilder = new StringBuilder ( result . length ) ; for ( int i = result . length - 1 ; i >= 0 ; i -- ) { byte digit = result [ i ] ; if ( digit != 0 || stringResultBuilder . length ( ) > 0 ) { stringResultBuilder . append ( ( char ) ( digit + '0' ) ) ; } } return stringResultBuilder . toString ( ) ; } public static void main ( String [ ] args ) { System . out . println ( longMult ( "18446744073709551616" , "18446744073709551616" ) ) ; } } 
import java . util . Arrays ; public class LongMultBinary { public static class MyLongNum implements Cloneable { private int [ ] digits ; private int digitsUsed ; @ Override public MyLongNum clone ( ) { try { MyLongNum clone = ( MyLongNum ) super . clone ( ) ; clone . digits = clone . digits . clone ( ) ; return clone ; } catch ( CloneNotSupportedException e ) { throw new Error ( "Object.clone() threw exception" , e ) ; } } private void resize ( int newLength ) { if ( digits . length < newLength ) { digits = Arrays . copyOf ( digits , newLength ) ; } } private void adjustDigitsUsed ( ) { while ( digitsUsed > 0 && digits [ digitsUsed - 1 ] == 0 ) { digitsUsed -- ; } } public void multiply ( int multiplier ) { if ( multiplier < 0 ) { throw new IllegalArgumentException ( "Signed arithmetic isn't supported" ) ; } resize ( digitsUsed + 1 ) ; long temp = 0 ; for ( int i = 0 ; i < digitsUsed ; i ++ ) { temp += ( digits [ i ] & 0xFFFFFFFFL ) * multiplier ; digits [ i ] = ( int ) temp ; temp >>>= 32 ; } digits [ digitsUsed ] = ( int ) temp ; digitsUsed ++ ; adjustDigitsUsed ( ) ; } public void add ( int addend ) { if ( addend < 0 ) { throw new IllegalArgumentException ( "Signed arithmetic isn't supported" ) ; } long temp = addend ; for ( int i = 0 ; i < digitsUsed && temp != 0 ; i ++ ) { temp += ( digits [ i ] & 0xFFFFFFFFL ) ; digits [ i ] = ( int ) temp ; temp >>>= 32 ; } if ( temp != 0 ) { resize ( digitsUsed + 1 ) ; digits [ digitsUsed ] = ( int ) temp ; digitsUsed ++ ; } } public int divide ( int divisor ) { if ( divisor < 0 ) { throw new IllegalArgumentException ( "Signed arithmetic isn't supported" ) ; } int remainder = 0 ; for ( int i = digitsUsed - 1 ; i >= 0 ; i -- ) { long twoDigits = ( ( ( long ) remainder << 32 ) | ( digits [ i ] & 0xFFFFFFFFL ) ) ; remainder = ( int ) ( twoDigits % divisor ) ; digits [ i ] = ( int ) ( twoDigits / divisor ) ; } adjustDigitsUsed ( ) ; return remainder ; } public MyLongNum ( String value ) { this . digits = new int [ value . length ( ) / 9 + 1 ] ; this . digitsUsed = 0 ; for ( int i = 0 ; i < value . length ( ) ; i += 9 ) { String chunk = value . substring ( i , Math . min ( i + 9 , value . length ( ) ) ) ; int multiplier = 1 ; int addend = 0 ; for ( int j = 0 ; j < chunk . length ( ) ; j ++ ) { char c = chunk . charAt ( j ) ; if ( c < '0' || c > '9' ) { throw new IllegalArgumentException ( "Invalid digit " + c + " found in input" ) ; } multiplier *= 10 ; addend *= 10 ; addend += c - '0' ; } multiply ( multiplier ) ; add ( addend ) ; } } @ Override public String toString ( ) { if ( digitsUsed == 0 ) { return "0" ; } MyLongNum dummy = this . clone ( ) ; StringBuilder resultBuilder = new StringBuilder ( digitsUsed * 9 ) ; while ( dummy . digitsUsed > 0 ) { int decimalDigits = dummy . divide ( 1000000000 ) ; for ( int i = 0 ; i < 9 ; i ++ ) { resultBuilder . append ( ( char ) ( decimalDigits % 10 + '0' ) ) ; decimalDigits /= 10 ; } } while ( resultBuilder . charAt ( resultBuilder . length ( ) - 1 ) == '0' ) { resultBuilder . deleteCharAt ( resultBuilder . length ( ) - 1 ) ; } return resultBuilder . reverse ( ) . toString ( ) ; } public void multiply ( MyLongNum multiplier ) { MyLongNum left , right ; if ( this . digitsUsed > multiplier . digitsUsed ) { left = this ; right = multiplier ; } else { left = multiplier ; right = this ; } int [ ] newDigits = new int [ left . digitsUsed + right . digitsUsed ] ; for ( int rightPos = 0 ; rightPos < right . digitsUsed ; rightPos ++ ) { long rightDigit = right . digits [ rightPos ] & 0xFFFFFFFFL ; long temp = 0 ; for ( int leftPos = 0 ; leftPos < left . digitsUsed ; leftPos ++ ) { temp += ( newDigits [ leftPos + rightPos ] & 0xFFFFFFFFL ) ; temp += rightDigit * ( left . digits [ leftPos ] & 0xFFFFFFFFL ) ; newDigits [ leftPos + rightPos ] = ( int ) temp ; temp >>>= 32 ; } int destPos = rightPos + digitsUsed ; while ( temp != 0 ) { temp += ( newDigits [ destPos ] & 0xFFFFFFFFL ) ; newDigits [ destPos ] = ( int ) temp ; temp >>>= 32 ; destPos ++ ; } } this . digits = newDigits ; this . digitsUsed = newDigits . length ; adjustDigitsUsed ( ) ; } } public static void main ( String [ ] args ) { MyLongNum one = new MyLongNum ( "18446744073709551616" ) ; MyLongNum two = one . clone ( ) ; one . multiply ( two ) ; System . out . println ( one ) ; } } 
import java . util . * ; public class LIS { public static < E extends Comparable < ? super E > > List < E > lis ( List < E > n ) { List < Node < E > > pileTops = new ArrayList < Node < E > > ( ) ; for ( E x : n ) { Node < E > node = new Node < E > ( ) ; node . value = x ; int i = Collections . binarySearch ( pileTops , node ) ; if ( i < 0 ) i = ~ i ; if ( i != 0 ) node . pointer = pileTops . get ( i - 1 ) ; if ( i != pileTops . size ( ) ) pileTops . set ( i , node ) ; else pileTops . add ( node ) ; } List < E > result = new ArrayList < E > ( ) ; for ( Node < E > node = pileTops . size ( ) == 0 ? null : pileTops . get ( pileTops . size ( ) - 1 ) ; node != null ; node = node . pointer ) result . add ( node . value ) ; Collections . reverse ( result ) ; return result ; } private static class Node < E extends Comparable < ? super E > > implements Comparable < Node < E > > { public E value ; public Node < E > pointer ; public int compareTo ( Node < E > y ) { return value . compareTo ( y . value ) ; } } public static void main ( String [ ] args ) { List < Integer > d = Arrays . asList ( 3 , 2 , 6 , 4 , 5 , 1 ) ; System . out . printf ( "an L.I.S. of %s is %s\n" , d , lis ( d ) ) ; d = Arrays . asList ( 0 , 8 , 4 , 12 , 2 , 10 , 6 , 14 , 1 , 9 , 5 , 13 , 3 , 11 , 7 , 15 ) ; System . out . printf ( "an L.I.S. of %s is %s\n" , d , lis ( d ) ) ; } } 
public static String lookandsay ( String number ) { StringBuilder result = new StringBuilder ( ) ; char repeat = number . charAt ( 0 ) ; number = number . substring ( 1 ) + " " ; int times = 1 ; for ( char actual : number . toCharArray ( ) ) { if ( actual != repeat ) { result . append ( times + "" + repeat ) ; times = 1 ; repeat = actual ; } else { times += 1 ; } } return result . toString ( ) ; } 
public static void main ( String [ ] args ) { String num = "1" ; for ( int i = 1 ; i <= 10 ; i ++ ) { System . out . println ( num ) ; num = lookandsay ( num ) ; } } 
String [ ] a = { "a" , "b" , "c" } ; String [ ] b = { "A" , "B" , "C" } ; int [ ] c = { 1 , 2 , 3 } ; for ( int i = 0 ; i < a . length ; i ++ ) { System . out . println ( a [ i ] + b [ i ] + c [ i ] ) ; } 
import java . util . Random ; Random rand = new Random ( ) ; while ( true ) { int a = rand . nextInt ( 20 ) ; System . out . println ( a ) ; if ( a == 10 ) break ; int b = rand . nextInt ( 20 ) ; System . out . println ( b ) ; } 
for ( int i = 1 ; i <= 10 ; i ++ ) { System . out . print ( i ) ; if ( i % 5 == 0 ) { System . out . println ( ) ; continue ; } System . out . print ( ", " ) ; } 
int val = 0 ; do { val ++ ; System . out . println ( val ) ; } while ( val % 6 != 0 ) ; 
for ( i = 10 ; i >= 0 ; -- i ) { System . out . println ( i ) ; } 
for ( int i = 2 ; i <= 8 ; i += 2 ) { System . out . print ( i + ", " ) ; } System . out . println ( "who do we appreciate?" ) ; 
for ( int i = 0 ; i < 5 ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { System . out . print ( "*" ) ; } System . out . println ( ) ; } 
Iterable < Type > collect ; ... for ( Type i : collect ) { System . out . println ( i ) ; } 
while ( true ) { System . out . println ( "SPAM" ) ; } 
for ( ; ; ) { System . out . println ( "SPAM" ) ; } 
public static void main ( String [ ] args ) { for ( int i = 1 ; ; i ++ ) { System . out . print ( i ) ; if ( i == 10 ) break ; System . out . print ( ", " ) ; } System . out . println ( ) ; } 
import java . util . Random ; public class NestedLoopTest { public static final Random gen = new Random ( ) ; public static void main ( String [ ] args ) { int [ ] [ ] a = new int [ 10 ] [ 10 ] ; for ( int i = 0 ; i < a . length ; i ++ ) for ( int j = 0 ; j < a [ i ] . length ; j ++ ) a [ i ] [ j ] = gen . nextInt ( 20 ) + 1 ; Outer : for ( int i = 0 ; i < a . length ; i ++ ) { for ( int j = 0 ; j < a [ i ] . length ; j ++ ) { System . out . print ( " " + a [ i ] [ j ] ) ; if ( a [ i ] [ j ] == 20 ) break Outer ; } System . out . println ( ) ; } System . out . println ( ) ; } } 
int i = 1024 ; while ( i > 0 ) { System . out . println ( i ) ; i >>= 1 ; } 
for ( int i = 1024 ; i > 0 ; i /= 2 ) { System . out . println ( i ) ; } 
public class Luhn { public static void main ( String [ ] args ) { System . out . println ( luhnTest ( "49927398716" ) ) ; System . out . println ( luhnTest ( "49927398717" ) ) ; System . out . println ( luhnTest ( "1234567812345678" ) ) ; System . out . println ( luhnTest ( "1234567812345670" ) ) ; } public static boolean luhnTest ( String number ) { int s1 = 0 , s2 = 0 ; String reverse = new StringBuffer ( number ) . reverse ( ) . toString ( ) ; for ( int i = 0 ; i < reverse . length ( ) ; i ++ ) { int digit = Character . digit ( reverse . charAt ( i ) , 10 ) ; if ( i % 2 == 0 ) { s1 += digit ; } else { s2 += 2 * digit ; if ( digit >= 5 ) { s2 -= 9 ; } } } return ( s1 + s2 ) % 10 == 0 ; } } 
import java . util . function . DoubleSupplier ; public class ManOrBoy { static double A ( int k , DoubleSupplier x1 , DoubleSupplier x2 , DoubleSupplier x3 , DoubleSupplier x4 , DoubleSupplier x5 ) { DoubleSupplier B = new DoubleSupplier ( ) { int m = k ; public double getAsDouble ( ) { return A ( -- m , this , x1 , x2 , x3 , x4 ) ; } } ; return k <= 0 ? x4 . getAsDouble ( ) + x5 . getAsDouble ( ) : B . getAsDouble ( ) ; } public static void main ( String [ ] args ) { System . out . println ( A ( 10 , ( ) -> 1.0 , ( ) -> - 1.0 , ( ) -> - 1.0 , ( ) -> 1.0 , ( ) -> 0.0 ) ) ; } } 
public class ManOrBoy { interface Arg { public int run ( ) ; } public static int A ( final int k , final Arg x1 , final Arg x2 , final Arg x3 , final Arg x4 , final Arg x5 ) { if ( k <= 0 ) return x4 . run ( ) + x5 . run ( ) ; return new Arg ( ) { int m = k ; public int run ( ) { m -- ; return A ( m , this , x1 , x2 , x3 , x4 ) ; } } . run ( ) ; } public static Arg C ( final int i ) { return new Arg ( ) { public int run ( ) { return i ; } } ; } public static void main ( String [ ] args ) { System . out . println ( A ( 10 , C ( 1 ) , C ( - 1 ) , C ( - 1 ) , C ( 1 ) , C ( 0 ) ) ) ; } } 
import java . awt . Graphics ; import java . awt . image . BufferedImage ; import javax . swing . JFrame ; public class Mandelbrot extends JFrame { private final int MAX_ITER = 570 ; private final double ZOOM = 150 ; private BufferedImage I ; private double zx , zy , cX , cY , tmp ; public Mandelbrot ( ) { super ( "Mandelbrot Set" ) ; setBounds ( 100 , 100 , 800 , 600 ) ; setResizable ( false ) ; setDefaultCloseOperation ( EXIT_ON_CLOSE ) ; I = new BufferedImage ( getWidth ( ) , getHeight ( ) , BufferedImage . TYPE_INT_RGB ) ; for ( int y = 0 ; y < getHeight ( ) ; y ++ ) { for ( int x = 0 ; x < getWidth ( ) ; x ++ ) { zx = zy = 0 ; cX = ( x - 400 ) / ZOOM ; cY = ( y - 300 ) / ZOOM ; int iter = MAX_ITER ; while ( zx * zx + zy * zy < 4 && iter > 0 ) { tmp = zx * zx - zy * zy + cX ; zy = 2.0 * zx * zy + cY ; zx = tmp ; iter -- ; } I . setRGB ( x , y , iter | ( iter << 8 ) ) ; } } } @ Override public void paint ( Graphics g ) { g . drawImage ( I , 0 , 0 , this ) ; } public static void main ( String [ ] args ) { new Mandelbrot ( ) . setVisible ( true ) ; } } 
import java . util . Arrays ; public class Transpose { public static void main ( String [ ] args ) { double [ ] [ ] m = { { 1 , 1 , 1 , 1 } , { 2 , 4 , 8 , 16 } , { 3 , 9 , 27 , 81 } , { 4 , 16 , 64 , 256 } , { 5 , 25 , 125 , 625 } } ; double [ ] [ ] ans = new double [ m [ 0 ] . length ] [ m . length ] ; for ( int rows = 0 ; rows < m . length ; rows ++ ) { for ( int cols = 0 ; cols < m [ 0 ] . length ; cols ++ ) { ans [ cols ] [ rows ] = m [ rows ] [ cols ] ; } } for ( double [ ] i : ans ) { System . out . println ( Arrays . toString ( i ) ) ; } } } 
public static String select ( List < String > list , String prompt ) { if ( list . size ( ) == 0 ) return "" ; Scanner sc = new Scanner ( System . in ) ; String ret = null ; do { for ( int i = 0 ; i < list . size ( ) ; i ++ ) { System . out . println ( i + ": " + list . get ( i ) ) ; } System . out . print ( prompt ) ; int index = sc . nextInt ( ) ; if ( index >= 0 && index < list . size ( ) ) { ret = list . get ( index ) ; } } while ( ret == null ) ; return ret ; } 
public class MiddleThreeDigits { public static void main ( String [ ] args ) { final long [ ] passing = { 123 , 12345 , 1234567 , 987654321 , 10001 , - 10001 , - 123 , - 100 , 100 , - 12345 , Long . MIN_VALUE , Long . MAX_VALUE } ; final int [ ] failing = { 1 , 2 , - 1 , - 10 , 2002 , - 2002 , 0 , Integer . MIN_VALUE , Integer . MAX_VALUE } ; for ( long n : passing ) System . out . printf ( "middleThreeDigits(%s): %s\n" , n , middleThreeDigits ( n ) ) ; for ( int n : failing ) System . out . printf ( "middleThreeDigits(%s): %s\n" , n , middleThreeDigits ( n ) ) ; } public static < T > String middleThreeDigits ( T n ) { String s = String . valueOf ( n ) ; if ( s . charAt ( 0 ) == '-' ) s = s . substring ( 1 ) ; int len = s . length ( ) ; if ( len < 3 || len % 2 == 0 ) return "Need odd and >= 3 digits" ; int mid = len / 2 ; return s . substring ( mid - 1 , mid + 2 ) ; } } 
System . out . println ( BigInteger . valueOf ( 42 ) . modInverse ( BigInteger . valueOf ( 2017 ) ) ) ; 
public class MC { public static void main ( String [ ] args ) { System . out . println ( getPi ( 10000 ) ) ; System . out . println ( getPi ( 100000 ) ) ; System . out . println ( getPi ( 1000000 ) ) ; System . out . println ( getPi ( 10000000 ) ) ; System . out . println ( getPi ( 100000000 ) ) ; } public static double getPi ( int numThrows ) { int inCircle = 0 ; for ( int i = 0 ; i < numThrows ; i ++ ) { double randX = ( Math . random ( ) * 2 ) - 1 ; double randY = ( Math . random ( ) * 2 ) - 1 ; double dist = Math . sqrt ( randX * randX + randY * randY ) ; if ( dist < 1 ) { inCircle ++ ; } } return 4.0 * inCircle / numThrows ; } } 
package montecarlo ; import java . util . stream . IntStream ; import java . util . stream . DoubleStream ; import static java . lang . Math . random ; import static java . lang . Math . hypot ; import static java . lang . System . out ; public interface MonteCarlo { public static void main ( String ... arguments ) { IntStream . of ( 10000 , 100000 , 1000000 , 10000000 , 100000000 ) . mapToDouble ( MonteCarlo :: pi ) . forEach ( out :: println ) ; } public static double range ( ) { return ( random ( ) * 2 ) - 1 ; } public static double pi ( int numThrows ) { long inCircle = DoubleStream . generate ( ( ) -> hypot ( range ( ) , range ( ) ) ) . limit ( numThrows ) . unordered ( ) . parallel ( ) . filter ( d -> d < 1 ) . count ( ) ; return ( 4.0 * inCircle ) / numThrows ; } } 
import java . util . Random ; public class Monty { public static void main ( String [ ] args ) { int switchWins = 0 ; int stayWins = 0 ; Random gen = new Random ( ) ; for ( int plays = 0 ; plays < 32768 ; plays ++ ) { int [ ] doors = { 0 , 0 , 0 } ; doors [ gen . nextInt ( 3 ) ] = 1 ; int choice = gen . nextInt ( 3 ) ; int shown ; do { shown = gen . nextInt ( 3 ) ; } while ( doors [ shown ] == 1 || shown == choice ) ; stayWins += doors [ choice ] ; switchWins += doors [ 3 - choice - shown ] ; } System . out . println ( "Switching wins " + switchWins + " times." ) ; System . out . println ( "Staying wins " + stayWins + " times." ) ; } } 
public static int f ( final int n ) { return n == 0 ? 1 : n - m ( f ( n - 1 ) ) ; } public static int m ( final int n ) { return n == 0 ? 0 : n - f ( m ( n - 1 ) ) ; } public static void main ( final String args [ ] ) { for ( int i = 0 ; i < 20 ; i ++ ) System . out . println ( f ( i ) ) ; System . out . println ( ) ; for ( i = 0 ; i < 20 ; i ++ ) System . out . println ( m ( i ) ) ; } 
public class NQueens { private static int [ ] b = new int [ 8 ] ; private static int s = 0 ; static boolean unsafe ( int y ) { int x = b [ y ] ; for ( int i = 1 ; i <= y ; i ++ ) { int t = b [ y - i ] ; if ( t == x || t == x - i || t == x + i ) { return true ; } } return false ; } public static void putboard ( ) { System . out . println ( "\n\nSolution " + ( ++ s ) ) ; for ( int y = 0 ; y < 8 ; y ++ ) { for ( int x = 0 ; x < 8 ; x ++ ) { System . out . print ( ( b [ y ] == x ) ? "|Q" : "|_" ) ; } System . out . println ( "|" ) ; } } public static void main ( String [ ] args ) { int y = 0 ; b [ 0 ] = - 1 ; while ( y >= 0 ) { do { b [ y ] ++ ; } while ( ( b [ y ] < 8 ) && unsafe ( y ) ) ; if ( b [ y ] < 8 ) { if ( y < 7 ) { b [ ++ y ] = - 1 ; } else { putboard ( ) ; } } else { y -- ; } } } } 
processNutritionFacts ( new NutritionFacts . Builder ( 240 , 8 ) . calories ( 100 ) . sodium ( 35 ) . carbohydrate ( 27 ) . build ( ) ) ; 
public static long backToTen ( String num , int oldBase ) { return Long . parseLong ( num , oldBase ) ; } public static String tenToBase ( long num , int newBase ) { return Long . toString ( num , newBase ) ; } 
public static BigInteger backToTenBig ( String num , int oldBase ) { return new BigInteger ( num , oldBase ) ; } public static String tenBigToBase ( BigInteger num , int newBase ) { return num . toString ( newBase ) ; } 
Scanner sc = new Scanner ( System . in ) ; sc . useRadix ( base ) ; sc . nextInt ( ) ; 
int number = Integer . parseInt ( stringNum , base ) ; 
Integer . decode ( "0xabcf123" ) ; Integer . decode ( "07651" ) ; Integer . decode ( "123459" ) ; 
public static void main ( String args [ ] ) { for ( int a = 0 ; a < 33 ; a ++ ) { System . out . println ( Integer . toBinaryString ( a ) ) ; System . out . println ( Integer . toOctalString ( a ) ) ; System . out . println ( Integer . toHexString ( a ) ) ; System . out . printf ( "%3o %2d %2x\n" , a , a , a ) ; } } 
public static double nthroot ( int n , double A ) { return nthroot ( n , A , .001 ) ; } public static double nthroot ( int n , double A , double p ) { if ( A < 0 ) { System . err . println ( "A < 0" ) ; return - 1 ; } else if ( A == 0 ) { return 0 ; } double x_prev = A ; double x = A / n ; while ( Math . abs ( x - x_prev ) > p ) { x_prev = x ; x = ( ( n - 1.0 ) * x + A / Math . pow ( x , n - 1.0 ) ) / n ; } return x ; } 
public static double nthroot ( int n , double x ) { assert ( n > 1 && x > 0 ) ; int np = n - 1 ; double g1 = x ; double g2 = iter ( g1 , np , n , x ) ; while ( g1 != g2 ) { g1 = iter ( g1 , np , n , x ) ; g2 = iter ( iter ( g2 , np , n , x ) , np , n , x ) ; } return g1 ; } private static double iter ( double g , int np , int n , double x ) { return ( np * g + x / Math . pow ( g , np ) ) / n ; } 
public class Nth { public static String ordinalAbbrev ( int n ) { String ans = "th" ; if ( n % 100 / 10 == 1 ) return ans ; switch ( n % 10 ) { case 1 : ans = "st" ; break ; case 2 : ans = "nd" ; break ; case 3 : ans = "rd" ; break ; } return ans ; } public static void main ( String [ ] args ) { for ( int i = 0 ; i <= 25 ; i ++ ) { System . out . print ( i + ordinalAbbrev ( i ) + " " ) ; } System . out . println ( ) ; for ( int i = 250 ; i <= 265 ; i ++ ) { System . out . print ( i + ordinalAbbrev ( i ) + " " ) ; } System . out . println ( ) ; for ( int i = 1000 ; i <= 1025 ; i ++ ) { System . out . print ( i + ordinalAbbrev ( i ) + " " ) ; } } } 
package nth ; import java . util . stream . IntStream ; import java . util . stream . Stream ; public interface Nth { public static String suffix ( int n ) { if ( n % 100 / 10 == 1 ) { return "th" ; } switch ( n % 10 ) { case 1 : return "st" ; case 2 : return "nd" ; case 3 : return "rd" ; default : return "th" ; } } public static void print ( int start , int end ) { IntStream . rangeClosed ( start , end ) . parallel ( ) . mapToObj ( i -> i + suffix ( i ) + " " ) . reduce ( String :: concat ) . ifPresent ( System . out :: println ) ; } public static void print ( int [ ] startAndEnd ) { print ( startAndEnd [ 0 ] , startAndEnd [ 1 ] ) ; } public static int [ ] startAndEnd ( int start , int end ) { return new int [ ] { start , end } ; } public static void main ( String ... arguments ) { Stream . of ( startAndEnd ( 0 , 25 ) , startAndEnd ( 250 , 265 ) , startAndEnd ( 1000 , 1025 ) ) . forEach ( Nth :: print ) ; } } 
if ( object == null ) { System . out . println ( "object is null" ) ; } 
import java . util . List ; import java . util . ArrayList ; import java . util . Scanner ; import java . util . Collections ; public class ReversalGame { private List < Integer > gameList ; public ReversalGame ( ) { initialize ( ) ; } public void play ( ) throws Exception { int i = 0 ; int moveCount = 0 ; Scanner scanner = new Scanner ( System . in ) ; while ( true ) { System . out . println ( gameList ) ; System . out . println ( "Please enter a index to reverse from 2 to 9. Enter 99 to quit" ) ; i = scanner . nextInt ( ) ; if ( i == 99 ) { break ; } if ( i < 2 || i > 9 ) { System . out . println ( "Invalid input" ) ; } else { moveCount ++ ; reverse ( i ) ; if ( isSorted ( ) ) { System . out . println ( "Congratulations you solved this in " + moveCount + " moves!" ) ; break ; } } } scanner . close ( ) ; } private void reverse ( int position ) { Collections . reverse ( gameList . subList ( 0 , position ) ) ; } private boolean isSorted ( ) { for ( int i = 0 ; i < gameList . size ( ) - 1 ; ++ i ) { if ( gameList . get ( i ) . compareTo ( gameList . get ( i + 1 ) ) > 0 ) { return false ; } } return true ; } private void initialize ( ) { this . gameList = new ArrayList < Integer > ( 9 ) ; for ( int i = 1 ; i < 10 ; ++ i ) { gameList . add ( i ) ; } while ( isSorted ( ) ) { Collections . shuffle ( gameList ) ; } } public static void main ( String [ ] args ) { try { ReversalGame game = new ReversalGame ( ) ; game . play ( ) ; } catch ( Exception e ) { System . out . println ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; } } } 
public static boolean pali ( String testMe ) { StringBuilder sb = new StringBuilder ( testMe ) ; return testMe . equals ( sb . reverse ( ) . toString ( ) ) ; } 
public static boolean rPali ( String testMe ) { if ( testMe . length ( ) <= 1 ) { return true ; } if ( ! ( testMe . charAt ( 0 ) + "" ) . equals ( testMe . charAt ( testMe . length ( ) - 1 ) + "" ) ) { return false ; } return rPali ( testMe . substring ( 1 , testMe . length ( ) - 1 ) ) ; } 
public static boolean rPali ( String testMe ) { int strLen = testMe . length ( ) ; return rPaliHelp ( testMe , strLen - 1 , strLen / 2 , 0 ) ; } public static boolean rPaliHelp ( String testMe , int strLen , int testLen , int index ) { if ( index > testLen ) { return true ; } if ( testMe . charAt ( index ) != testMe . charAt ( strLen - index ) ) { return false ; } return rPaliHelp ( testMe , strLen , testLen , index + 1 ) ; } 
public static boolean pali ( String testMe ) { return testMe . matches ( "|(?:(.)(?<=(?=^.*?(\\1\\2?)$).*))+(?<=(?=^\\2$).*)" ) ; } 
public class Pangram { public static boolean isPangram ( String test ) { for ( char a = 'A' ; a <= 'Z' ; a ++ ) if ( ( test . indexOf ( a ) < 0 ) && ( test . indexOf ( ( char ) ( a + 32 ) ) < 0 ) ) return false ; return true ; } public static void main ( String [ ] args ) { System . out . println ( isPangram ( "the quick brown fox jumps over the lazy dog" ) ) ; System . out . println ( isPangram ( "the quick brown fox jumped over the lazy dog" ) ) ; System . out . println ( isPangram ( "ABCDEFGHIJKLMNOPQRSTUVWXYZ" ) ) ; System . out . println ( isPangram ( "ABCDEFGHIJKLMNOPQSTUVWXYZ" ) ) ; System . out . println ( isPangram ( "ABCDEFGHIJKL.NOPQRSTUVWXYZ" ) ) ; System . out . println ( isPangram ( "ABC.D.E.FGHI*J/KL-M+NO*PQ R\nSTUVWXYZ" ) ) ; System . out . println ( isPangram ( "" ) ) ; } } 
import java . util . LinkedList ; public class RPN { public static void evalRPN ( String expr ) { String cleanExpr = cleanExpr ( expr ) ; LinkedList < Double > stack = new LinkedList < Double > ( ) ; System . out . println ( "Input\tOperation\tStack after" ) ; for ( String token : cleanExpr . split ( "\\s" ) ) { System . out . print ( token + "\t" ) ; Double tokenNum = null ; try { tokenNum = Double . parseDouble ( token ) ; } catch ( NumberFormatException e ) { } if ( tokenNum != null ) { System . out . print ( "Push\t\t" ) ; stack . push ( Double . parseDouble ( token + "" ) ) ; } else if ( token . equals ( "*" ) ) { System . out . print ( "Operate\t\t" ) ; double secondOperand = stack . pop ( ) ; double firstOperand = stack . pop ( ) ; stack . push ( firstOperand * secondOperand ) ; } else if ( token . equals ( "/" ) ) { System . out . print ( "Operate\t\t" ) ; double secondOperand = stack . pop ( ) ; double firstOperand = stack . pop ( ) ; stack . push ( firstOperand / secondOperand ) ; } else if ( token . equals ( "-" ) ) { System . out . print ( "Operate\t\t" ) ; double secondOperand = stack . pop ( ) ; double firstOperand = stack . pop ( ) ; stack . push ( firstOperand - secondOperand ) ; } else if ( token . equals ( "+" ) ) { System . out . print ( "Operate\t\t" ) ; double secondOperand = stack . pop ( ) ; double firstOperand = stack . pop ( ) ; stack . push ( firstOperand + secondOperand ) ; } else if ( token . equals ( "^" ) ) { System . out . print ( "Operate\t\t" ) ; double secondOperand = stack . pop ( ) ; double firstOperand = stack . pop ( ) ; stack . push ( Math . pow ( firstOperand , secondOperand ) ) ; } else { System . out . println ( "Error" ) ; return ; } System . out . println ( stack ) ; } System . out . println ( "Final answer: " + stack . pop ( ) ) ; } private static String cleanExpr ( String expr ) { return expr . replaceAll ( "[^\\^\\*\\+\\-\\d/\\s]" , "" ) ; } public static void main ( String [ ] args ) { evalRPN ( "3 4 2 * 1 5 - 2 3 ^ ^ / +" ) ; } } 
import java . util . ArrayList ; ... public static void genPyrN ( int rows ) { if ( rows < 0 ) return ; ArrayList < Integer > last = new ArrayList < Integer > ( ) ; last . add ( 1 ) ; System . out . println ( last ) ; for ( int i = 1 ; i <= rows ; ++ i ) { ArrayList < Integer > thisRow = new ArrayList < Integer > ( ) ; thisRow . add ( last . get ( 0 ) ) ; for ( int j = 1 ; j < i ; ++ j ) { thisRow . add ( last . get ( j - 1 ) + last . get ( j ) ) ; } thisRow . add ( last . get ( 0 ) ) ; last = thisRow ; System . out . println ( thisRow ) ; } } 
public class Pas { public static void main ( String [ ] args ) { pas ( 20 ) ; } public static void pas ( int rows ) { for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { System . out . print ( ncr ( i , j ) + " " ) ; } System . out . println ( ) ; } } public static long ncr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; } public static long fact ( int n ) { long ans = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { ans *= i ; } return ans ; } } 
public class Pascal { private static void printPascalLine ( int n ) { if ( n < 1 ) return ; int m = 1 ; System . out . print ( "1 " ) ; for ( int j = 1 ; j < n ; j ++ ) { m = m * ( n - j ) / j ; System . out . print ( m ) ; System . out . print ( " " ) ; } System . out . println ( ) ; } public static void printPascal ( int nRows ) { for ( int i = 1 ; i <= nRows ; i ++ ) printPascalLine ( i ) ; } } 
public static boolean perf ( int n ) { int sum = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( n % i == 0 ) { sum += i ; } } return sum == n ; } 
import java . math . BigInteger ; public static boolean perf ( BigInteger n ) { BigInteger sum = BigInteger . ZERO ; for ( BigInteger i = BigInteger . ONE ; i . compareTo ( n ) < 0 ; i = i . add ( BigInteger . ONE ) ) { if ( n . mod ( i ) . equals ( BigInteger . ZERO ) ) { sum = sum . add ( i ) ; } } return sum . equals ( n ) ; } 
public class PermutationGenerator { private int [ ] array ; private int firstNum ; private boolean firstReady = false ; public PermutationGenerator ( int n , int firstNum_ ) { if ( n < 1 ) { throw new IllegalArgumentException ( "The n must be min. 1" ) ; } firstNum = firstNum_ ; array = new int [ n ] ; reset ( ) ; } public void reset ( ) { for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = i + firstNum ; } firstReady = false ; } public boolean hasMore ( ) { boolean end = firstReady ; for ( int i = 1 ; i < array . length ; i ++ ) { end = end && array [ i ] < array [ i - 1 ] ; } return ! end ; } public int [ ] getNext ( ) { if ( ! firstReady ) { firstReady = true ; return array ; } int temp ; int j = array . length - 2 ; int k = array . length - 1 ; for ( ; array [ j ] > array [ j + 1 ] ; j -- ) ; for ( ; array [ j ] > array [ k ] ; k -- ) ; temp = array [ k ] ; array [ k ] = array [ j ] ; array [ j ] = temp ; int r = array . length - 1 ; int s = j + 1 ; while ( r > s ) { temp = array [ s ] ; array [ s ++ ] = array [ r ] ; array [ r -- ] = temp ; } return array ; } public static void main ( String [ ] args ) { PermutationGenerator pg = new PermutationGenerator ( 3 , 1 ) ; while ( pg . hasMore ( ) ) { int [ ] temp = pg . getNext ( ) ; for ( int i = 0 ; i < temp . length ; i ++ ) { System . out . print ( temp [ i ] + " " ) ; } System . out . println ( ) ; } } } 
public class Permutations { public static void main ( String [ ] args ) { System . out . println ( Utils . Permutations ( Utils . mRange ( 1 , 3 ) ) ) ; } } 
import java . util . Arrays ; public class PhraseRev { private static String reverse ( String x ) { return new StringBuilder ( x ) . reverse ( ) . toString ( ) ; } private static < T > T [ ] reverse ( T [ ] x ) { T [ ] rev = Arrays . copyOf ( x , x . length ) ; for ( int i = x . length - 1 ; i >= 0 ; i -- ) { rev [ x . length - 1 - i ] = x [ i ] ; } return rev ; } private static String join ( String [ ] arr , String joinStr ) { StringBuilder joined = new StringBuilder ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { joined . append ( arr [ i ] ) ; if ( i < arr . length - 1 ) joined . append ( joinStr ) ; } return joined . toString ( ) ; } public static void main ( String [ ] args ) { String str = "rosetta code phrase reversal" ; System . out . println ( "Straight-up reversed: " + reverse ( str ) ) ; String [ ] words = str . split ( " " ) ; for ( int i = 0 ; i < words . length ; i ++ ) { words [ i ] = reverse ( words [ i ] ) ; } System . out . println ( "Reversed words: " + join ( words , " " ) ) ; System . out . println ( "Reversed word order: " + join ( reverse ( str . split ( " " ) ) , " " ) ) ; } } 
import java . util . Random ; ... int [ ] array = { 1 , 2 , 3 } ; return array [ new Random ( ) . nextInt ( array . length ) ] ; 
public enum Pip { Two , Three , Four , Five , Six , Seven , Eight , Nine , Ten , Jack , Queen , King , Ace } 
public enum Suit { Diamonds , Spades , Hearts , Clubs } 
public class Card { private final Suit suit ; private final Pip value ; public Card ( Suit s , Pip v ) { suit = s ; value = v ; } public String toString ( ) { return value + " of " + suit ; } } 
import java . util . Collections ; import java . util . LinkedList ; public class Deck { private final LinkedList < Card > deck = new LinkedList < Card > ( ) ; public Deck ( ) { for ( Suit s : Suit . values ( ) ) for ( Pip v : Pip . values ( ) ) deck . add ( new Card ( s , v ) ) ; } public Card deal ( ) { return deck . poll ( ) ; } public void shuffle ( ) { Collections . shuffle ( deck ) ; } public String toString ( ) { return deck . toString ( ) ; } } 
class T implements Cloneable { public String name ( ) { return "T" ; } public T copy ( ) { try { return ( T ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { return null ; } } } class S extends T { public String name ( ) { return "S" ; } } public class PolymorphicCopy { public static T copier ( T x ) { return x . copy ( ) ; } public static void main ( String [ ] args ) { T obj1 = new T ( ) ; S obj2 = new S ( ) ; System . out . println ( copier ( obj1 ) . name ( ) ) ; System . out . println ( copier ( obj2 ) . name ( ) ) ; } } 
class Point { protected int x , y ; public Point ( ) { this ( 0 ) ; } public Point ( int x ) { this ( x , 0 ) ; } public Point ( int x , int y ) { this . x = x ; this . y = y ; } public Point ( Point p ) { this ( p . x , p . y ) ; } public int getX ( ) { return this . x ; } public int getY ( ) { return this . y ; } public void setX ( int x ) { this . x = x ; } public void setY ( int y ) { this . y = y ; } public void print ( ) { System . out . println ( "Point x: " + this . x + " y: " + this . y ) ; } } class Circle extends Point { private int r ; public Circle ( Point p ) { this ( p , 0 ) ; } public Circle ( Point p , int r ) { super ( p ) ; this . r = r ; } public Circle ( ) { this ( 0 ) ; } public Circle ( int x ) { this ( x , 0 ) ; } public Circle ( int x , int y ) { this ( x , y , 0 ) ; } public Circle ( int x , int y , int r ) { super ( x , y ) ; this . r = r ; } public Circle ( Circle c ) { this ( c . x , c . y , c . r ) ; } public int getR ( ) { return this . r ; } public void setR ( int r ) { this . r = r ; } public void print ( ) { System . out . println ( "Circle x: " + this . x + " y: " + this . y + " r: " + this . r ) ; } } public class test { public static void main ( String args [ ] ) { Point p = new Point ( ) ; Point c = new Circle ( ) ; p . print ( ) ; c . print ( ) ; } } 
public static ArrayList < String > getpowerset ( int a [ ] , int n , ArrayList < String > ps ) { if ( n < 0 ) { return null ; } if ( n == 0 ) { if ( ps == null ) ps = new ArrayList < String > ( ) ; ps . add ( " " ) ; return ps ; } ps = getpowerset ( a , n - 1 , ps ) ; ArrayList < String > tmp = new ArrayList < String > ( ) ; for ( String s : ps ) { if ( s . equals ( " " ) ) tmp . add ( "" + a [ n - 1 ] ) ; else tmp . add ( s + a [ n - 1 ] ) ; } ps . addAll ( tmp ) ; return ps ; } 
public static < T > List < List < T > > powerset ( Collection < T > list ) { List < List < T > > ps = new ArrayList < List < T > > ( ) ; ps . add ( new ArrayList < T > ( ) ) ; for ( T item : list ) { List < List < T > > newPs = new ArrayList < List < T > > ( ) ; for ( List < T > subset : ps ) { newPs . add ( subset ) ; List < T > newSubset = new ArrayList < T > ( subset ) ; newSubset . add ( item ) ; newPs . add ( newSubset ) ; } ps = newPs ; } return ps ; } 
public static < T extends Comparable < ? super T > > LinkedList < LinkedList < T > > BinPowSet ( LinkedList < T > A ) { LinkedList < LinkedList < T > > ans = new LinkedList < LinkedList < T > > ( ) ; int ansSize = ( int ) Math . pow ( 2 , A . size ( ) ) ; for ( int i = 0 ; i < ansSize ; ++ i ) { String bin = Integer . toBinaryString ( i ) ; while ( bin . length ( ) < A . size ( ) ) bin = "0" + bin ; LinkedList < T > thisComb = new LinkedList < T > ( ) ; for ( int j = 0 ; j < A . size ( ) ; ++ j ) { if ( bin . charAt ( j ) == '1' ) thisComb . add ( A . get ( j ) ) ; } Collections . sort ( thisComb ) ; ans . add ( thisComb ) ; } return ans ; } 
public static boolean prime ( long a ) { if ( a == 2 ) { return true ; } else if ( a <= 1 || a % 2 == 0 ) { return false ; } long max = ( long ) Math . sqrt ( a ) ; for ( long n = 3 ; n <= max ; n += 2 ) { if ( a % n == 0 ) { return false ; } } return true ; } 
public static boolean prime ( int n ) { return ! new String ( new char [ n ] ) . matches ( ".?|(..+?)\\1+" ) ; } 
public class ScriptName { public static void main ( String [ ] args ) { String program = System . getProperty ( "sun.java.command" ) . split ( " " ) [ 0 ] ; System . out . println ( "Program: " + program ) ; } } 
public class ScriptName { public static void main ( String [ ] args ) { Class c = new Object ( ) { } . getClass ( ) . getEnclosingClass ( ) ; System . out . println ( "Program: " + c . getName ( ) ) ; } } 
public class ScriptName { public static void main ( String [ ] args ) { Class c = System . getSecurityManager ( ) . getClassContext ( ) [ 0 ] ; System . out . println ( "Program: " + c . getName ( ) ) ; } } 
public class ScriptName { public static void main ( String [ ] args ) { String program = Thread . currentThread ( ) . getStackTrace ( ) [ 1 ] . getClassName ( ) ; System . out . println ( "Program: " + program ) ; } } 
if ( problem ) { System . exit ( integerErrorCode ) ; } 
if ( problem ) { Runtime . getRuntime ( ) . halt ( integerErrorCode ) ; } 
public class Queue < E > { Node < E > head = null , tail = null ; static class Node < E > { E value ; Node < E > next ; Node ( E value , Node < E > next ) { this . value = value ; this . next = next ; } } public Queue ( ) { } public void enqueue ( E value ) { Node < E > newNode = new Node < E > ( value , null ) ; if ( empty ( ) ) { head = newNode ; } else { tail . next = newNode ; } tail = newNode ; } public E dequeue ( ) throws java . util . NoSuchElementException { if ( empty ( ) ) { throw new java . util . NoSuchElementException ( "No more elements." ) ; } E retVal = head . value ; head = head . next ; return retVal ; } public boolean empty ( ) { return head == null ; } } 
class S { public static void main ( String [ ] a ) { String s = "class S{public static void main(String[]a){String s=;char c=34;System.out.println(s.substring(0,52)+c+s+c+s.substring(52));}}" ; char c = 34 ; System . out . println ( s . substring ( 0 , 52 ) + c + s + c + s . substring ( 52 ) ) ; } } 
class S { public static void main ( String [ ] a ) { String p = "class S{public static void main(String[]a){String p=%c%s%1$c;System.out.printf(p,34,p);}}" ; System . out . printf ( p , 34 , p ) ; } } 
double [ ] list = new double [ 1000 ] ; double mean = 1.0 , std = 0.5 ; Random rng = new Random ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { list [ i ] = mean + std * rng . nextGaussian ( ) ; } 
import java . util . * ; class RangeExpander implements Iterator < Integer > , Iterable < Integer > { private static final Pattern TOKEN_PATTERN = Pattern . compile ( "([+-]?\\d+)-([+-]?\\d+)" ) ; private final Iterator < String > tokensIterator ; private boolean inRange ; private int upperRangeEndpoint ; private int nextRangeValue ; public RangeExpander ( String range ) { String [ ] tokens = range . split ( "\\s*,\\s*" ) ; this . tokensIterator = Arrays . asList ( tokens ) . iterator ( ) ; } @ Override public boolean hasNext ( ) { return hasNextRangeValue ( ) || this . tokensIterator . hasNext ( ) ; } private boolean hasNextRangeValue ( ) { return this . inRange && this . nextRangeValue <= this . upperRangeEndpoint ; } @ Override public Integer next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } if ( hasNextRangeValue ( ) ) { return this . nextRangeValue ++ ; } String token = this . tokensIterator . next ( ) ; Matcher matcher = TOKEN_PATTERN . matcher ( token ) ; if ( matcher . find ( ) ) { this . inRange = true ; this . upperRangeEndpoint = Integer . valueOf ( matcher . group ( 2 ) ) ; this . nextRangeValue = Integer . valueOf ( matcher . group ( 1 ) ) ; return this . nextRangeValue ++ ; } this . inRange = false ; return Integer . valueOf ( token ) ; } @ Override public Iterator < Integer > iterator ( ) { return this ; } } class RangeExpanderTest { public static void main ( String [ ] args ) { RangeExpander re = new RangeExpander ( "-6,-3--1,3-5,7-11,14,15,17-20" ) ; for ( int i : re ) { System . out . print ( i + " " ) ; } } } 
import java . io . BufferedReader ; import java . io . FileReader ; public class ReadFileByLines { private static void processLine ( int lineNo , String line ) { } public static void main ( String [ ] args ) { for ( String filename : args ) { BufferedReader br = null ; FileReader fr = null ; try { fr = new FileReader ( filename ) ; br = new BufferedReader ( fr ) ; String line ; int lineNo = 0 ; while ( ( line = br . readLine ( ) ) != null ) { processLine ( ++ lineNo , line ) ; } } catch ( Exception x ) { x . printStackTrace ( ) ; } finally { if ( fr != null ) { try { br . close ( ) ; } catch ( Exception ignoreMe ) { } try { fr . close ( ) ; } catch ( Exception ignoreMe ) { } } } } } } 
for ( String filename : args ) { try ( FileReader fr = new FileReader ( filename ) ; BufferedReader br = new BufferedReader ( fr ) ) { String line ; int lineNo = 0 ; while ( ( line = br . readLine ( ) ) != null ) { processLine ( ++ lineNo , line ) ; } } catch ( Exception x ) { x . printStackTrace ( ) ; } } 
import java . nio . file . Files ; import java . nio . file . Paths ; import java . nio . charset . Charset ; import java . io . IOException ; List < String > lines = null ; try { lines = Files . readAllLines ( Paths . get ( filename ) , Charset . defaultCharset ( ) ) ; } catch ( IOException | SecurityException e ) { } 
import java . io . BufferedReader ; import java . io . FileReader ; import java . io . IOException ; public class ReadFile { public static void main ( String [ ] args ) throws IOException { String fileContents = readEntireFile ( "./foo.txt" ) ; } private static String readEntireFile ( String filename ) throws IOException { FileReader in = new FileReader ( filename ) ; StringBuilder contents = new StringBuilder ( ) ; char [ ] buffer = new char [ 4096 ] ; int read = 0 ; do { contents . append ( buffer , 0 , read ) ; read = in . read ( buffer ) ; } while ( read >= 0 ) ; in . close ( ) ; return contents . toString ( ) ; } } 
import java . nio . channels . FileChannel . MapMode ; import java . nio . MappedByteBuffer ; import java . io . RandomAccessFile ; import java . io . IOException ; import java . io . File ; public class MMapReadFile { public static void main ( String [ ] args ) throws IOException { MappedByteBuffer buff = getBufferFor ( new File ( args [ 0 ] ) ) ; String results = new String ( buff . asCharBuffer ( ) ) ; } public static MappedByteBuffer getBufferFor ( File f ) throws IOException { RandomAccessFile file = new RandomAccessFile ( f , "r" ) ; MappedByteBuffer buffer = file . getChannel ( ) . map ( MapMode . READ_ONLY , 0 , f . length ( ) ) ; file . close ( ) ; return buffer ; } } 
String content = new Scanner ( new File ( "foo" ) , "UTF-8" ) . useDelimiter ( "\\A" ) . next ( ) ; 
import java . util . List ; import java . nio . charset . Charset ; import java . nio . file . * ; public class ReadAll { public static List < String > readAllLines ( String filesname ) { Path file = Paths . get ( filename ) ; return Files . readAllLines ( file , Charset . defaultCharset ( ) ) ; } public static byte [ ] readAllBytes ( String filename ) { Path file = Paths . get ( filename ) ; return Files . readAllBytes ( file ) ; } } 
Math . E ; Math . PI ; Math . sqrt ( x ) ; Math . log ( x ) ; Math . exp ( x ) ; Math . abs ( x ) ; Math . floor ( x ) ; Math . ceil ( x ) ; Math . pow ( x , y ) ; 
import java . util . * ; import java . lang . Math ; import org . apache . commons . math . fraction . Fraction ; import org . apache . commons . math . fraction . FractionConversionException ; class Matrix { LinkedList < LinkedList < Fraction > > matrix ; int numRows ; int numCols ; static class Coordinate { int row ; int col ; Coordinate ( int r , int c ) { row = r ; col = c ; } public String toString ( ) { return "(" + row + ", " + col + ")" ; } } Matrix ( double [ ] [ ] m ) { numRows = m . length ; numCols = m [ 0 ] . length ; matrix = new LinkedList < LinkedList < Fraction > > ( ) ; for ( int i = 0 ; i < numRows ; i ++ ) { matrix . add ( new LinkedList < Fraction > ( ) ) ; for ( int j = 0 ; j < numCols ; j ++ ) { try { matrix . get ( i ) . add ( new Fraction ( m [ i ] [ j ] ) ) ; } catch ( FractionConversionException e ) { System . err . println ( "Fraction could not be converted from double by apache commons . . ." ) ; } } } } public void Interchange ( Coordinate a , Coordinate b ) { LinkedList < Fraction > temp = matrix . get ( a . row ) ; matrix . set ( a . row , matrix . get ( b . row ) ) ; matrix . set ( b . row , temp ) ; int t = a . row ; a . row = b . row ; b . row = t ; } public void Scale ( Coordinate x , Fraction d ) { LinkedList < Fraction > row = matrix . get ( x . row ) ; for ( int i = 0 ; i < numCols ; i ++ ) { row . set ( i , row . get ( i ) . multiply ( d ) ) ; } } public void MultiplyAndAdd ( Coordinate to , Coordinate from , Fraction scalar ) { LinkedList < Fraction > row = matrix . get ( to . row ) ; LinkedList < Fraction > rowMultiplied = matrix . get ( from . row ) ; for ( int i = 0 ; i < numCols ; i ++ ) { row . set ( i , row . get ( i ) . add ( ( rowMultiplied . get ( i ) . multiply ( scalar ) ) ) ) ; } } public void RREF ( ) { Coordinate pivot = new Coordinate ( 0 , 0 ) ; int submatrix = 0 ; for ( int x = 0 ; x < numCols ; x ++ ) { pivot = new Coordinate ( pivot . row , x ) ; for ( int i = x ; i < numCols ; i ++ ) { if ( isColumnZeroes ( pivot ) == false ) { break ; } else { pivot . col = i ; } } pivot = findPivot ( pivot ) ; if ( getCoordinate ( pivot ) . doubleValue ( ) == 0.0 ) { pivot . row ++ ; continue ; } if ( pivot . row != submatrix ) { Interchange ( new Coordinate ( submatrix , pivot . col ) , pivot ) ; } if ( getCoordinate ( pivot ) . doubleValue ( ) != 1 ) { Fraction scalar = getCoordinate ( pivot ) . reciprocal ( ) ; Scale ( pivot , scalar ) ; } for ( int i = pivot . row ; i < numRows ; i ++ ) { if ( i == pivot . row ) { continue ; } Coordinate belowPivot = new Coordinate ( i , pivot . col ) ; Fraction complement = ( getCoordinate ( belowPivot ) . negate ( ) . divide ( getCoordinate ( pivot ) ) ) ; MultiplyAndAdd ( belowPivot , pivot , complement ) ; } for ( int i = pivot . row ; i >= 0 ; i -- ) { if ( i == pivot . row ) { if ( getCoordinate ( pivot ) . doubleValue ( ) != 1.0 ) { Scale ( pivot , getCoordinate ( pivot ) . reciprocal ( ) ) ; } continue ; } if ( i == pivot . row ) { continue ; } Coordinate abovePivot = new Coordinate ( i , pivot . col ) ; Fraction complement = ( getCoordinate ( abovePivot ) . negate ( ) . divide ( getCoordinate ( pivot ) ) ) ; MultiplyAndAdd ( abovePivot , pivot , complement ) ; } if ( ( pivot . row + 1 ) >= numRows || isRowZeroes ( new Coordinate ( pivot . row + 1 , pivot . col ) ) ) { break ; } submatrix ++ ; pivot . row ++ ; } } public boolean isColumnZeroes ( Coordinate a ) { for ( int i = 0 ; i < numRows ; i ++ ) { if ( matrix . get ( i ) . get ( a . col ) . doubleValue ( ) != 0.0 ) { return false ; } } return true ; } public boolean isRowZeroes ( Coordinate a ) { for ( int i = 0 ; i < numCols ; i ++ ) { if ( matrix . get ( a . row ) . get ( i ) . doubleValue ( ) != 0.0 ) { return false ; } } return true ; } public Coordinate findPivot ( Coordinate a ) { int first_row = a . row ; Coordinate pivot = new Coordinate ( a . row , a . col ) ; Coordinate current = new Coordinate ( a . row , a . col ) ; for ( int i = a . row ; i < ( numRows - first_row ) ; i ++ ) { current . row = i ; if ( getCoordinate ( current ) . doubleValue ( ) == 1.0 ) { Interchange ( current , a ) ; } } current . row = a . row ; for ( int i = current . row ; i < ( numRows - first_row ) ; i ++ ) { current . row = i ; if ( getCoordinate ( current ) . doubleValue ( ) != 0 ) { pivot . row = i ; break ; } } return pivot ; } public Fraction getCoordinate ( Coordinate a ) { return matrix . get ( a . row ) . get ( a . col ) ; } public String toString ( ) { return matrix . toString ( ) . replace ( "], " , "]\n" ) ; } public static void main ( String [ ] args ) { double [ ] [ ] matrix_1 = { { 1 , 2 , - 1 , - 4 } , { 2 , 3 , - 1 , - 11 } , { - 2 , 0 , - 3 , 22 } } ; Matrix x = new Matrix ( matrix_1 ) ; System . out . println ( "before\n" + x . toString ( ) + "\n" ) ; x . RREF ( ) ; System . out . println ( "after\n" + x . toString ( ) + "\n" ) ; double matrix_2 [ ] [ ] = { { 2 , 0 , - 1 , 0 , 0 } , { 1 , 0 , 0 , - 1 , 0 } , { 3 , 0 , 0 , - 2 , - 1 } , { 0 , 1 , 0 , 0 , - 2 } , { 0 , 1 , - 1 , 0 , 0 } } ; Matrix y = new Matrix ( matrix_2 ) ; System . out . println ( "before\n" + y . toString ( ) + "\n" ) ; y . RREF ( ) ; System . out . println ( "after\n" + y . toString ( ) + "\n" ) ; double matrix_3 [ ] [ ] = { { 1 , 2 , 3 , 4 , 3 , 1 } , { 2 , 4 , 6 , 2 , 6 , 2 } , { 3 , 6 , 18 , 9 , 9 , - 6 } , { 4 , 8 , 12 , 10 , 12 , 4 } , { 5 , 10 , 24 , 11 , 15 , - 4 } } ; Matrix z = new Matrix ( matrix_3 ) ; System . out . println ( "before\n" + z . toString ( ) + "\n" ) ; z . RREF ( ) ; System . out . println ( "after\n" + z . toString ( ) + "\n" ) ; double matrix_4 [ ] [ ] = { { 0 , 1 } , { 1 , 2 } , { 0 , 5 } } ; Matrix a = new Matrix ( matrix_4 ) ; System . out . println ( "before\n" + a . toString ( ) + "\n" ) ; a . RREF ( ) ; System . out . println ( "after\n" + a . toString ( ) + "\n" ) ; } } 
String str = "I am a string" ; if ( str . matches ( ".*string" ) ) { System . out . println ( "ends with 'string'" ) ; } 
import java . util . regex . * ; Pattern p = Pattern . compile ( "a*b" ) ; Matcher m = p . matcher ( str ) ; while ( m . find ( ) ) { } 
String orig = "I am the original string" ; String result = orig . replaceAll ( "original" , "modified" ) ; 
import java . util . * ; class Test { public static void main ( String [ ] args ) { Object [ ] data = { 1 , 1 , 2 , 2 , 3 , 3 , 3 , "a" , "a" , "b" , "b" , "c" , "d" } ; Set < Object > uniqueSet = new HashSet < Object > ( Arrays . asList ( data ) ) ; for ( Object o : uniqueSet ) System . out . printf ( "%s " , o ) ; } } 
import java . util . * ; class Test { public static void main ( String [ ] args ) { Object [ ] data = { 1 , 1 , 2 , 2 , 3 , 3 , 3 , "a" , "a" , "b" , "b" , "c" , "d" } ; Arrays . stream ( data ) . distinct ( ) . forEach ( ( o ) -> System . out . printf ( "%s " , o ) ) ; } } 
import java . io . File ; public class FileRenameTest { public static boolean renameFile ( String oldname , String newname ) { File file = new File ( oldname ) ; File file2 = new File ( newname ) ; boolean success = file . renameTo ( file2 ) ; return success ; } public static void test ( String type , String oldname , String newname ) { System . out . println ( "The following " + type + " called " + oldname + ( renameFile ( oldname , newname ) ? " was renamed as " : " could not be renamed into " ) + newname + "." ) ; } public static void main ( String args [ ] ) { test ( "file" , "input.txt" , "output.txt" ) ; test ( "file" , File . separator + "input.txt" , File . separator + "output.txt" ) ; test ( "directory" , "docs" , "mydocs" ) ; test ( "directory" , File . separator + "docs" + File . separator , File . separator + "mydocs" + File . separator ) ; } } 
public static String repeat ( String str , int times ) { StringBuilder sb = new StringBuilder ( str . length ( ) * times ) ; for ( int i = 0 ; i < times ; i ++ ) sb . append ( str ) ; return sb . toString ( ) ; } public static void main ( String [ ] args ) { System . out . println ( repeat ( "ha" , 5 ) ) ; } 
public static String repeat ( String str , int times ) { return new String ( new char [ times ] ) . replace ( "\0" , str ) ; } 
import java . util . List ; import java . util . ArrayList ; import java . util . Map ; import java . util . HashMap ; public class RReturnMultipleVals { public static final String K_lipsum = "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua." ; public static final Long K_1024 = 1024L ; public static final String L = "L" ; public static final String R = "R" ; public static void main ( String [ ] args ) throws NumberFormatException { Long nv_ ; String sv_ ; switch ( args . length ) { case 0 : nv_ = K_1024 ; sv_ = K_lipsum ; break ; case 1 : nv_ = Long . parseLong ( args [ 0 ] ) ; sv_ = K_lipsum ; break ; case 2 : nv_ = Long . parseLong ( args [ 0 ] ) ; sv_ = args [ 1 ] ; break ; default : nv_ = Long . parseLong ( args [ 0 ] ) ; sv_ = args [ 1 ] ; for ( int ix = 2 ; ix < args . length ; ++ ix ) { sv_ = sv_ + " " + args [ ix ] ; } break ; } RReturnMultipleVals lcl = new RReturnMultipleVals ( ) ; Pair < Long , String > rvp = lcl . getPairFromPair ( nv_ , sv_ ) ; System . out . println ( "Results extracted from a composite object:" ) ; System . out . printf ( "%s, %s%n%n" , rvp . getLeftVal ( ) , rvp . getRightVal ( ) ) ; List < Object > rvl = lcl . getPairFromList ( nv_ , sv_ ) ; System . out . println ( "Results extracted from a Java Colections \"List\" object:" ) ; System . out . printf ( "%s, %s%n%n" , rvl . get ( 0 ) , rvl . get ( 1 ) ) ; Map < String , Object > rvm = lcl . getPairFromMap ( nv_ , sv_ ) ; System . out . println ( "Results extracted from a Java Colections \"Map\" object:" ) ; System . out . printf ( "%s, %s%n%n" , rvm . get ( L ) , rvm . get ( R ) ) ; } public < T , U > Pair < T , U > getPairFromPair ( T vl_ , U vr_ ) { return new Pair < T , U > ( vl_ , vr_ ) ; } public List < Object > getPairFromList ( Object nv_ , Object sv_ ) { List < Object > rset = new ArrayList < Object > ( ) ; rset . add ( nv_ ) ; rset . add ( sv_ ) ; return rset ; } public Map < String , Object > getPairFromMap ( Object nv_ , Object sv_ ) { Map < String , Object > rset = new HashMap < String , Object > ( ) ; rset . put ( L , nv_ ) ; rset . put ( R , sv_ ) ; return rset ; } private static class Pair < L , R > { private L leftVal ; private R rightVal ; public Pair ( L nv_ , R sv_ ) { setLeftVal ( nv_ ) ; setRightVal ( sv_ ) ; } public void setLeftVal ( L nv_ ) { leftVal = nv_ ; } public L getLeftVal ( ) { return leftVal ; } public void setRightVal ( R sv_ ) { rightVal = sv_ ; } public R getRightVal ( ) { return rightVal ; } } } 
public class Values { private final Object [ ] objects ; public Values ( Object ... objects ) { this . objects = objects ; } public < T > T get ( int i ) { return ( T ) objects [ i ] ; } public Object [ ] get ( ) { return objects ; } public static void main ( String [ ] args ) { Values v = getValues ( ) ; int i = v . get ( 0 ) ; System . out . println ( i ) ; printValues ( i , v . get ( 1 ) ) ; printValues ( v . get ( ) ) ; } private static Values getValues ( ) { return new Values ( 1 , 3.8 , "text" ) ; } private static void printValues ( int i , double d ) { System . out . println ( i + ", " + d ) ; } private static void printValues ( Object ... objects ) { for ( int i = 0 ; i < objects . length ; i += 1 ) System . out . print ( ( i == 0 ? "" : ", " ) + objects [ i ] ) ; System . out . println ( ) ; } } 
public static String reverseString ( String s ) { return new StringBuffer ( s ) . reverse ( ) . toString ( ) ; } 
public static String reverseString ( String s ) { return new StringBuilder ( s ) . reverse ( ) . toString ( ) ; } 
public class ReverseWords { static final String [ ] lines = { " ----------- Ice and Fire ----------- " , "                                      " , " fire, in end will world the say Some " , " ice. in say Some                     " , " desire of tasted I've what From      " , " fire. favor who those with hold I    " , "                                      " , " ... elided paragraph last ...        " , " Frost Robert ----------------------- " } ; public static void main ( String [ ] args ) { for ( String line : lines ) { String [ ] words = line . split ( "\\s" ) ; for ( int i = words . length - 1 ; i >= 0 ; i -- ) System . out . printf ( "%s " , words [ i ] ) ; System . out . println ( ) ; } } } 
package string ; import static java . util . Arrays . stream ; public interface ReverseWords { public static final String [ ] LINES = { " ----------- Ice and Fire ----------- " , "                                      " , " fire, in end will world the say Some " , " ice. in say Some                     " , " desire of tasted I've what From      " , " fire. favor who those with hold I    " , "                                      " , " ... elided paragraph last ...        " , " Frost Robert ----------------------- " } ; public static String [ ] reverseWords ( String [ ] lines ) { return stream ( lines ) . parallel ( ) . map ( l -> l . split ( "\\s" ) ) . map ( ws -> stream ( ws ) . parallel ( ) . map ( w -> " " + w ) . reduce ( "" , ( w1 , w2 ) -> w2 + w1 ) ) . toArray ( String [ ] :: new ) ; } public static void main ( String ... arguments ) { stream ( reverseWords ( LINES ) ) . forEach ( System . out :: println ) ; } } 
public class Roman { private static int decodeSingle ( char letter ) { switch ( letter ) { case 'M' : return 1000 ; case 'D' : return 500 ; case 'C' : return 100 ; case 'L' : return 50 ; case 'X' : return 10 ; case 'V' : return 5 ; case 'I' : return 1 ; default : return 0 ; } } public static int decode ( String roman ) { int result = 0 ; String uRoman = roman . toUpperCase ( ) ; for ( int i = 0 ; i < uRoman . length ( ) - 1 ; i ++ ) { if ( decodeSingle ( uRoman . charAt ( i ) ) < decodeSingle ( uRoman . charAt ( i + 1 ) ) ) { result -= decodeSingle ( uRoman . charAt ( i ) ) ; } else { result += decodeSingle ( uRoman . charAt ( i ) ) ; } } result += decodeSingle ( uRoman . charAt ( uRoman . length ( ) - 1 ) ) ; return result ; } public static void main ( String [ ] args ) { System . out . println ( decode ( "MCMXC" ) ) ; System . out . println ( decode ( "MMVIII" ) ) ; System . out . println ( decode ( "MDCLXVI" ) ) ; } } 
import java . util . Set ; import java . util . EnumSet ; import java . util . Collections ; import java . util . stream . Collectors ; import java . util . stream . LongStream ; public interface RomanNumerals { public enum Numeral { M ( 1000 ) , CM ( 900 ) , D ( 500 ) , CD ( 400 ) , C ( 100 ) , XC ( 90 ) , L ( 50 ) , XL ( 40 ) , X ( 10 ) , IX ( 9 ) , V ( 5 ) , IV ( 4 ) , I ( 1 ) ; public final long weight ; private static final Set < Numeral > SET = Collections . unmodifiableSet ( EnumSet . allOf ( Numeral . class ) ) ; private Numeral ( long weight ) { this . weight = weight ; } public static Numeral getLargest ( long weight ) { return SET . stream ( ) . filter ( numeral -> weight >= numeral . weight ) . findFirst ( ) . orElse ( I ) ; } } ; public static String encode ( long n ) { return LongStream . iterate ( n , l -> l - Numeral . getLargest ( l ) . weight ) . limit ( Numeral . values ( ) . length ) . filter ( l -> l > 0 ) . mapToObj ( Numeral :: getLargest ) . map ( String :: valueOf ) . collect ( Collectors . joining ( ) ) ; } public static long decode ( String roman ) { long result = new StringBuilder ( roman . toUpperCase ( ) ) . reverse ( ) . chars ( ) . mapToObj ( c -> Character . toString ( ( char ) c ) ) . map ( numeral -> Enum . valueOf ( Numeral . class , numeral ) ) . mapToLong ( numeral -> numeral . weight ) . reduce ( 0 , ( a , b ) -> a + ( a <= b ? b : - b ) ) ; if ( roman . charAt ( 0 ) == roman . charAt ( 1 ) ) { result += 2 * Enum . valueOf ( Numeral . class , roman . substring ( 0 , 1 ) ) . weight ; } return result ; } public static void test ( long n ) { System . out . println ( n + " = " + encode ( n ) ) ; System . out . println ( encode ( n ) + " = " + decode ( encode ( n ) ) ) ; } public static void main ( String [ ] args ) { LongStream . of ( 1999 , 25 , 944 ) . forEach ( RomanNumerals :: test ) ; } } 
public class RN { enum Numeral { I ( 1 ) , IV ( 4 ) , V ( 5 ) , IX ( 9 ) , X ( 10 ) , XL ( 40 ) , L ( 50 ) , XC ( 90 ) , C ( 100 ) , CD ( 400 ) , D ( 500 ) , CM ( 900 ) , M ( 1000 ) ; int weight ; Numeral ( int weight ) { this . weight = weight ; } } ; public static String roman ( long n ) { if ( n <= 0 ) { throw new IllegalArgumentException ( ) ; } StringBuilder buf = new StringBuilder ( ) ; final Numeral [ ] values = Numeral . values ( ) ; for ( int i = values . length - 1 ; i >= 0 ; i -- ) { while ( n >= values [ i ] . weight ) { buf . append ( values [ i ] ) ; n -= values [ i ] . weight ; } } return buf . toString ( ) ; } public static void test ( long n ) { System . out . println ( n + " = " + roman ( n ) ) ; } public static void main ( String [ ] args ) { test ( 1999 ) ; test ( 25 ) ; test ( 944 ) ; test ( 0 ) ; } } 
import java . util . Set ; import java . util . EnumSet ; import java . util . Collections ; import java . util . stream . Collectors ; import java . util . stream . LongStream ; public interface RomanNumerals { public enum Numeral { M ( 1000 ) , CM ( 900 ) , D ( 500 ) , CD ( 400 ) , C ( 100 ) , XC ( 90 ) , L ( 50 ) , XL ( 40 ) , X ( 10 ) , IX ( 9 ) , V ( 5 ) , IV ( 4 ) , I ( 1 ) ; public final long weight ; private static final Set < Numeral > SET = Collections . unmodifiableSet ( EnumSet . allOf ( Numeral . class ) ) ; private Numeral ( long weight ) { this . weight = weight ; } public static Numeral getLargest ( long weight ) { return SET . stream ( ) . filter ( numeral -> weight >= numeral . weight ) . findFirst ( ) . orElse ( I ) ; } } ; public static String encode ( long n ) { return LongStream . iterate ( n , l -> l - Numeral . getLargest ( l ) . weight ) . limit ( Numeral . values ( ) . length ) . filter ( l -> l > 0 ) . mapToObj ( Numeral :: getLargest ) . map ( String :: valueOf ) . collect ( Collectors . joining ( ) ) ; } public static long decode ( String roman ) { long result = new StringBuilder ( roman . toUpperCase ( ) ) . reverse ( ) . chars ( ) . mapToObj ( c -> Character . toString ( ( char ) c ) ) . map ( numeral -> Enum . valueOf ( Numeral . class , numeral ) ) . mapToLong ( numeral -> numeral . weight ) . reduce ( 0 , ( a , b ) -> a + ( a <= b ? b : - b ) ) ; if ( roman . charAt ( 0 ) == roman . charAt ( 1 ) ) { result += 2 * Enum . valueOf ( Numeral . class , roman . substring ( 0 , 1 ) ) . weight ; } return result ; } public static void test ( long n ) { System . out . println ( n + " = " + encode ( n ) ) ; System . out . println ( encode ( n ) + " = " + decode ( encode ( n ) ) ) ; } public static void main ( String [ ] args ) { LongStream . of ( 1999 , 25 , 944 ) . forEach ( RomanNumerals :: test ) ; } } 
import java . io . * ; public class Rot13 { public static void main ( String [ ] args ) throws IOException { if ( args . length >= 1 ) { for ( String file : args ) { try ( InputStream in = new BufferedInputStream ( new FileInputStream ( file ) ) ) { rot13 ( in , System . out ) ; } } } else { rot13 ( System . in , System . out ) ; } } private static void rot13 ( InputStream in , OutputStream out ) throws IOException { int ch ; while ( ( ch = in . read ( ) ) != - 1 ) { out . write ( rot13 ( ( char ) ch ) ) ; } } private static char rot13 ( char ch ) { if ( ch >= 'A' && ch <= 'Z' ) { return ( char ) ( ( ( ch - 'A' ) + 13 ) % 26 + 'A' ) ; } if ( ch >= 'a' && ch <= 'z' ) { return ( char ) ( ( ( ch - 'a' ) + 13 ) % 26 + 'a' ) ; } return ch ; } } 
import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class RunLengthEncoding { public static String encode ( String source ) { StringBuffer dest = new StringBuffer ( ) ; for ( int i = 0 ; i < source . length ( ) ; i ++ ) { int runLength = 1 ; while ( i + 1 < source . length ( ) && source . charAt ( i ) == source . charAt ( i + 1 ) ) { runLength ++ ; i ++ ; } dest . append ( runLength ) ; dest . append ( source . charAt ( i ) ) ; } return dest . toString ( ) ; } public static String decode ( String source ) { StringBuffer dest = new StringBuffer ( ) ; Pattern pattern = Pattern . compile ( "[0-9]+|[a-zA-Z]" ) ; Matcher matcher = pattern . matcher ( source ) ; while ( matcher . find ( ) ) { int number = Integer . parseInt ( matcher . group ( ) ) ; matcher . find ( ) ; while ( number -- != 0 ) { dest . append ( matcher . group ( ) ) ; } } return dest . toString ( ) ; } public static void main ( String [ ] args ) { String example = "WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW" ; System . out . println ( encode ( example ) ) ; System . out . println ( decode ( "1W1B1W1B1W1B1W1B1W1B1W1B1W1B" ) ) ; } } 
import static org . junit . Assert . assertEquals ; import org . junit . Test ; public class RunLengthEncodingTest { private RLE = new RunLengthEncoding ( ) ; @ Test public void encodingTest ( ) { assertEquals ( "1W" , RLE . encode ( "W" ) ) ; assertEquals ( "4W" , RLE . encode ( "WWWW" ) ) ; assertEquals ( "5w4i7k3i6p5e4d2i1a" , RLE . encode ( "wwwwwiiiikkkkkkkiiippppppeeeeeddddiia" ) ) ; assertEquals ( "12B1N12B3N24B1N14B" , RLE . encode ( "BBBBBBBBBBBBNBBBBBBBBBBBBNNNBBBBBBBBBBBBBBBBBBBBBBBBNBBBBBBBBBBBBBB" ) ) ; assertEquals ( "12W1B12W3B24W1B14W" , RLE . encode ( "WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW" ) ) ; assertEquals ( "1W1B1W1B1W1B1W1B1W1B1W1B1W1B" , RLE . encode ( "WBWBWBWBWBWBWB" ) ) ; } @ Test public void decodingTest ( ) { assertEquals ( "W" , RLE . decode ( "1W" ) ) ; assertEquals ( "WWWW" , RLE . decode ( "4W" ) ) ; assertEquals ( "WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW" , RLE . decode ( "12W1B12W3B24W1B14W" ) ) ; assertEquals ( "WBWBWBWBWBWBWB" , RLE . decode ( "1W1B1W1B1W1B1W1B1W1B1W1B1W1B" ) ) ; assertEquals ( "WBWBWBWBWBWBWB" , RLE . decode ( "1W1B1W1B1W1B1W1B1W1B1W1B1W1B" ) ) ; } } 
import java . util . Scanner ; public class SEDOL { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( sc . hasNext ( ) ) { String sedol = sc . next ( ) ; System . out . println ( sedol + getSedolCheckDigit ( sedol ) ) ; } } private static final int [ ] mult = { 1 , 3 , 1 , 7 , 3 , 9 } ; public static int getSedolCheckDigit ( String str ) { if ( ! validateSedol ( str ) ) { System . err . println ( "SEDOL strings must contain six characters with no vowels." ) ; return - 1 ; } str = str . toUpperCase ( ) ; int total = 0 ; for ( int i = 0 ; i < 6 ; i ++ ) { char s = str . charAt ( i ) ; total += Character . digit ( s , 36 ) * mult [ i ] ; } return ( 10 - ( total % 10 ) ) % 10 ; } public static boolean validateSedol ( String str ) { return ( str . length ( ) == 6 ) && ! str . toUpperCase ( ) . matches ( ".*?[AEIOU].*?" ) ; } } 
import java . util . List ; import java . util . Arrays ; List < String > haystack = Arrays . asList ( "Zig" , "Zag" , "Wally" , "Ronald" , "Bush" , "Krusty" , "Charlie" , "Bush" , "Bozo" ) ; for ( String needle : new String [ ] { "Washington" , "Bush" } ) { int index = haystack . indexOf ( needle ) ; if ( index < 0 ) System . out . println ( needle + " is not in haystack" ) ; else System . out . println ( index + " " + needle ) ; } 
import java . util . Arrays ; String [ ] haystack = { "Zig" , "Zag" , "Wally" , "Ronald" , "Bush" , "Krusty" , "Charlie" , "Bush" , "Bozo" } ; for ( String needle : new String [ ] { "Washington" , "Bush" } ) { int index = Arrays . binarySearch ( haystack , needle ) ; if ( index < 0 ) System . out . println ( needle + " is not in haystack" ) ; else System . out . println ( index + " " + needle ) ; } 
public class SelfDescribingNumbers { public static boolean isSelfDescribing ( int a ) { String s = Integer . toString ( a ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { String s0 = s . charAt ( i ) + "" ; int b = Integer . parseInt ( s0 ) ; int count = 0 ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { int temp = Integer . parseInt ( s . charAt ( j ) + "" ) ; if ( temp == i ) { count ++ ; } if ( count > b ) return false ; } if ( count != b ) return false ; } return true ; } public static void main ( String [ ] args ) { for ( int i = 0 ; i < 100000000 ; i ++ ) { if ( isSelfDescribing ( i ) ) { System . out . println ( i ) ; } } } } 
import java . nio . file . * ; import java . util . * ; public class Semordnilap { public static void main ( String [ ] args ) throws Exception { List < String > lst = Files . readAllLines ( Paths . get ( "unixdict.txt" ) ) ; Set < String > seen = new HashSet < > ( ) ; int count = 0 ; for ( String w : lst ) { w = w . toLowerCase ( ) ; String r = new StringBuilder ( w ) . reverse ( ) . toString ( ) ; if ( seen . contains ( r ) ) { if ( count ++ < 5 ) System . out . printf ( "%-10s %-10s\n" , w , r ) ; } else seen . add ( w ) ; } System . out . println ( "\nSemordnilap pairs found: " + count ) ; } } 
public class SeqNonSquares { public static int nonsqr ( int n ) { return n + ( int ) Math . round ( Math . sqrt ( n ) ) ; } public static void main ( String [ ] args ) { for ( int i = 1 ; i < 23 ; i ++ ) System . out . print ( nonsqr ( i ) + " " ) ; System . out . println ( ) ; for ( int i = 1 ; i < 1000000 ; i ++ ) { double j = Math . sqrt ( nonsqr ( i ) ) ; assert j != Math . floor ( j ) ; } } } 
import java . text . DateFormat ; import java . util . Date ; import java . util . TimeZone ; public class DateTest { public static void main ( String [ ] args ) { Date date = new Date ( 0 ) ; DateFormat format = DateFormat . getDateTimeInstance ( ) ; format . setTimeZone ( TimeZone . getTimeZone ( "UTC" ) ) ; System . out . println ( format . format ( date ) ) ; } } 
import java . util . LinkedList ; public class Sieve { public static LinkedList < Integer > sieve ( int n ) { if ( n < 2 ) return new LinkedList < Integer > ( ) ; LinkedList < Integer > primes = new LinkedList < Integer > ( ) ; LinkedList < Integer > nums = new LinkedList < Integer > ( ) ; for ( int i = 2 ; i <= n ; i ++ ) { nums . add ( i ) ; } while ( nums . size ( ) > 0 ) { int nextPrime = nums . remove ( ) ; for ( int i = nextPrime * nextPrime ; i <= n ; i += nextPrime ) { nums . removeFirstOccurrence ( i ) ; } primes . add ( nextPrime ) ; } return primes ; } } 
nums . add ( 2 ) ; for ( int i = 3 ; i <= n ; i += 2 ) { nums . add ( i ) ; } 
import java . util . LinkedList ; import java . util . BitSet ; public class Sieve { public static LinkedList < Integer > sieve ( int n ) { LinkedList < Integer > primes = new LinkedList < Integer > ( ) ; BitSet nonPrimes = new BitSet ( n + 1 ) ; for ( int p = 2 ; p <= n ; p = nonPrimes . nextClearBit ( p + 1 ) ) { for ( int i = p * p ; i <= n ; i += p ) nonPrimes . set ( i ) ; primes . add ( p ) ; } return primes ; } } 
import java . util . Iterator ; import java . util . PriorityQueue ; import java . math . BigInteger ; public class InfiniteSieve implements Iterator < BigInteger > { private static class NonPrimeSequence implements Comparable < NonPrimeSequence > { BigInteger currentMultiple ; BigInteger prime ; public NonPrimeSequence ( BigInteger p ) { prime = p ; currentMultiple = p . multiply ( p ) ; } @ Override public int compareTo ( NonPrimeSequence other ) { return currentMultiple . compareTo ( other . currentMultiple ) ; } } private BigInteger i = BigInteger . valueOf ( 2 ) ; final PriorityQueue < NonPrimeSequence > nonprimes = new PriorityQueue < NonPrimeSequence > ( ) ; @ Override public boolean hasNext ( ) { return true ; } @ Override public BigInteger next ( ) { for ( ; ! nonprimes . isEmpty ( ) && i . equals ( nonprimes . peek ( ) . currentMultiple ) ; i = i . add ( BigInteger . ONE ) ) { while ( nonprimes . peek ( ) . currentMultiple . equals ( i ) ) { NonPrimeSequence x = nonprimes . poll ( ) ; x . currentMultiple = x . currentMultiple . add ( x . prime ) ; nonprimes . offer ( x ) ; } } nonprimes . offer ( new NonPrimeSequence ( i ) ) ; BigInteger result = i ; i = i . add ( BigInteger . ONE ) ; return result ; } public static void main ( String [ ] args ) { Iterator < BigInteger > sieve = new InfiniteSieve ( ) ; for ( int i = 0 ; i < 25 ; i ++ ) { System . out . println ( sieve . next ( ) ) ; } } } 
import java . util . Iterator ; import java . util . HashMap ; public class SoEInfHashMap implements Iterator < Long > { long candidate = 2 ; Iterator < Long > baseprimes = null ; long basep = 3 ; long basepsqr = 9 ; final HashMap < Long , Long > nonprimes = new HashMap < > ( ) ; @ Override public boolean hasNext ( ) { return true ; } @ Override public Long next ( ) { if ( this . candidate <= 5L ) if ( this . candidate ++ == 2L ) return 2L ; else { this . candidate ++ ; if ( this . candidate == 5L ) return 3L ; else { this . baseprimes = new SoEInfHashMap ( ) ; this . baseprimes . next ( ) ; this . baseprimes . next ( ) ; return 5L ; } } for ( ; this . candidate >= this . basepsqr || nonprimes . containsKey ( this . candidate ) ; candidate += 2 ) { if ( candidate >= basepsqr ) { long adv = this . basep << 1 ; nonprimes . put ( this . basep * this . basep + adv , adv ) ; this . basep = this . baseprimes . next ( ) ; this . basepsqr = this . basep * this . basep ; } else { long adv = nonprimes . remove ( this . candidate ) ; long nxt = this . candidate + adv ; while ( this . nonprimes . containsKey ( nxt ) ) nxt += adv ; this . nonprimes . put ( nxt , adv ) ; } } long tmp = candidate ; this . candidate += 2 ; return tmp ; } public static void main ( String [ ] args ) { int n = 100000000 ; long strt = System . currentTimeMillis ( ) ; SoEInfHashMap sieve = new SoEInfHashMap ( ) ; int count = 0 ; while ( sieve . next ( ) <= n ) count ++ ; long elpsd = System . currentTimeMillis ( ) - strt ; System . out . println ( "Found " + count + " primes up to " + n + " in " + elpsd + " milliseconds." ) ; } } 
import java . util . Iterator ; import java . util . ArrayList ; public class SoEPagedOdds implements Iterator < Long > { private final int BFSZ = 1 << 16 ; private final int BFBTS = BFSZ * 32 ; private final int BFRNG = BFBTS * 2 ; private long bi = - 1 ; private long lowi = 0 ; private final ArrayList < Integer > bpa = new ArrayList < > ( ) ; private Iterator < Long > bps ; private final int [ ] buf = new int [ BFSZ ] ; @ Override public boolean hasNext ( ) { return true ; } @ Override public Long next ( ) { if ( this . bi < 1 ) { if ( this . bi < 0 ) { this . bi = 0 ; return 2L ; } long nxt = 3 + ( this . lowi << 1 ) + BFRNG ; if ( this . lowi <= 0 ) { for ( int i = 0 , p = 3 , sqr = 9 ; sqr < nxt ; i ++ , p += 2 , sqr = p * p ) if ( ( this . buf [ i > > > 5 ] & ( 1 << ( i & 31 ) ) ) == 0 ) for ( int j = ( sqr - 3 ) > > 1 ; j < BFBTS ; j += p ) this . buf [ j > > > 5 ] |= 1 << ( j & 31 ) ; } else { for ( int i = 0 ; i < this . buf . length ; i ++ ) this . buf [ i ] = 0 ; if ( this . bpa . isEmpty ( ) ) { this . bps = new SoEPagedOdds ( ) ; this . bps . next ( ) ; this . bpa . add ( this . bps . next ( ) . intValue ( ) ) ; } for ( long p = this . bpa . get ( this . bpa . size ( ) - 1 ) , sqr = p * p ; sqr < nxt ; p = this . bps . next ( ) , this . bpa . add ( ( int ) p ) , sqr = p * p ) ; for ( int i = 0 ; i < this . bpa . size ( ) - 1 ; i ++ ) { long p = this . bpa . get ( i ) ; long s = ( p * p - 3 ) > > > 1 ; if ( s >= this . lowi ) s -= this . lowi ; else { long r = ( this . lowi - s ) % p ; s = ( r != 0 ) ? p - r : 0 ; } for ( int j = ( int ) s ; j < BFBTS ; j += p ) this . buf [ j > > > 5 ] |= 1 << ( j & 31 ) ; } } } while ( ( this . bi < BFBTS ) && ( ( this . buf [ ( int ) this . bi > > > 5 ] & ( 1 << ( ( int ) this . bi & 31 ) ) ) != 0 ) ) this . bi ++ ; if ( this . bi < BFBTS ) return 3 + ( ( this . lowi + this . bi ++ ) << 1 ) ; else { this . bi = 0 ; this . lowi += BFBTS ; return this . next ( ) ; } } public static void main ( String [ ] args ) { long n = 1000000000 ; long strt = System . currentTimeMillis ( ) ; Iterator < Long > gen = new SoEPagedOdds ( ) ; int count = 0 ; while ( gen . next ( ) <= n ) count ++ ; long elpsd = System . currentTimeMillis ( ) - strt ; System . out . println ( "Found " + count + " primes up to " + n + " in " + elpsd + " milliseconds." ) ; } } 
class Singleton { private static Singleton myInstance ; public static Singleton getInstance ( ) { if ( myInstance == null ) { synchronized ( Singleton . class ) { if ( myInstance == null ) { myInstance = new Singleton ( ) ; } } } return myInstance ; } protected Singleton ( ) { } } 
public class Singleton { private Singleton ( ) { } private static class LazyHolder { private static final Singleton INSTANCE = new Singleton ( ) ; } public static Singleton getInstance ( ) { return LazyHolder . INSTANCE ; } } 
class Singleton { private static Singleton myInstance ; public static Singleton getInstance ( ) { if ( myInstance == null ) { myInstance = new Singleton ( ) ; } return myInstance ; } protected Singleton ( ) { } } 
import java . util . InputMismatchException ; import java . util . Scanner ; public class Sleep { public static void main ( final String [ ] args ) throws InterruptedException { try { int ms = new Scanner ( System . in ) . nextInt ( ) ; System . out . println ( "Sleeping..." ) ; Thread . sleep ( ms ) ; System . out . println ( "Awake!" ) ; } catch ( InputMismatchException inputMismatchException ) { System . err . println ( "Exception: " + inputMismatchException ) ; } } } 
import java . util . Arrays ; public class example { public static void main ( String [ ] args ) { int [ ] nums = { 2 , 4 , 3 , 1 , 2 } ; Arrays . sort ( nums ) ; } } 
import java . util . Arrays ; import java . util . Collections ; import java . util . List ; public class example { public static void main ( String [ ] args ) { List < Integer > nums = Arrays . asList ( 2 , 4 , 3 , 1 , 2 ) ; Collections . sort ( nums ) ; } } 
import java . util . Comparator ; import java . util . Arrays ; public class Test { public static void main ( String [ ] args ) { String [ ] strings = { "Here" , "are" , "some" , "sample" , "strings" , "to" , "be" , "sorted" } ; Arrays . sort ( strings , new Comparator < String > ( ) { public int compare ( String s1 , String s2 ) { int c = s2 . length ( ) - s1 . length ( ) ; if ( c == 0 ) c = s1 . compareToIgnoreCase ( s2 ) ; return c ; } } ) ; for ( String s : strings ) System . out . print ( s + " " ) ; } } 
import java . util . Comparator ; import java . util . Arrays ; public class ComparatorTest { public static void main ( String [ ] args ) { String [ ] strings = { "Here" , "are" , "some" , "sample" , "strings" , "to" , "be" , "sorted" } ; Arrays . sort ( strings , ( s1 , s2 ) -> { int c = s2 . length ( ) - s1 . length ( ) ; if ( c == 0 ) c = s1 . compareToIgnoreCase ( s2 ) ; return c ; } ) ; for ( String s : strings ) System . out . print ( s + " " ) ; } } 
public class BogoSort { public static void main ( String [ ] args ) { int [ ] arr = { 4 , 5 , 6 , 0 , 7 , 8 , 9 , 1 , 2 , 3 } ; BogoSort now = new BogoSort ( ) ; System . out . print ( "Unsorted: " ) ; now . display1D ( arr ) ; now . bogo ( arr ) ; System . out . print ( "Sorted: " ) ; now . display1D ( arr ) ; } void bogo ( int [ ] arr ) { int shuffle = 1 ; for ( ; ! isSorted ( arr ) ; shuffle ++ ) shuffle ( arr ) ; System . out . println ( "This took " + shuffle + " shuffles." ) ; } void shuffle ( int [ ] arr ) { int i = arr . length - 1 ; while ( i > 0 ) swap ( arr , i -- , ( int ) ( Math . random ( ) * i ) ) ; } void swap ( int [ ] arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } boolean isSorted ( int [ ] arr ) { for ( int i = 1 ; i < arr . length ; i ++ ) if ( arr [ i ] < arr [ i - 1 ] ) return false ; return true ; } void display1D ( int [ ] arr ) { for ( int i = 0 ; i < arr . length ; i ++ ) System . out . print ( arr [ i ] + " " ) ; System . out . println ( ) ; } } 
import java . util . Collections ; import java . util . List ; import java . util . Iterator ; public class Bogosort { private static < T extends Comparable < ? super T > > boolean isSorted ( List < T > list ) { if ( list . isEmpty ( ) ) return true ; Iterator < T > it = list . iterator ( ) ; T last = it . next ( ) ; while ( it . hasNext ( ) ) { T current = it . next ( ) ; if ( last . compareTo ( current ) > 0 ) return false ; last = current ; } return true ; } public static < T extends Comparable < ? super T > > void bogoSort ( List < T > list ) { while ( ! isSorted ( list ) ) Collections . shuffle ( list ) ; } } 
public static < E extends Comparable < ? super E > > void bubbleSort ( E [ ] comparable ) { boolean changed = false ; do { changed = false ; for ( int a = 0 ; a < comparable . length - 1 ; a ++ ) { if ( comparable [ a ] . compareTo ( comparable [ a + 1 ] ) > 0 ) { E tmp = comparable [ a ] ; comparable [ a ] = comparable [ a + 1 ] ; comparable [ a + 1 ] = tmp ; changed = true ; } } } while ( changed ) ; } 
if ( comparable [ a ] . compareTo ( comparable [ b ] ) < 0 ) { } 
public static void cocktailSort ( int [ ] A ) { boolean swapped ; do { swapped = false ; for ( int i = 0 ; i <= A . length - 2 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { int temp = A [ i ] ; A [ i ] = A [ i + 1 ] ; A [ i + 1 ] = temp ; swapped = true ; } } if ( ! swapped ) { break ; } swapped = false ; for ( int i = A . length - 2 ; i >= 0 ; i -- ) { if ( A [ i ] > A [ i + 1 ] ) { int temp = A [ i ] ; A [ i ] = A [ i + 1 ] ; A [ i + 1 ] = temp ; swapped = true ; } } } while ( swapped ) ; } 
public static < E extends Comparable < ? super E > > void sort ( E [ ] input ) { int gap = input . length ; boolean swapped = true ; while ( gap > 1 || swapped ) { if ( gap > 1 ) { gap = ( int ) ( gap / 1.3 ) ; } swapped = false ; for ( int i = 0 ; i + gap < input . length ; i ++ ) { if ( input [ i ] . compareTo ( input [ i + gap ] ) > 0 ) { E t = input [ i ] ; input [ i ] = input [ i + gap ] ; input [ i + gap ] = t ; swapped = true ; } } } } 
public static void countingSort ( int [ ] array , int min , int max ) { int [ ] count = new int [ max - min + 1 ] ; for ( int number : array ) { count [ number - min ] ++ ; } int z = 0 ; for ( int i = min ; i <= max ; i ++ ) { while ( count [ i - min ] > 0 ) { array [ z ] = i ; z ++ ; count [ i - min ] -- ; } } } 
public static void gnomeSort ( int [ ] a ) { int i = 1 ; int j = 2 ; while ( i < a . length ) { if ( a [ i - 1 ] <= a [ i ] ) { i = j ; j ++ ; } else { int tmp = a [ i - 1 ] ; a [ i - 1 ] = a [ i ] ; a [ i -- ] = tmp ; i = ( i == 0 ) ? j ++ : i ; } } } 
public static void insertSort ( int [ ] A ) { for ( int i = 1 ; i < A . length ; i ++ ) { int value = A [ i ] ; int j = i - 1 ; while ( j >= 0 && A [ j ] > value ) { A [ j + 1 ] = A [ j ] ; j = j - 1 ; } A [ j + 1 ] = value ; } } 
public static < E extends Comparable < ? super E > > void insertionSort ( List < E > a ) { for ( int i = 1 ; i < a . size ( ) ; i ++ ) { int j = Math . abs ( Collections . binarySearch ( a . subList ( 0 , i ) , a . get ( i ) ) + 1 ) ; Collections . rotate ( a . subList ( j , i + 1 ) , j - i ) ; } } public static < E extends Comparable < ? super E > > void insertionSort ( E [ ] a ) { for ( int i = 1 ; i < a . length ; i ++ ) { E x = a [ i ] ; int j = Math . abs ( Arrays . binarySearch ( a , 0 , i , x ) + 1 ) ; System . arraycopy ( a , j , a , j + 1 , i - j ) ; a [ j ] = x ; } } 
import java . util . List ; import java . util . ArrayList ; import java . util . Iterator ; public class Merge { public static < E extends Comparable < ? super E > > List < E > mergeSort ( List < E > m ) { if ( m . size ( ) <= 1 ) return m ; int middle = m . size ( ) / 2 ; List < E > left = m . subList ( 0 , middle ) ; List < E > right = m . subList ( middle , m . size ( ) ) ; right = mergeSort ( right ) ; left = mergeSort ( left ) ; List < E > result = merge ( left , right ) ; return result ; } public static < E extends Comparable < ? super E > > List < E > merge ( List < E > left , List < E > right ) { List < E > result = new ArrayList < E > ( ) ; Iterator < E > it1 = left . iterator ( ) ; Iterator < E > it2 = right . iterator ( ) ; E x = it1 . next ( ) ; E y = it2 . next ( ) ; while ( true ) { if ( x . compareTo ( y ) <= 0 ) { result . add ( x ) ; if ( it1 . hasNext ( ) ) { x = it1 . next ( ) ; } else { result . add ( y ) ; while ( it2 . hasNext ( ) ) { result . add ( it2 . next ( ) ) ; } break ; } } else { result . add ( y ) ; if ( it2 . hasNext ( ) ) { y = it2 . next ( ) ; } else { result . add ( x ) ; while ( it1 . hasNext ( ) ) { result . add ( it1 . next ( ) ) ; } break ; } } } return result ; } } 
public static < E extends Comparable < ? super E > > List < E > quickSort ( List < E > arr ) { if ( ! arr . isEmpty ( ) ) { E pivot = arr . get ( 0 ) ; List < E > less = new LinkedList < E > ( ) ; List < E > pivotList = new LinkedList < E > ( ) ; List < E > more = new LinkedList < E > ( ) ; for ( E i : arr ) { if ( i . compareTo ( pivot ) < 0 ) less . add ( i ) ; else if ( i . compareTo ( pivot ) > 0 ) more . add ( i ) ; else pivotList . add ( i ) ; } less = quickSort ( less ) ; more = quickSort ( more ) ; less . addAll ( pivotList ) ; less . addAll ( more ) ; return less ; } return arr ; } 
public static void sort ( int [ ] nums ) { for ( int currentPlace = 0 ; currentPlace < nums . length - 1 ; currentPlace ++ ) { int smallest = Integer . MAX_VALUE ; int smallestAt = currentPlace + 1 ; for ( int check = currentPlace ; check < nums . length ; check ++ ) { if ( nums [ check ] < smallest ) { smallestAt = check ; smallest = nums [ check ] ; } } int temp = nums [ currentPlace ] ; nums [ currentPlace ] = nums [ smallestAt ] ; nums [ smallestAt ] = temp ; } } 
public static void shell ( int [ ] a ) { int increment = a . length / 2 ; while ( increment > 0 ) { for ( int i = increment ; i < a . length ; i ++ ) { int j = i ; int temp = a [ i ] ; while ( j >= increment && a [ j - increment ] > temp ) { a [ j ] = a [ j - increment ] ; j = j - increment ; } a [ j ] = temp ; } if ( increment == 2 ) { increment = 1 ; } else { increment *= ( 5.0 / 11 ) ; } } } 
import java . util . Arrays ; public class Stooge { public static void main ( String [ ] args ) { int [ ] nums = { 1 , 4 , 5 , 3 , - 6 , 3 , 7 , 10 , - 2 , - 5 } ; stoogeSort ( nums ) ; System . out . println ( Arrays . toString ( nums ) ) ; } public static void stoogeSort ( int [ ] L ) { stoogeSort ( L , 0 , L . length - 1 ) ; } public static void stoogeSort ( int [ ] L , int i , int j ) { if ( L [ j ] < L [ i ] ) { int tmp = L [ i ] ; L [ i ] = L [ j ] ; L [ j ] = tmp ; } if ( j - i > 1 ) { int t = ( j - i + 1 ) / 3 ; stoogeSort ( L , i , j - t ) ; stoogeSort ( L , i + t , j ) ; stoogeSort ( L , i , j - t ) ; } } } 
import java . util . Stack ; public class StackTest { public static void main ( final String [ ] args ) { final Stack < String > stack = new Stack < String > ( ) ; System . out . println ( "New stack empty? " + stack . empty ( ) ) ; stack . push ( "There can be only one" ) ; System . out . println ( "Pushed stack empty? " + stack . empty ( ) ) ; System . out . println ( "Popped single entry: " + stack . pop ( ) ) ; stack . push ( "First" ) ; stack . push ( "Second" ) ; System . out . println ( "Popped entry should be second: " + stack . pop ( ) ) ; stack . pop ( ) ; stack . pop ( ) ; } } 
public class Stack { private Node first = null ; public boolean isEmpty ( ) { return first == null ; } public Object Pop ( ) { if ( isEmpty ( ) ) throw new Exception ( "Can't Pop from an empty Stack." ) ; else { Object temp = first . value ; first = first . next ; return temp ; } } public void Push ( Object o ) { first = new Node ( o , first ) ; } class Node { public Node next ; public Object value ; public Node ( Object value ) { this ( value , null ) ; } public Node ( Object value , Node next ) { this . next = next ; this . value = value ; } } } 
public class Stack < T > { private Node first = null ; public boolean isEmpty ( ) { return first == null ; } public T Pop ( ) { if ( isEmpty ( ) ) throw new Exception ( "Can't Pop from an empty Stack." ) ; else { T temp = first . value ; first = first . next ; return temp ; } } public void Push ( T o ) { first = new Node ( o , first ) ; } class Node { public Node next ; public T value ; public Node ( T value ) { this ( value , null ) ; } public Node ( T value , Node next ) { this . next = next ; this . value = value ; } } } 
String str = "alphaBETA" ; System . out . println ( str . toUpperCase ( ) ) ; System . out . println ( str . toLowerCase ( ) ) ; System . out . println ( . toUpperCase ( ) ) ; System . out . println ( . toLowerCase ( ) ) ; 
public class Str { public static void main ( String [ ] args ) { String s = "hello" ; System . out . println ( s + " literal" ) ; String s2 = s + " literal" ; System . out . println ( s2 ) ; } } 
String original = "Mary had a X lamb" ; String little = "little" ; String replaced = original . replace ( "X" , little ) ; System . out . println ( replaced ) ; System . out . printf ( "Mary had a %s lamb." , little ) ; String formatted = String . format ( "Mary had a %s lamb." , little ) ; System . out . println ( formatted ) ; 
String s = "Hello, world!" ; int byteCountUTF16 = s . getBytes ( "UTF-16" ) . length ; int byteCountUTF16LE = s . getBytes ( "UTF-16LE" ) . length ; int byteCountUTF8 = s . getBytes ( "UTF-8" ) . length ; 
String s = "Hello, world!" ; int not_really_the_length = s . length ( ) ; 
String str = ; int not_really__the_length = str . length ( ) ; int actual_length = str . codePointCount ( 0 , str . length ( ) ) ; 
import java . text . BreakIterator ; public class Grapheme { public static void main ( String [ ] args ) { printLength ( "mse" ) ; printLength ( ) ; printLength ( ) ; } public static void printLength ( String s ) { BreakIterator it = BreakIterator . getCharacterInstance ( ) ; it . setText ( s ) ; int count = 0 ; while ( it . next ( ) != BreakIterator . DONE ) { count ++ ; } System . out . println ( "Grapheme length: " + count + " " + s ) ; } } 
"abcd" . startsWith ( "ab" ) "abcd" . endsWith ( "zn" ) "abab" . contains ( "bb" ) "abab" . contains ( "ab" ) int loc = "abab" . indexOf ( "bb" ) loc = "abab" . indexOf ( "ab" ) loc = "abab" . indexOf ( "ab" , loc + 1 ) 
class StripChars { public static String stripChars ( String inString , String toStrip ) { return inString . replaceAll ( "[" + toStrip + "]" , "" ) ; } public static void main ( String [ ] args ) { String sentence = "She was a soul stripper. She took my heart!" ; String chars = "aei" ; System . out . println ( "sentence: " + sentence ) ; System . out . println ( "to strip: " + chars ) ; System . out . println ( "stripped: " + stripChars ( sentence , chars ) ) ; } } 
public class Trims { public static String ltrim ( String s ) { int i = 0 ; while ( i < s . length ( ) && Character . isWhitespace ( s . charAt ( i ) ) ) { i ++ ; } return s . substring ( i ) ; } public static String rtrim ( String s ) { int i = s . length ( ) - 1 ; while ( i > 0 && Character . isWhitespace ( s . charAt ( i ) ) ) { i -- ; } return s . substring ( 0 , i + 1 ) ; } public static void main ( String [ ] args ) { String s = " \t \r \n String with spaces  \t  \r  \n  " ; System . out . println ( ltrim ( s ) ) ; System . out . println ( rtrim ( s ) ) ; System . out . println ( s . trim ( ) ) ; } } 
public class RM_chars { public static void main ( String [ ] args ) { System . out . println ( "knight" . substring ( 1 ) ) ; System . out . println ( "socks" . substring ( 0 , 4 ) ) ; System . out . println ( "brooms" . substring ( 1 , 5 ) ) ; System . out . println ( "knight" . replaceAll ( "^." , "" ) ) ; System . out . println ( "socks" . replaceAll ( ".$" , "" ) ) ; System . out . println ( "brooms" . replaceAll ( "^.|.$" , "" ) ) ; } } 
String x = "testing123" ; System . out . println ( x . substring ( n , n + m ) ) ; System . out . println ( x . substring ( n ) ) ; System . out . println ( x . substring ( 0 , x . length ( ) - 1 ) ) ; int index1 = x . indexOf ( 'i' ) ; System . out . println ( x . substring ( index1 , index1 + m ) ) ; int index2 = x . indexOf ( "ing" ) ; System . out . println ( x . substring ( index2 , index2 + m ) ) ; 
public class Sudoku { private int mBoard [ ] [ ] ; private int mBoardSize ; private int mBoxSize ; private boolean mRowSubset [ ] [ ] ; private boolean mColSubset [ ] [ ] ; private boolean mBoxSubset [ ] [ ] ; public Sudoku ( int board [ ] [ ] ) { mBoard = board ; mBoardSize = mBoard . length ; mBoxSize = ( int ) Math . sqrt ( mBoardSize ) ; } public void initSubsets ( ) { mRowSubset = new boolean [ mBoardSize ] [ mBoardSize ] ; mColSubset = new boolean [ mBoardSize ] [ mBoardSize ] ; mBoxSubset = new boolean [ mBoardSize ] [ mBoardSize ] ; for ( int i = 0 ; i < mBoard . length ; i ++ ) { for ( int j = 0 ; j < mBoard . length ; j ++ ) { int value = mBoard [ i ] [ j ] ; if ( value != 0 ) { setSubsetValue ( i , j , value , true ) ; } } } } private void setSubsetValue ( int i , int j , int value , boolean present ) { mRowSubset [ i ] [ value - 1 ] = present ; mColSubset [ j ] [ value - 1 ] = present ; mBoxSubset [ computeBoxNo ( i , j ) ] [ value - 1 ] = present ; } public boolean solve ( ) { return solve ( 0 , 0 ) ; } public boolean solve ( int i , int j ) { if ( i == mBoardSize ) { i = 0 ; if ( ++ j == mBoardSize ) { return true ; } } if ( mBoard [ i ] [ j ] != 0 ) { return solve ( i + 1 , j ) ; } for ( int value = 1 ; value <= mBoardSize ; value ++ ) { if ( isValid ( i , j , value ) ) { mBoard [ i ] [ j ] = value ; setSubsetValue ( i , j , value , true ) ; if ( solve ( i + 1 , j ) ) { return true ; } setSubsetValue ( i , j , value , false ) ; } } mBoard [ i ] [ j ] = 0 ; return false ; } private boolean isValid ( int i , int j , int val ) { val -- ; boolean isPresent = mRowSubset [ i ] [ val ] || mColSubset [ j ] [ val ] || mBoxSubset [ computeBoxNo ( i , j ) ] [ val ] ; return ! isPresent ; } private int computeBoxNo ( int i , int j ) { int boxRow = i / mBoxSize ; int boxCol = j / mBoxSize ; return boxRow * mBoxSize + boxCol ; } public void print ( ) { for ( int i = 0 ; i < mBoardSize ; i ++ ) { if ( i % mBoxSize == 0 ) { System . out . println ( " -----------------------" ) ; } for ( int j = 0 ; j < mBoardSize ; j ++ ) { if ( j % mBoxSize == 0 ) { System . out . print ( "| " ) ; } System . out . print ( mBoard [ i ] [ j ] != 0 ? ( ( Object ) ( Integer . valueOf ( mBoard [ i ] [ j ] ) ) ) : " " ) ; System . out . print ( ' ' ) ; } System . out . println ( "|" ) ; } System . out . println ( " -----------------------" ) ; } } 
public class SumProd { public static void main ( final String [ ] args ) { int sum = 0 ; int prod = 1 ; int [ ] arg = { 1 , 2 , 3 , 4 , 5 } ; for ( int i : arg ) { sum += i ; prod *= i ; } } } 
import java . util . Arrays ; public class SumProd { public static void main ( final String [ ] args ) { int [ ] arg = { 1 , 2 , 3 , 4 , 5 } ; System . out . printf ( "sum = %d\n" , Arrays . stream ( arg ) . sum ( ) ) ; System . out . printf ( "sum = %d\n" , Arrays . stream ( arg ) . reduce ( 0 , ( a , b ) -> a + b ) ) ; System . out . printf ( "product = %d\n" , Arrays . stream ( arg ) . reduce ( 1 , ( a , b ) -> a * b ) ) ; } } 
import java . math . BigInteger ; public class SumDigits { public static int sumDigits ( long num ) { return sumDigits ( num , 10 ) ; } public static int sumDigits ( long num , int base ) { String s = Long . toString ( num , base ) ; int result = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) result += Character . digit ( s . charAt ( i ) , base ) ; return result ; } public static int sumDigits ( BigInteger num ) { return sumDigits ( num , 10 ) ; } public static int sumDigits ( BigInteger num , int base ) { String s = num . toString ( base ) ; int result = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) result += Character . digit ( s . charAt ( i ) , base ) ; return result ; } public static void main ( String [ ] args ) { System . out . println ( sumDigits ( 1 ) ) ; System . out . println ( sumDigits ( 12345 ) ) ; System . out . println ( sumDigits ( 123045 ) ) ; System . out . println ( sumDigits ( 0xfe , 16 ) ) ; System . out . println ( sumDigits ( 0xf0e , 16 ) ) ; System . out . println ( sumDigits ( new BigInteger ( "12345678901234567890" ) ) ) ; } } 
public class Sum { public static double f ( double x ) { return 1 / ( x * x ) ; } public static void main ( String [ ] args ) { double start = 1 ; double end = 1000 ; double sum = 0 ; for ( double x = start ; x <= end ; x ++ ) sum += f ( x ) ; System . out . println ( "Sum of f(x) from " + start + " to " + end + " is " + sum ) ; } } 
public class SumSquares { public static void main ( final String [ ] args ) { double sum = 0 ; int [ ] nums = { 1 , 2 , 3 , 4 , 5 } ; for ( int i : nums ) sum += i * i ; System . out . println ( "The sum of the squares is: " + sum ) ; } } 
import java . util . Arrays ; import java . util . HashSet ; import java . util . Set ; public class SymmetricDifference { public static void main ( String [ ] args ) { Set < String > setA = new HashSet < String > ( Arrays . asList ( "John" , "Serena" , "Bob" , "Mary" , "Serena" ) ) ; Set < String > setB = new HashSet < String > ( Arrays . asList ( "Jim" , "Mary" , "John" , "Jim" , "Bob" ) ) ; System . out . println ( "In set A: " + setA ) ; System . out . println ( "In set B: " + setB ) ; Set < String > notInSetA = new HashSet < String > ( setB ) ; notInSetA . removeAll ( setA ) ; Set < String > notInSetB = new HashSet < String > ( setA ) ; notInSetB . removeAll ( setB ) ; Set < String > symmetricDifference = new HashSet < String > ( notInSetA ) ; symmetricDifference . addAll ( notInSetB ) ; Set < String > union = new HashSet < String > ( setA ) ; union . addAll ( setB ) ; Set < String > intersection = new HashSet < String > ( setA ) ; intersection . retainAll ( setB ) ; Set < String > symmetricDifference2 = new HashSet < String > ( union ) ; symmetricDifference2 . removeAll ( intersection ) ; System . out . println ( "Not in set A: " + notInSetA ) ; System . out . println ( "Not in set B: " + notInSetB ) ; System . out . println ( "Symmetric Difference: " + symmetricDifference ) ; System . out . println ( "Symmetric Difference 2: " + symmetricDifference2 ) ; } } 
public class SystemTime { public static void main ( String [ ] args ) { System . out . format ( "%tc%n" , System . currentTimeMillis ( ) ) ; } } 
import java . util . Date ; public class SystemTime { public static void main ( String [ ] args ) { Date now = new Date ( ) ; System . out . println ( now ) ; System . out . println ( now . getTime ( ) ) ; } } 
import java . io . * ; import java . nio . channels . * ; import java . util . Date ; public class TakeNotes { public static void main ( String [ ] args ) throws IOException { if ( args . length > 0 ) { PrintStream ps = new PrintStream ( new FileOutputStream ( "notes.txt" , true ) ) ; ps . println ( new Date ( ) ) ; ps . print ( "\t" + args [ 0 ] ) ; for ( int i = 1 ; i < args . length ; i ++ ) ps . print ( " " + args [ i ] ) ; ps . println ( ) ; ps . close ( ) ; } else { FileChannel fc = new FileInputStream ( "notes.txt" ) . getChannel ( ) ; fc . transferTo ( 0 , fc . size ( ) , Channels . newChannel ( System . out ) ) ; fc . close ( ) ; } } } 
public class TemperatureConversion { public static void main ( String args [ ] ) { if ( args . length == 1 ) { try { double kelvin = Double . parseDouble ( args [ 0 ] ) ; if ( kelvin >= 0 ) { System . out . printf ( "K  %2.2f\n" , kelvin ) ; System . out . printf ( "C  %2.2f\n" , kelvinToCelsius ( kelvin ) ) ; System . out . printf ( "F  %2.2f\n" , kelvinToFahrenheit ( kelvin ) ) ; System . out . printf ( "R  %2.2f\n" , kelvinToRankine ( kelvin ) ) ; } else { System . out . printf ( "%2.2f K is below absolute zero" , kelvin ) ; } } catch ( NumberFormatException e ) { System . out . println ( e ) ; } } } public static double kelvinToCelsius ( double k ) { return k + 273.15 ; } public static double kelvinToFahrenheit ( double k ) { return k * 1.8 - 459.67 ; } public static double kelvinToRankine ( double k ) { return k * 1.8 ; } } 
public class Logic { public static enum Trit { TRUE , MAYBE , FALSE ; public Trit and ( Trit other ) { if ( this == TRUE ) { return other ; } else if ( this == MAYBE ) { return ( other == FALSE ) ? FALSE : MAYBE ; } else { return FALSE ; } } public Trit or ( Trit other ) { if ( this == TRUE ) { return TRUE ; } else if ( this == MAYBE ) { return ( other == TRUE ) ? TRUE : MAYBE ; } else { return other ; } } public Trit tIf ( Trit other ) { if ( this == TRUE ) { return other ; } else if ( this == MAYBE ) { return ( other == TRUE ) ? TRUE : MAYBE ; } else { return TRUE ; } } public Trit not ( ) { if ( this == TRUE ) { return FALSE ; } else if ( this == MAYBE ) { return MAYBE ; } else { return TRUE ; } } public Trit equals ( Trit other ) { if ( this == TRUE ) { return other ; } else if ( this == MAYBE ) { return MAYBE ; } else { return other . not ( ) ; } } } public static void main ( String [ ] args ) { for ( Trit a : Trit . values ( ) ) { System . out . println ( "not " + a + ": " + a . not ( ) ) ; } for ( Trit a : Trit . values ( ) ) { for ( Trit b : Trit . values ( ) ) { System . out . println ( a + " and " + b + ": " + a . and ( b ) + "\t " + a + " or " + b + ": " + a . or ( b ) + "\t " + a + " implies " + b + ": " + a . tIf ( b ) + "\t " + a + " = " + b + ": " + a . equals ( b ) ) ; } } } } 
import java . util . * ; import java . util . regex . * ; import java . io . * ; public class DataMunging2 { public static final Pattern e = Pattern . compile ( "\\s+" ) ; public static void main ( String [ ] args ) { try { BufferedReader infile = new BufferedReader ( new FileReader ( args [ 0 ] ) ) ; List < String > duplicates = new ArrayList < String > ( ) ; Set < String > datestamps = new HashSet < String > ( ) ; String eingabe ; int all_ok = 0 ; while ( ( eingabe = infile . readLine ( ) ) != null ) { String [ ] fields = e . split ( eingabe ) ; if ( fields . length != 49 ) System . out . println ( "Format not ok!" ) ; if ( datestamps . add ( fields [ 0 ] ) ) { int howoften = ( fields . length - 1 ) / 2 ; for ( int n = 1 ; Integer . parseInt ( fields [ 2 * n ] ) >= 1 ; n ++ ) { if ( n == howoften ) { all_ok ++ ; break ; } } } else { duplicates . add ( fields [ 0 ] ) ; } } infile . close ( ) ; System . out . println ( "The following " + duplicates . size ( ) + " datestamps were duplicated:" ) ; for ( String x : duplicates ) System . out . println ( x ) ; System . out . println ( all_ok + " records were complete and ok!" ) ; } catch ( IOException e ) { System . err . println ( "Can't open file " + args [ 0 ] ) ; System . exit ( 1 ) ; } } } 
import java . io . BufferedReader ; import java . io . FileNotFoundException ; import java . io . FileReader ; import java . io . IOException ; import java . util . LinkedList ; public class License { public static void main ( String [ ] args ) throws FileNotFoundException , IOException { BufferedReader in = new BufferedReader ( new FileReader ( args [ 0 ] ) ) ; int max = Integer . MIN_VALUE ; LinkedList < String > dates = new LinkedList < String > ( ) ; String line ; int count = 0 ; while ( ( line = in . readLine ( ) ) != null ) { if ( line . startsWith ( "License OUT " ) ) count ++ ; if ( line . startsWith ( "License IN " ) ) count -- ; if ( count > max ) { max = count ; String date = line . split ( " " ) [ 3 ] ; dates . clear ( ) ; dates . add ( date ) ; } else if ( count == max ) { String date = line . split ( " " ) [ 3 ] ; dates . add ( date ) ; } } System . out . println ( "Max licenses out: " + max ) ; System . out . println ( "At time(s): " + dates ) ; } } 
public class TwelveDaysOfChristmas { final static String [ ] gifts = { "A partridge in a pear tree." , "Two turtle doves and" , "Three french hens" , "Four calling birds" , "Five golden rings" , "Six geese a-laying" , "Seven swans a-swimming" , "Eight maids a-milking" , "Nine ladies dancing" , "Ten lords a-leaping" , "Eleven pipers piping" , "Twelve drummers drumming" , "And a partridge in a pear tree." , "Two turtle doves" } ; final static String [ ] days = { "first" , "second" , "third" , "fourth" , "fifth" , "sixth" , "seventh" , "eighth" , "ninth" , "tenth" , "eleventh" , "Twelfth" } ; public static void main ( String [ ] args ) { for ( int i = 0 ; i < days . length ; i ++ ) { System . out . printf ( "%nOn the %s day of Christmas%n" , days [ i ] ) ; System . out . println ( "My true love gave to me:" ) ; for ( int j = i ; j >= 0 ; j -- ) System . out . println ( gifts [ i == 11 && j < 2 ? j + 12 : j ] ) ; } } } 
String toTokenize = "Hello,How,Are,You,Today" ; System . out . println ( String . join ( "." , toTokenize . split ( "," ) ) ) ; 
String toTokenize = "Hello,How,Are,You,Today" ; String words [ ] = toTokenize . split ( "," ) ; for ( int i = 0 ; i < words . length ; i ++ ) { System . out . print ( words [ i ] + "." ) ; } 
String toTokenize = "Hello,How,Are,You,Today" ; StringTokenizer tokenizer = new StringTokenizer ( toTokenize , "," ) ; while ( tokenizer . hasMoreTokens ( ) ) { System . out . print ( tokenizer . nextToken ( ) + "." ) ; } 
import java . io . File ; import java . util . * ; public class TopRankPerGroup { private static class Employee { final String name ; final String id ; final String department ; final int salary ; Employee ( String [ ] rec ) { name = rec [ 0 ] ; id = rec [ 1 ] ; salary = Integer . parseInt ( rec [ 2 ] ) ; department = rec [ 3 ] ; } @ Override public String toString ( ) { return String . format ( "%s %s %d %s" , id , name , salary , department ) ; } } public static void main ( String [ ] args ) throws Exception { int N = args . length > 0 ? Integer . parseInt ( args [ 0 ] ) : 3 ; Map < String , List < Employee > > records = new TreeMap < > ( ) ; try ( Scanner sc = new Scanner ( new File ( "data.txt" ) ) ) { while ( sc . hasNextLine ( ) ) { String [ ] rec = sc . nextLine ( ) . trim ( ) . split ( ", " ) ; List < Employee > lst = records . get ( rec [ 3 ] ) ; if ( lst == null ) { lst = new ArrayList < > ( ) ; records . put ( rec [ 3 ] , lst ) ; } lst . add ( new Employee ( rec ) ) ; } } records . forEach ( ( key , val ) -> { System . out . printf ( "%nDepartment %s%n" , key ) ; val . stream ( ) . sorted ( ( a , b ) -> Integer . compare ( b . salary , a . salary ) ) . limit ( N ) . forEach ( System . out :: println ) ; } ) ; } } 
public void move ( int n , int from , int to , int via ) { if ( n == 1 ) { System . out . println ( "Move disk from pole " + from + " to pole " + to ) ; } else { move ( n - 1 , from , via , to ) ; move ( 1 , from , to , via ) ; move ( n - 1 , via , to , from ) ; } } 
import java . util . * ; public class TreeTraversal { static class Node < T > { T value ; Node < T > left ; Node < T > right ; Node ( T value ) { this . value = value ; } void visit ( ) { System . out . print ( this . value + " " ) ; } } static enum ORDER { PREORDER , INORDER , POSTORDER , LEVEL } static void traverse ( Node < ? > node , ORDER order ) { if ( node == null ) { return ; } switch ( order ) { case PREORDER : node . visit ( ) ; traverse ( node . left , order ) ; traverse ( node . right , order ) ; break ; case INORDER : traverse ( node . left , order ) ; node . visit ( ) ; traverse ( node . right , order ) ; break ; case POSTORDER : traverse ( node . left , order ) ; traverse ( node . right , order ) ; node . visit ( ) ; break ; case LEVEL : Queue < Node < ? > > queue = new LinkedList < > ( ) ; queue . add ( node ) ; while ( ! queue . isEmpty ( ) ) { Node < ? > next = queue . remove ( ) ; next . visit ( ) ; if ( next . left != null ) queue . add ( next . left ) ; if ( next . right != null ) queue . add ( next . right ) ; } } } public static void main ( String [ ] args ) { Node < Integer > one = new Node < Integer > ( 1 ) ; Node < Integer > two = new Node < Integer > ( 2 ) ; Node < Integer > three = new Node < Integer > ( 3 ) ; Node < Integer > four = new Node < Integer > ( 4 ) ; Node < Integer > five = new Node < Integer > ( 5 ) ; Node < Integer > six = new Node < Integer > ( 6 ) ; Node < Integer > seven = new Node < Integer > ( 7 ) ; Node < Integer > eight = new Node < Integer > ( 8 ) ; Node < Integer > nine = new Node < Integer > ( 9 ) ; one . left = two ; one . right = three ; two . left = four ; two . right = five ; three . left = six ; four . left = seven ; six . left = eight ; six . right = nine ; traverse ( one , ORDER . PREORDER ) ; System . out . println ( ) ; traverse ( one , ORDER . INORDER ) ; System . out . println ( ) ; traverse ( one , ORDER . POSTORDER ) ; System . out . println ( ) ; traverse ( one , ORDER . LEVEL ) ; } } 
public class Trig { public static void main ( String [ ] args ) { double radians = Math . PI / 4 ; double degrees = 45.0 ; System . out . println ( Math . sin ( radians ) + " " + Math . sin ( Math . toRadians ( degrees ) ) ) ; System . out . println ( Math . cos ( radians ) + " " + Math . cos ( Math . toRadians ( degrees ) ) ) ; System . out . println ( Math . tan ( radians ) + " " + Math . tan ( Math . toRadians ( degrees ) ) ) ; double arcsin = Math . asin ( Math . sin ( radians ) ) ; System . out . println ( arcsin + " " + Math . toDegrees ( arcsin ) ) ; double arccos = Math . acos ( Math . cos ( radians ) ) ; System . out . println ( arccos + " " + Math . toDegrees ( arccos ) ) ; double arctan = Math . atan ( Math . tan ( radians ) ) ; System . out . println ( arctan + " " + Math . toDegrees ( arctan ) ) ; } } 
import java . io . UnsupportedEncodingException ; import java . net . URLDecoder ; public class Main { public static void main ( String [ ] args ) throws UnsupportedEncodingException { String encoded = "http%3A%2F%2Ffoo%20bar%2F" ; String normal = URLDecoder . decode ( encoded , "utf-8" ) ; System . out . println ( normal ) ; } } 
import java . io . UnsupportedEncodingException ; import java . net . URLEncoder ; public class Main { public static void main ( String [ ] args ) throws UnsupportedEncodingException { String normal = "http://foo bar/" ; String encoded = URLEncoder . encode ( normal , "utf-8" ) ; System . out . println ( encoded ) ; } } 
package rosetta ; import java . io . IOException ; import java . io . PrintStream ; import java . nio . file . DirectoryStream ; import java . nio . file . Files ; import java . nio . file . Path ; import java . nio . file . Paths ; public class UnixLS { public static void main ( String [ ] args ) throws IOException { UnixLS ls = new UnixLS ( ) ; ls . list ( System . out ) ; } private void list ( PrintStream out ) throws IOException { try ( DirectoryStream < Path > stream = Files . newDirectoryStream ( Paths . get ( "." ) ) ) { stream . forEach ( ( path ) -> out . println ( path . getFileName ( ) ) ) ; } } } 
import java . util . Scanner ; public class GetInput { public static void main ( String [ ] args ) throws Exception { Scanner s = new Scanner ( System . in ) ; System . out . print ( "Enter a string: " ) ; String str = s . nextLine ( ) ; System . out . print ( "Enter an integer: " ) ; int i = Integer . parseInt ( s . next ( ) ) ; } } 
import java . util . Scanner ; public class GetInput { public static void main ( String [ ] args ) { Scanner stdin = new Scanner ( System . in ) ; String string = stdin . nextLine ( ) ; int number = stdin . nextInt ( ) ; } } 
public static void printAll ( Object ... things ) { for ( Object i : things ) { System . out . println ( i ) ; } } 
printAll ( 4 , 3 , 5 , 6 , 4 , 3 ) ; printAll ( 4 , 3 , 5 ) ; printAll ( "Rosetta" , "Code" , "Is" , "Awesome!" ) ; 
Object [ ] args = { "Rosetta" , "Code" , "Is" , "Awesome!" } ; printAll ( args ) ; 
Object [ ] args = { "Rosetta" , "Code" , "Is" , "Awesome," } ; printAll ( args , "Dude!" ) ; 
printAll ( ( Object ) args ) ; 
public class VectorProds { public static class Vector3D < T extends Number > { private T a , b , c ; public Vector3D ( T a , T b , T c ) { this . a = a ; this . b = b ; this . c = c ; } public double dot ( Vector3D < ? > vec ) { return ( a . doubleValue ( ) * vec . a . doubleValue ( ) + b . doubleValue ( ) * vec . b . doubleValue ( ) + c . doubleValue ( ) * vec . c . doubleValue ( ) ) ; } public Vector3D < Double > cross ( Vector3D < ? > vec ) { Double newA = b . doubleValue ( ) * vec . c . doubleValue ( ) - c . doubleValue ( ) * vec . b . doubleValue ( ) ; Double newB = c . doubleValue ( ) * vec . a . doubleValue ( ) - a . doubleValue ( ) * vec . c . doubleValue ( ) ; Double newC = a . doubleValue ( ) * vec . b . doubleValue ( ) - b . doubleValue ( ) * vec . a . doubleValue ( ) ; return new Vector3D < Double > ( newA , newB , newC ) ; } public double scalTrip ( Vector3D < ? > vecB , Vector3D < ? > vecC ) { return this . dot ( vecB . cross ( vecC ) ) ; } public Vector3D < Double > vecTrip ( Vector3D < ? > vecB , Vector3D < ? > vecC ) { return this . cross ( vecB . cross ( vecC ) ) ; } @ Override public String toString ( ) { return "<" + a . toString ( ) + ", " + b . toString ( ) + ", " + c . toString ( ) + ">" ; } } public static void main ( String [ ] args ) { Vector3D < Integer > a = new Vector3D < Integer > ( 3 , 4 , 5 ) ; Vector3D < Integer > b = new Vector3D < Integer > ( 4 , 3 , 5 ) ; Vector3D < Integer > c = new Vector3D < Integer > ( - 5 , - 12 , - 13 ) ; System . out . println ( a . dot ( b ) ) ; System . out . println ( a . cross ( b ) ) ; System . out . println ( a . scalTrip ( b , c ) ) ; System . out . println ( a . vecTrip ( b , c ) ) ; } } 
import java . util . Arrays ; import java . util . stream . IntStream ; public class VectorsOp { private static int dotProduct ( int [ ] v1 , int [ ] v2 , int length ) { int result = IntStream . range ( 0 , length ) . parallel ( ) . map ( id -> v1 [ id ] * v2 [ id ] ) . reduce ( 0 , Integer :: sum ) ; return result ; } private static int [ ] crossProduct ( int [ ] v1 , int [ ] v2 , int length ) { int result [ ] = new int [ length ] ; result = IntStream . range ( 0 , length ) . parallel ( ) . map ( i -> v1 [ ( i + 1 ) % length ] * v2 [ ( i + 2 ) % length ] - v1 [ ( i + 2 ) % length ] * v2 [ ( i + 1 ) % length ] ) . toArray ( ) ; return result ; } public static void main ( String [ ] args ) { int [ ] vect1 = { 3 , 4 , 5 } ; int [ ] vect2 = { 4 , 3 , 5 } ; int [ ] vect3 = { - 5 , - 12 , - 13 } ; System . out . println ( "dot product =:" + dotProduct ( vect1 , vect2 , 3 ) ) ; int [ ] prodvect = new int [ 3 ] ; prodvect = crossProduct ( vect1 , vect2 , 3 ) ; System . out . println ( "cross product =:[" + prodvect [ 0 ] + "," + prodvect [ 1 ] + "," + prodvect [ 2 ] + "]" ) ; prodvect = crossProduct ( vect2 , vect3 , 3 ) ; System . out . println ( "scalar product =:" + dotProduct ( vect1 , prodvect , 3 ) ) ; prodvect = crossProduct ( vect1 , prodvect , 3 ) ; System . out . println ( "triple product =:[" + prodvect [ 0 ] + "," + prodvect [ 1 ] + "," + prodvect [ 2 ] + "]" ) ; } } 
public class VigenereCipher { public static void main ( String [ ] args ) { String key = "VIGENERECIPHER" ; String ori = "Beware the Jabberwock, my son! The jaws that bite, the claws that catch!" ; String enc = encrypt ( ori , key ) ; System . out . println ( enc ) ; System . out . println ( decrypt ( enc , key ) ) ; } static String encrypt ( String text , final String key ) { String res = "" ; text = text . toUpperCase ( ) ; for ( int i = 0 , j = 0 ; i < text . length ( ) ; i ++ ) { char c = text . charAt ( i ) ; if ( c < 'A' || c > 'Z' ) continue ; res += ( char ) ( ( c + key . charAt ( j ) - 2 * 'A' ) % 26 + 'A' ) ; j = ++ j % key . length ( ) ; } return res ; } static String decrypt ( String text , final String key ) { String res = "" ; text = text . toUpperCase ( ) ; for ( int i = 0 , j = 0 ; i < text . length ( ) ; i ++ ) { char c = text . charAt ( i ) ; if ( c < 'A' || c > 'Z' ) continue ; res += ( char ) ( ( c - key . charAt ( j ) + 26 ) % 26 + 'A' ) ; j = ++ j % key . length ( ) ; } return res ; } } 
File dir = new File ( "/foo/bar" ) ; String [ ] contents = dir . list ( ) ; for ( String file : contents ) if ( file . endsWith ( ".mp3" ) ) System . out . println ( file ) ; 
import java . io . File ; public class MainEntry { public static void main ( String [ ] args ) { walkin ( new File ( "/home/user" ) ) ; } public static void walkin ( File dir ) { String pattern = ".mp3" ; File listFile [ ] = dir . listFiles ( ) ; if ( listFile != null ) { for ( int i = 0 ; i < listFile . length ; i ++ ) { if ( listFile [ i ] . isDirectory ( ) ) { walkin ( listFile [ i ] ) ; } else { if ( listFile [ i ] . getName ( ) . endsWith ( pattern ) ) { System . out . println ( listFile [ i ] . getPath ( ) ) ; } } } } } } 
import java . io . IOException ; import java . nio . file . * ; import java . nio . file . attribute . BasicFileAttributes ; public class WalkTree { public static void main ( String [ ] args ) throws IOException { Path start = FileSystems . getDefault ( ) . getPath ( "/path/to/file" ) ; Files . walkFileTree ( start , new SimpleFileVisitor < Path > ( ) { @ Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { if ( file . toString ( ) . endsWith ( ".mp3" ) ) { System . out . println ( file ) ; } return FileVisitResult . CONTINUE ; } } ) ; } } 
import java . io . IOException ; import java . nio . file . * ; public class WalkTree { public static void main ( String [ ] args ) throws IOException { Path start = FileSystems . getDefault ( ) . getPath ( "/path/to/file" ) ; Files . walk ( start ) . filter ( path -> path . toFile ( ) . isFile ( ) ) . filter ( path -> path . toString ( ) . endsWith ( ".mp3" ) ) . forEach ( System . out :: println ) ; } } 
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . net . URL ; import java . net . URLConnection ; public class WebTime { public static void main ( String [ ] args ) { try { URL address = new URL ( "http://tycho.usno.navy.mil/cgi-bin/timer.pl" ) ; URLConnection conn = address . openConnection ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( conn . getInputStream ( ) ) ) ; String line ; while ( ! ( line = in . readLine ( ) ) . contains ( "UTC" ) ) ; System . out . println ( line . substring ( 4 ) ) ; } catch ( IOException e ) { System . err . println ( "error connecting to server." ) ; e . printStackTrace ( ) ; } } } 
import java . io . IOException ; import java . io . StringReader ; import org . xml . sax . Attributes ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . DefaultHandler ; import org . xml . sax . helpers . XMLReaderFactory ; public class StudentHandler extends DefaultHandler { public static void main ( String [ ] args ) throws Exception { String xml = "<Students>\n" + "<Student Name=\"April\" Gender=\"F\" DateOfBirth=\"1989-01-02\" />\n" + "<Student Name=\"Bob\" Gender=\"M\"  DateOfBirth=\"1990-03-04\" />\n" + "<Student Name=\"Chad\" Gender=\"M\"  DateOfBirth=\"1991-05-06\" />\n" + "<Student Name=\"Dave\" Gender=\"M\"  DateOfBirth=\"1992-07-08\">\n" + "  <Pet Type=\"dog\" Name=\"Rover\" />\n" + "</Student>\n" + "<Student DateOfBirth=\"1993-09-10\" Gender=\"F\" Name=\"&#x00C9;mily\" />\n" + "</Students>" ; StudentHandler handler = new StudentHandler ( ) ; handler . parse ( new InputSource ( new StringReader ( xml ) ) ) ; } public void parse ( InputSource src ) throws SAXException , IOException { XMLReader parser = XMLReaderFactory . createXMLReader ( ) ; parser . setContentHandler ( this ) ; parser . parse ( src ) ; } @ Override public void characters ( char [ ] ch , int start , int length ) throws SAXException { super . characters ( ch , start , length ) ; } @ Override public void endElement ( String uri , String localName , String qName ) throws SAXException { super . endElement ( uri , localName , qName ) ; } @ Override public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { if ( qName . equals ( "Student" ) ) { System . out . println ( attributes . getValue ( "Name" ) ) ; } } } 
import java . io . StringReader ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . xpath . XPath ; import javax . xml . xpath . XPathConstants ; import javax . xml . xpath . XPathFactory ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . xml . sax . InputSource ; public class XMLParser { final static String xmlStr = "<inventory title=\"OmniCorp Store #45x10^3\">" + "  <section name=\"health\">" + "    <item upc=\"123456789\" stock=\"12\">" + "      <name>Invisibility Cream</name>" + "      <price>14.50</price>" + "      <description>Makes you invisible</description>" + "    </item>" + "    <item upc=\"445322344\" stock=\"18\">" + "      <name>Levitation Salve</name>" + "      <price>23.99</price>" + "      <description>Levitate yourself for up to 3 hours per application</description>" + "    </item>" + "  </section>" + "  <section name=\"food\">" + "    <item upc=\"485672034\" stock=\"653\">" + "      <name>Blork and Freen Instameal</name>" + "      <price>4.95</price>" + "      <description>A tasty meal in a tablet; just add water</description>" + "    </item>" + "    <item upc=\"132957764\" stock=\"44\">" + "      <name>Grob winglets</name>" + "      <price>3.56</price>" + "      <description>Tender winglets of Grob. Just add priwater</description>" + "    </item>" + "  </section>" + "</inventory>" ; public static void main ( String [ ] args ) { try { Document doc = DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) . parse ( new InputSource ( new StringReader ( xmlStr ) ) ) ; XPath xpath = XPathFactory . newInstance ( ) . newXPath ( ) ; System . out . println ( ( ( Node ) xpath . evaluate ( "/inventory/section/item[1]" , doc , XPathConstants . NODE ) ) . getAttributes ( ) . getNamedItem ( "upc" ) ) ; NodeList nodes = ( NodeList ) xpath . evaluate ( "/inventory/section/item/price" , doc , XPathConstants . NODESET ) ; for ( int i = 0 ; i < nodes . getLength ( ) ; i ++ ) System . out . println ( nodes . item ( i ) . getTextContent ( ) ) ; } catch ( Exception e ) { System . out . println ( "Error ocurred while parsing XML." ) ; } } } 
import java . util . function . Function ; public interface YCombinator { interface RecursiveFunction < F > extends Function < RecursiveFunction < F > , F > { } public static < A , B > Function < A , B > Y ( Function < Function < A , B > , Function < A , B > > f ) { RecursiveFunction < Function < A , B > > r = w -> f . apply ( x -> w . apply ( w ) . apply ( x ) ) ; return r . apply ( r ) ; } public static void main ( String ... arguments ) { Function < Integer , Integer > fib = Y ( f -> n -> ( n <= 2 ) ? 1 : ( f . apply ( n - 1 ) + f . apply ( n - 2 ) ) ) ; Function < Integer , Integer > fac = Y ( f -> n -> ( n <= 1 ) ? 1 : ( n * f . apply ( n - 1 ) ) ; ) ; System . out . println ( "fib(10) = " + fib . apply ( 10 ) ) ; System . out . println ( "fac(10) = " + fac . apply ( 10 ) ) ; } } 
public static < A , B > Function < A , B > Y ( Function < Function < A , B > , Function < A , B > > f ) { return x -> f . apply ( Y ( f ) ) . apply ( x ) ; } 
public static < A , B > Function < A , B > Y ( Function < Function < A , B > , Function < A , B > > f ) { return new Function < A , B > ( ) { public B apply ( A x ) { return f . apply ( this ) . apply ( x ) ; } } ; } 
interface Function < A , B > { public B call ( A x ) ; } public class YCombinator { interface RecursiveFunc < F > extends Function < RecursiveFunc < F > , F > { } public static < A , B > Function < A , B > fix ( final Function < Function < A , B > , Function < A , B > > f ) { RecursiveFunc < Function < A , B > > r = new RecursiveFunc < Function < A , B > > ( ) { public Function < A , B > call ( final RecursiveFunc < Function < A , B > > w ) { return f . call ( new Function < A , B > ( ) { public B call ( A x ) { return w . call ( w ) . call ( x ) ; } } ) ; } } ; return r . call ( r ) ; } public static void main ( String [ ] args ) { Function < Function < Integer , Integer > , Function < Integer , Integer > > almost_fib = new Function < Function < Integer , Integer > , Function < Integer , Integer > > ( ) { public Function < Integer , Integer > call ( final Function < Integer , Integer > f ) { return new Function < Integer , Integer > ( ) { public Integer call ( Integer n ) { if ( n <= 2 ) return 1 ; return f . call ( n - 1 ) + f . call ( n - 2 ) ; } } ; } } ; Function < Function < Integer , Integer > , Function < Integer , Integer > > almost_fac = new Function < Function < Integer , Integer > , Function < Integer , Integer > > ( ) { public Function < Integer , Integer > call ( final Function < Integer , Integer > f ) { return new Function < Integer , Integer > ( ) { public Integer call ( Integer n ) { if ( n <= 1 ) return 1 ; return n * f . call ( n - 1 ) ; } } ; } } ; Function < Integer , Integer > fib = fix ( almost_fib ) ; Function < Integer , Integer > fac = fix ( almost_fac ) ; System . out . println ( "fib(10) = " + fib . call ( 10 ) ) ; System . out . println ( "fac(10) = " + fac . call ( 10 ) ) ; } } 
import java . util . function . Function ; @ FunctionalInterface public interface SelfApplicable < OUTPUT > extends Function < SelfApplicable < OUTPUT > , OUTPUT > { public default OUTPUT selfApply ( ) { return apply ( this ) ; } } 
import java . util . function . Function ; import java . util . function . UnaryOperator ; @ FunctionalInterface public interface FixedPoint < FUNCTION > extends Function < UnaryOperator < FUNCTION > , FUNCTION > { } 
import java . util . Arrays ; import java . util . Optional ; import java . util . function . Function ; import java . util . function . BiFunction ; @ FunctionalInterface public interface VarargsFunction < INPUTS , OUTPUT > extends Function < INPUTS [ ] , OUTPUT > { @ SuppressWarnings ( "unchecked" ) public OUTPUT apply ( INPUTS ... inputs ) ; public static < INPUTS , OUTPUT > VarargsFunction < INPUTS , OUTPUT > from ( Function < INPUTS [ ] , OUTPUT > function ) { return function :: apply ; } public static < INPUTS , OUTPUT > VarargsFunction < INPUTS , OUTPUT > upgrade ( Function < INPUTS , OUTPUT > function ) { return inputs -> function . apply ( inputs [ 0 ] ) ; } public static < INPUTS , OUTPUT > VarargsFunction < INPUTS , OUTPUT > upgrade ( BiFunction < INPUTS , INPUTS , OUTPUT > function ) { return inputs -> function . apply ( inputs [ 0 ] , inputs [ 1 ] ) ; } @ SuppressWarnings ( "unchecked" ) public default < POST_OUTPUT > VarargsFunction < INPUTS , POST_OUTPUT > andThen ( VarargsFunction < OUTPUT , POST_OUTPUT > after ) { return inputs -> after . apply ( apply ( inputs ) ) ; } @ SuppressWarnings ( "unchecked" ) public default Function < INPUTS , OUTPUT > toFunction ( ) { return input -> apply ( input ) ; } @ SuppressWarnings ( "unchecked" ) public default BiFunction < INPUTS , INPUTS , OUTPUT > toBiFunction ( ) { return ( input , input2 ) -> apply ( input , input2 ) ; } @ SuppressWarnings ( "unchecked" ) public default < PRE_INPUTS > VarargsFunction < PRE_INPUTS , OUTPUT > transformArguments ( Function < PRE_INPUTS , INPUTS > transformer ) { return inputs -> apply ( ( INPUTS [ ] ) Arrays . stream ( inputs ) . parallel ( ) . map ( transformer ) . toArray ( ) ) ; } } 
import java . math . BigDecimal ; import java . math . BigInteger ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Map ; import java . util . function . Function ; import java . util . function . UnaryOperator ; import java . util . stream . Collectors ; import java . util . stream . LongStream ; @ FunctionalInterface public interface Y < FUNCTION > extends SelfApplicable < FixedPoint < FUNCTION > > { public static void main ( String ... arguments ) { BigInteger TWO = BigInteger . ONE . add ( BigInteger . ONE ) ; Function < Number , Long > toLong = Number :: longValue ; Function < Number , BigInteger > toBigInteger = toLong . andThen ( BigInteger :: valueOf ) ; Y < VarargsFunction < Number , Number > > combinator = y -> f -> x -> f . apply ( y . selfApply ( ) . apply ( f ) ) . apply ( x ) ; FixedPoint < VarargsFunction < Number , Number > > fixedPoint = combinator . selfApply ( ) ; VarargsFunction < Number , Number > fibonacci = fixedPoint . apply ( f -> VarargsFunction . upgrade ( toBigInteger . andThen ( n -> ( n . compareTo ( TWO ) <= 0 ) ? 1 : new BigInteger ( f . apply ( n . subtract ( BigInteger . ONE ) ) . toString ( ) ) . add ( new BigInteger ( f . apply ( n . subtract ( TWO ) ) . toString ( ) ) ) ) ) ) ; VarargsFunction < Number , Number > factorial = fixedPoint . apply ( f -> VarargsFunction . upgrade ( toBigInteger . andThen ( n -> ( n . compareTo ( BigInteger . ONE ) <= 0 ) ? 1 : n . multiply ( new BigInteger ( f . apply ( n . subtract ( BigInteger . ONE ) ) . toString ( ) ) ) ) ) ) ; VarargsFunction < Number , Number > ackermann = fixedPoint . apply ( f -> VarargsFunction . upgrade ( ( BigInteger m , BigInteger n ) -> m . equals ( BigInteger . ZERO ) ? n . add ( BigInteger . ONE ) : f . apply ( m . subtract ( BigInteger . ONE ) , n . equals ( BigInteger . ZERO ) ? BigInteger . ONE : f . apply ( m , n . subtract ( BigInteger . ONE ) ) ) ) . transformArguments ( toBigInteger ) ) ; Map < String , VarargsFunction < Number , Number > > functions = new HashMap < > ( ) ; functions . put ( "fibonacci" , fibonacci ) ; functions . put ( "factorial" , factorial ) ; functions . put ( "ackermann" , ackermann ) ; Map < VarargsFunction < Number , Number > , Number [ ] > parameters = new HashMap < > ( ) ; parameters . put ( functions . get ( "fibonacci" ) , new Number [ ] { 20 } ) ; parameters . put ( functions . get ( "factorial" ) , new Number [ ] { 10 } ) ; parameters . put ( functions . get ( "ackermann" ) , new Number [ ] { 3 , 2 } ) ; functions . entrySet ( ) . stream ( ) . parallel ( ) . map ( entry -> entry . getKey ( ) + Arrays . toString ( parameters . get ( entry . getValue ( ) ) ) + " = " + entry . getValue ( ) . apply ( parameters . get ( entry . getValue ( ) ) ) ) . forEach ( System . out :: println ) ; } } 
factorial [ 10 ] = 3628800 ackermann [ 3 , 2 ] = 29 fibonacci [ 20 ] = 6765 
import java . util . * ; class Zeckendorf { public static String getZeckendorf ( int n ) { if ( n == 0 ) return "0" ; List < Integer > fibNumbers = new ArrayList < Integer > ( ) ; fibNumbers . add ( 1 ) ; int nextFib = 2 ; while ( nextFib <= n ) { fibNumbers . add ( nextFib ) ; nextFib += fibNumbers . get ( fibNumbers . size ( ) - 2 ) ; } StringBuilder sb = new StringBuilder ( ) ; for ( int i = fibNumbers . size ( ) - 1 ; i >= 0 ; i -- ) { int fibNumber = fibNumbers . get ( i ) ; sb . append ( ( fibNumber <= n ) ? "1" : "0" ) ; if ( fibNumber <= n ) n -= fibNumber ; } return sb . toString ( ) ; } public static void main ( String [ ] args ) { for ( int i = 0 ; i <= 20 ; i ++ ) System . out . println ( "Z(" + i + ")=" + getZeckendorf ( i ) ) ; } } 
import java . util . ArrayList ; import java . util . List ; public class Zeckendorf { private List < Integer > getFibList ( final int maxNum , final int n1 , final int n2 , final List < Integer > fibs ) { if ( n2 > maxNum ) return fibs ; fibs . add ( n2 ) ; return getFibList ( maxNum , n2 , n1 + n2 , fibs ) ; } public String getZeckendorf ( final int num ) { if ( num <= 0 ) return "0" ; final List < Integer > fibs = getFibList ( num , 1 , 2 , new ArrayList < Integer > ( ) { { add ( 1 ) ; } } ) ; return getZeckString ( "" , num , fibs . size ( ) - 1 , fibs ) ; } private String getZeckString ( final String zeck , final int num , final int index , final List < Integer > fibs ) { final int curFib = fibs . get ( index ) ; final boolean placeZeck = num >= curFib ; final String outString = placeZeck ? zeck + "1" : zeck + "0" ; final int outNum = placeZeck ? num - curFib : num ; if ( index == 0 ) return outString ; return getZeckString ( outString , outNum , index - 1 , fibs ) ; } public static void main ( final String [ ] args ) { final Zeckendorf zeckendorf = new Zeckendorf ( ) ; for ( int i = 0 ; i <= 20 ; i ++ ) { System . out . println ( "Z(" + i + "):\t" + zeckendorf . getZeckendorf ( i ) ) ; } } } 
System . out . println ( Math . pow ( 0 , 0 ) ) ; 
public static int [ ] [ ] Zig_Zag ( final int size ) { int [ ] [ ] data = new int [ size ] [ size ] ; int i = 1 ; int j = 1 ; for ( int element = 0 ; element < size * size ; element ++ ) { data [ i - 1 ] [ j - 1 ] = element ; if ( ( i + j ) % 2 == 0 ) { if ( j < size ) j ++ ; else i += 2 ; if ( i > 1 ) i -- ; } else { if ( i < size ) i ++ ; else j += 2 ; if ( j > 1 ) j -- ; } } return data ; } 
